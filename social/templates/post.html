{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>create a vibe ðŸŽ¨ - Kishiface</title>
    <link rel="shortcut icon" href="{% static 'images/logo.jpg' %}" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Kishiface-Inspired Design Variables */
        :root {
            --ig-bg: #ffffff;
            --ig-header-bg: #ffffff;
            --ig-border: #dbdbdb;
            --ig-primary: #0095f6;
            --ig-danger: #ed4956;
            --ig-text: #262626;
            --ig-text-light: #8e8e8e;
            --ig-text-lighter: #c7c7c7;
            --ig-separator: #efefef;
            --ig-input-bg: #fafafa;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            
            /* Modern Aesthetic Colors */
            --neon-pink: #ff10f0;
            --neon-blue: #00f3ff;
            --neon-purple: #bc13fe;
            --neon-green: #39ff14;
            --soft-lavender: #e6e6fa;
            --millennial-pink: #ffd1dc;
            --y2k-yellow: #fced2d;
            --vaporwave: #6f4b8f;
            --aesthetic-orange: #ff8c42;
            --e-girl: #ff69b4;
            
            /* Editor Colors */
            --editor-toolbar: #1a1a1a;
            --editor-border: #333333;
            --editor-overlay: rgba(0,0,0,0.9);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--ig-bg);
            color: var(--ig-text);
            line-height: 1.5;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Main Container */
        .kf-main-container {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            background-color: var(--ig-bg);
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Post Creation Card */
        .kf-post-card {
            background-color: var(--ig-bg);
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .kf-post-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--ig-separator);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--ig-header-bg);
            flex-shrink: 0;
        }

        .kf-post-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--ig-text);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .kf-post-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--ig-text);
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kf-share-btn-header {
            background: none;
            border: none;
            color: var(--ig-primary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .kf-share-btn-header:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .kf-vibe-check {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            animation: subtleWiggle 3s infinite;
        }

        @keyframes subtleWiggle {
            0%, 100% { transform: rotate(0deg); }
            5% { transform: rotate(5deg); }
            10% { transform: rotate(-5deg); }
            15% { transform: rotate(0deg); }
        }

        @keyframes floatEmoji {
            0% { transform: translateY(0) scale(1) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-150px) scale(2) rotate(360deg); opacity: 0; }
        }

        @keyframes glowPulse {
            0%, 100% { filter: drop-shadow(0 0 5px rgba(255,255,255,0.5)); }
            50% { filter: drop-shadow(0 0 20px rgba(255,255,255,0.8)); }
        }

        /* Content Area - Scrollable */
        .kf-post-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: 20px;
            scrollbar-width: thin;
        }

        .kf-post-content::-webkit-scrollbar {
            width: 4px;
        }

        .kf-post-content::-webkit-scrollbar-track {
            background: var(--ig-separator);
        }

        .kf-post-content::-webkit-scrollbar-thumb {
            background: var(--ig-text-light);
            border-radius: 2px;
        }

        /* ===== MOOD SELECTOR - Modern ===== */
        .kf-mood-section {
            padding: 12px 16px;
            border-bottom: 1px solid var(--ig-separator);
            background: linear-gradient(145deg, #fff9f9 0%, #f9f9ff 100%);
        }

        .kf-mood-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--ig-text);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kf-mood-label i {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .kf-mood-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .kf-mood-dropdown-container {
            position: relative;
            flex: 1;
        }

        .kf-mood-selector-btn {
            width: 100%;
            padding: 10px 12px;
            background: var(--ig-white);
            border: 2px solid var(--ig-separator);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            font-size: 14px;
            color: var(--ig-text);
        }

        .kf-mood-selector-btn:hover {
            border-color: var(--ig-primary);
        }

        .kf-selected-mood {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kf-selected-mood-emoji {
            font-size: 18px;
        }

        .kf-selected-mood-text {
            font-weight: 500;
            font-size: 13px;
        }

        .kf-mood-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: var(--ig-white);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            max-height: 250px;
            overflow-y: auto;
            display: none;
            animation: slideDown 0.2s ease;
        }

        .kf-mood-dropdown.show {
            display: block;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .kf-mood-option {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            border-bottom: 1px solid var(--ig-separator);
        }

        .kf-mood-option:last-child {
            border-bottom: none;
        }

        .kf-mood-option:hover {
            background: var(--ig-input-bg);
        }

        .kf-mood-option-emoji {
            font-size: 18px;
            width: 30px;
            text-align: center;
        }

        .kf-mood-option-info {
            flex: 1;
        }

        .kf-mood-option-name {
            font-weight: 600;
            font-size: 13px;
        }

        .kf-mood-option-vibe {
            font-size: 11px;
            color: var(--ig-text-light);
        }

        /* Custom Mood */
        .kf-custom-mood-container {
            margin-top: 8px;
        }

        .kf-custom-mood-row {
            display: flex;
            gap: 6px;
        }

        .kf-custom-mood-input {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid var(--ig-separator);
            border-radius: 12px;
            font-size: 13px;
            outline: none;
        }

        .kf-custom-mood-input:focus {
            border-color: var(--ig-primary);
        }

        .kf-add-custom-btn {
            padding: 10px 16px;
            background: var(--ig-primary);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .kf-add-custom-btn:hover {
            opacity: 0.9;
        }

        .kf-custom-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .kf-custom-suggestion {
            padding: 6px 12px;
            background: var(--ig-input-bg);
            border: 1px solid var(--ig-separator);
            border-radius: 16px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .kf-custom-suggestion:hover {
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-purple));
            color: white;
            transform: scale(1.05);
        }

        /* Active Mood Badge */
        .kf-active-mood {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            background: linear-gradient(135deg, var(--ig-primary), #00b8ff);
            border-radius: 20px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            margin-top: 8px;
            animation: moodPop 0.3s ease;
        }

        .kf-active-mood.hidden {
            display: none;
        }

        @keyframes moodPop {
            0% { transform: scale(0); }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Textarea */
        .kf-textarea-container {
            padding: 12px 16px;
            border-bottom: 1px solid var(--ig-separator);
        }

        .kf-textarea {
            width: 100%;
            padding: 0;
            border: none;
            font-family: var(--font-family);
            font-size: 15px;
            resize: none;
            min-height: 60px;
            outline: none;
            background-color: transparent;
        }

        .kf-textarea::placeholder {
            color: var(--ig-text-light);
        }

        /* Media Grid */
        .kf-upload-section {
            padding: 12px 16px;
        }

        .kf-upload-label {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kf-media-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .kf-media-option {
            cursor: pointer;
        }

        .kf-media-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px 8px;
            background: var(--ig-white);
            border: 2px solid var(--ig-separator);
            border-radius: 12px;
            text-align: center;
            gap: 4px;
            transition: all 0.2s ease;
        }

        .kf-media-card:hover {
            border-color: var(--ig-primary);
            transform: translateY(-2px);
        }

        .kf-media-card i {
            font-size: 24px;
            color: var(--ig-text);
        }

        .kf-media-label {
            font-size: 12px;
            font-weight: 600;
        }

        .kf-media-sub-label {
            font-size: 9px;
            color: var(--ig-text-light);
        }

        .kf-media-option.camera .kf-media-card {
            background: linear-gradient(145deg, #fff0f0, #ffe5e5);
            border-color: var(--ig-primary);
        }

        /* Image Preview Grid */
        .kf-image-preview-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin: 12px 0;
        }

        .kf-image-preview-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid var(--ig-separator);
        }

        .kf-image-preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .kf-image-preview-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        .kf-image-preview-item:hover .kf-image-preview-overlay {
            opacity: 1;
        }

        .kf-image-preview-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            background: var(--ig-danger);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            cursor: pointer;
            opacity: 0;
            z-index: 10;
        }

        .kf-image-preview-item:hover .kf-image-preview-remove {
            opacity: 1;
        }

        /* ===== SNAPCHAT-STYLE AR CAMERA MODAL ===== */
        .kf-camera-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 2000;
            flex-direction: column;
        }

        .kf-camera-modal.active {
            display: flex;
        }

        /* Snapchat top bar: X on left, flash/timer/settings on right */
        .kf-camera-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 52px 16px 16px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.45) 0%, transparent 100%);
            pointer-events: none;
        }

        .kf-camera-close {
            pointer-events: auto;
            background: none;
            border: none;
            color: white;
            font-size: 22px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: drop-shadow(0 1px 3px rgba(0,0,0,0.7));
        }

        /* Snapchat top-right icon cluster */
        .snap-top-right {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 18px;
            align-items: center;
        }

        .snap-top-icon {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: drop-shadow(0 1px 3px rgba(0,0,0,0.7));
        }

        /* Hidden title â€” Snapchat has no title text */
        .kf-camera-title { display: none; }

        .kf-camera-preview {
            width: 100%;
            height: 100%;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        .kf-camera-live {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: relative;
            z-index: 1;
        }

        .kf-ar-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5;
            pointer-events: none;
        }

        .kf-ar-filter-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .kf-ar-face-mesh {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 15;
            opacity: 0.3;
        }

        .kf-ar-object {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            animation: float 4s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(255,255,255,0.5));
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg) scale(1); }
            33% { transform: translateY(-15px) rotate(5deg) scale(1.05); }
            66% { transform: translateY(-5px) rotate(-5deg) scale(0.95); }
        }

        .kf-ar-touch-effect {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            transform: scale(0);
            animation: touchPulse 0.8s ease-out forwards;
            z-index: 100;
        }

        @keyframes touchPulse {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(2); opacity: 0.5; }
            100% { transform: scale(3); opacity: 0; }
        }

        /* â”€â”€ SNAPCHAT LENS CAROUSEL (bottom, horizontal scroll) â”€â”€ */
        .snap-lens-carousel-wrap {
            position: absolute;
            bottom: 148px;
            left: 0; right: 0;
            z-index: 50;
            pointer-events: none;
        }

        .snap-lens-carousel {
            display: flex;
            gap: 10px;
            padding: 0 20px;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            pointer-events: auto;
            align-items: center;
            justify-content: flex-start;
        }

        .snap-lens-carousel::-webkit-scrollbar { display: none; }

        /* "Lens Explorer" search icon at left */
        .snap-lens-search {
            flex-shrink: 0;
            width: 52px; height: 52px;
            border-radius: 50%;
            background: rgba(255,255,255,0.18);
            backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255,255,255,0.35);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            cursor: pointer;
            scroll-snap-align: start;
        }

        /* Individual lens tile */
        .snap-lens-item {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            scroll-snap-align: start;
        }

        .snap-lens-circle {
            width: 52px; height: 52px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            transition: transform 0.2s, border-color 0.2s;
            position: relative;
        }

        .snap-lens-item.active .snap-lens-circle {
            border-color: #FFFC00; /* Snapchat yellow */
            border-width: 2.5px;
            transform: scale(1.18);
            box-shadow: 0 0 0 3px rgba(255,252,0,0.25);
        }

        .snap-lens-label {
            font-size: 10px;
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* â”€â”€ SNAPCHAT FACE EFFECTS ROW (above lens carousel) â”€â”€ */
        .snap-effects-row-wrap {
            position: absolute;
            bottom: 220px;
            left: 0; right: 0;
            z-index: 50;
            pointer-events: none;
            display: none; /* shown when a lens is active */
        }

        .snap-effects-row-wrap.visible {
            display: block;
        }

        .snap-effects-row {
            display: flex;
            gap: 10px;
            padding: 0 20px;
            overflow-x: auto;
            scrollbar-width: none;
            pointer-events: auto;
        }

        .snap-effects-row::-webkit-scrollbar { display: none; }

        .snap-effect-chip {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        .snap-effect-chip-circle {
            width: 44px; height: 44px;
            border-radius: 50%;
            background: rgba(0,0,0,0.45);
            backdrop-filter: blur(8px);
            border: 1.5px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }

        .snap-effect-chip.active .snap-effect-chip-circle {
            border-color: #FFFC00;
            background: rgba(255,252,0,0.15);
        }

        .snap-effect-chip-label {
            font-size: 9px;
            color: rgba(255,255,255,0.85);
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0,0,0,0.9);
            white-space: nowrap;
        }

        /* â”€â”€ SNAPCHAT BOTTOM CONTROLS BAR â”€â”€ */
        .snap-bottom-bar {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 148px;
            z-index: 60;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding-bottom: 32px;
            background: linear-gradient(to top, rgba(0,0,0,0.55) 0%, transparent 100%);
            pointer-events: none;
        }

        .snap-main-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0;
            width: 100%;
            padding: 0 24px;
            pointer-events: auto;
        }

        /* Left slot: gallery thumbnail */
        .snap-gallery-thumb {
            flex: 1;
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }

        .snap-gallery-btn {
            width: 46px; height: 46px;
            border-radius: 10px;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            cursor: pointer;
        }

        /* Center: Snapchat shutter button */
        .snap-shutter-wrap {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .snap-shutter {
            width: 72px; height: 72px;
            border-radius: 50%;
            background: white;
            border: 5px solid rgba(255,255,255,0.45);
            cursor: pointer;
            position: relative;
            transition: transform 0.12s;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.15);
        }

        .snap-shutter:active { transform: scale(0.9); }

        /* Right slot: flip camera */
        .snap-right-slot {
            flex: 1;
            display: flex;
            justify-content: flex-end;
            align-items: center;
        }

        .snap-flip-btn {
            width: 46px; height: 46px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.35s;
        }

        .snap-flip-btn:active { transform: rotate(180deg); }

        /* â”€â”€ SNAPCHAT RIGHT SIDEBAR ICONS â”€â”€ */
        .snap-sidebar {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 60;
            align-items: center;
            pointer-events: auto;
        }

        .snap-sidebar-btn {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: rgba(0,0,0,0.38);
            backdrop-filter: blur(8px);
            border: none;
            color: white;
            font-size: 17px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .snap-sidebar-btn:active { background: rgba(255,252,0,0.25); }

        .snap-sidebar-btn.active { background: rgba(255,252,0,0.35); color: #FFFC00; }

        /* â”€â”€ SNAPCHAT AR TIMER (top center) â”€â”€ */
        .kf-ar-timer {
            position: absolute;
            top: 56px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 13px;
            font-weight: 700;
            font-family: monospace;
            background: rgba(0,0,0,0.35);
            padding: 4px 12px;
            border-radius: 20px;
            z-index: 80;
            letter-spacing: 1px;
            display: none;
        }

        /* â”€â”€ SNAPCHAT GESTURE HINT â”€â”€ */
        .kf-ar-gesture-hint {
            position: absolute;
            bottom: 172px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 13px;
            font-weight: 600;
            text-align: center;
            background: rgba(0,0,0,0.52);
            padding: 7px 18px;
            border-radius: 20px;
            backdrop-filter: blur(8px);
            z-index: 40;
            pointer-events: none;
            white-space: nowrap;
            transition: opacity 0.4s;
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
        }

        /* â”€â”€ SNAPCHAT SPEED CONTROLS (kept but hidden â€” tuck into sidebar) â”€â”€ */
        .kf-ar-speed-controls { display: none; }

        /* Captured Image â€” Snapchat style (full screen + right-side action bar) */
        .kf-captured-image {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            z-index: 200;
        }

        .kf-captured-image.hidden { display: none; }

        .kf-captured-image img {
            flex: 1;
            object-fit: cover;
            background: #000;
            width: 100%;
        }

        /* Snapchat post-capture: send / retake row at bottom */
        .kf-captured-actions {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px 40px;
            background: linear-gradient(to top, rgba(0,0,0,0.75) 0%, transparent 100%);
        }

        .kf-captured-action-btn {
            padding: 12px 28px;
            border: none;
            border-radius: 28px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.15s;
            letter-spacing: 0.3px;
        }

        .kf-captured-action-btn:active { transform: scale(0.95); }

        .kf-captured-action-btn.keep {
            background: #FFFC00;
            color: #000;
        }

        .kf-captured-action-btn.retake {
            background: rgba(255,255,255,0.18);
            color: white;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* â”€â”€ SNAPCHAT snap-edit toolbar (top of captured image) â”€â”€ */
        .snap-edit-bar {
            position: absolute;
            top: 0; left: 0; right: 0;
            display: flex;
            justify-content: flex-end;
            gap: 6px;
            padding: 52px 14px 14px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.4) 0%, transparent 100%);
            z-index: 210;
        }

        .snap-edit-btn {
            width: 38px; height: 38px;
            border-radius: 50%;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(6px);
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Old controls hidden â€” replaced by snap layout */
        .kf-camera-controls { display: none; }
        .kf-camera-flip-btn { display: none; }
        .kf-camera-capture-btn { display: none; }

        /* Old filter/effects panels hidden */
        .kf-ar-filter-selector { display: none !important; }
        .kf-ar-effects-panel { display: none !important; }

        /* â”€â”€ LENS NAME BADGE (center screen when lens selected) â”€â”€ */
        .snap-lens-badge {
            position: absolute;
            top: 115px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px);
            color: white;
            font-size: 13px;
            font-weight: 700;
            padding: 5px 16px;
            border-radius: 20px;
            z-index: 80;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.4s;
            white-space: nowrap;
        }

        .snap-lens-badge.visible {
            opacity: 1;
        }

        /* Recording Status */
        .kf-recording-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 12px 0;
            padding: 12px 16px;
            background: linear-gradient(90deg, #ffe5e5, #fff0f0);
            border: 1px solid var(--ig-separator);
            border-radius: 30px;
            animation: glowPulse 2s infinite;
        }

        .kf-recording-status.hidden {
            display: none;
        }

        .kf-recording-dot {
            width: 8px;
            height: 8px;
            background-color: var(--ig-danger);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .kf-recording-text {
            font-size: 13px;
            font-weight: 500;
            color: var(--ig-danger);
            flex: 1;
        }

        .kf-recording-time {
            font-size: 12px;
            color: var(--ig-text);
            font-family: monospace;
        }

        /* Video/Audio Players */
        .kf-video-player, .kf-audio-player {
            margin: 12px 0;
            padding: 12px;
            background-color: var(--ig-input-bg);
            border: 1px solid var(--ig-separator);
            border-radius: 12px;
            display: none;
        }

        .kf-video-player.active, .kf-audio-player.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        .kf-video-player-header, .kf-audio-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .kf-video-player-title, .kf-audio-player-title {
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .kf-video-element {
            width: 100%;
            border-radius: 8px;
            background-color: #000;
            aspect-ratio: 16/9;
        }

        .kf-video-actions, .kf-audio-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .kf-video-action-btn, .kf-audio-action-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .kf-video-keep, .kf-audio-keep {
            background-color: var(--ig-primary);
            color: white;
        }

        /* Audio Player */
        .kf-custom-audio-player {
            width: 100%;
        }

        .kf-audio-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .kf-audio-play-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--ig-primary);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kf-audio-play-btn.playing {
            background: linear-gradient(135deg, var(--ig-primary), #00b8ff);
        }

        .kf-audio-info {
            flex: 1;
        }

        .kf-audio-filename {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .kf-audio-time {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--ig-text-light);
            font-family: monospace;
        }

        .kf-audio-progress {
            width: 100%;
            height: 3px;
            background-color: var(--ig-separator);
            border-radius: 2px;
            overflow: hidden;
            cursor: pointer;
            margin: 4px 0;
        }

        .kf-audio-progress-filled {
            height: 100%;
            background: linear-gradient(90deg, var(--ig-primary), #00b8ff);
            width: 0%;
            transition: width 0.1s linear;
        }

        /* Preview Box */
        .kf-preview-container {
            margin-top: 12px;
        }

        .kf-preview-box {
            border: 1px solid var(--ig-separator);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .kf-preview-box.has-content {
            border-color: var(--ig-primary);
            background: linear-gradient(145deg, var(--ig-input-bg), white);
        }

        .kf-preview-icon {
            font-size: 24px;
            color: var(--ig-text-light);
            margin-bottom: 4px;
        }

        .kf-preview-text {
            color: var(--ig-text-light);
            font-size: 13px;
        }

        .kf-preview-item {
            margin-top: 4px;
            font-size: 13px;
            color: var(--ig-primary);
            font-weight: 600;
        }

        .kf-file-size-info {
            font-size: 11px;
            color: var(--ig-text-light);
            margin-top: 4px;
        }

        /* Media Editor Modal */
        .kf-media-editor-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 2000;
            flex-direction: column;
        }

        .kf-media-editor-modal.active {
            display: flex;
        }

        .kf-editor-header {
            padding: 12px 16px;
            background: var(--editor-toolbar);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .kf-editor-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kf-editor-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kf-editor-canvas-container {
            flex: 1;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #000;
            overflow: hidden;
        }

        .kf-editor-canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            background: #000;
            position: relative;
            z-index: 1;
        }

        .kf-editor-overlay-text {
            position: absolute;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
            cursor: move;
            user-select: none;
            padding: 8px;
            border: 2px dashed rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            font-size: 32px;
            transform: translate(-50%, -50%);
            touch-action: none;
            pointer-events: auto;
        }

        .kf-overlay-delete {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background: var(--ig-danger);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            cursor: pointer;
            z-index: 20;
            border: 2px solid white;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .kf-editor-overlay-text:hover .kf-overlay-delete {
            opacity: 1;
        }

        .kf-editor-text-input {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            padding: 12px 16px;
            background: white;
            border: none;
            border-radius: 24px;
            font-size: 16px;
            outline: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 2100;
        }

        .kf-editor-text-input.hidden {
            display: none;
        }

        .kf-editor-toolbar {
            background: var(--editor-toolbar);
            padding: 10px;
            display: flex;
            overflow-x: auto;
            gap: 8px;
            flex-shrink: 0;
            scrollbar-width: thin;
        }

        .kf-editor-tool-btn {
            background: none;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }

        .kf-editor-tool-btn.active {
            background: var(--ig-primary);
        }

        .kf-editor-panel {
            display: none;
            background: var(--editor-toolbar);
            padding: 10px;
            border-top: 1px solid var(--editor-border);
            flex-shrink: 0;
            max-height: 100px;
            overflow-y: auto;
        }

        .kf-editor-panel.active {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .kf-color-picker {
            width: 30px;
            height: 30px;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .kf-color-picker:hover {
            transform: scale(1.1);
        }

        .kf-slider {
            flex: 1;
            min-width: 100px;
            height: 4px;
            background: #444;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .kf-filter-grid {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 4px 0;
        }

        .kf-filter-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        .kf-filter-preview {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid transparent;
        }

        .kf-filter-option.active .kf-filter-preview {
            border-color: var(--ig-primary);
        }

        .kf-filter-name {
            font-size: 10px;
            color: white;
        }

        .kf-editor-footer {
            padding: 10px 16px;
            background: var(--editor-toolbar);
            border-top: 1px solid var(--editor-border);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            flex-shrink: 0;
        }

        .kf-editor-btn {
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }

        .kf-editor-btn-primary {
            background: var(--ig-primary);
            color: white;
        }

        /* Video Recorder Modal */
        .kf-video-recorder-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1000;
            flex-direction: column;
        }

        .kf-video-recorder-modal.active {
            display: flex;
        }

        .kf-video-recorder-header {
            padding: 16px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: absolute;
            top: 0;
            width: 100%;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .kf-video-recorder-timer {
            font-size: 16px;
            font-weight: 600;
            background: rgba(0,0,0,0.4);
            padding: 6px 16px;
            border-radius: 30px;
            font-family: monospace;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .kf-video-recorder-close {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .kf-video-preview {
            width: 100%;
            height: 100%;
            background: #000;
            position: relative;
        }

        .kf-video-live {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .kf-video-recording-indicator {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(255,0,0,0.6);
            padding: 6px 16px;
            border-radius: 30px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .kf-video-controls {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
            padding: 30px 20px 20px;
        }

        .kf-video-main-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
        }

        .kf-video-record-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: white;
            border: 6px solid rgba(255,255,255,0.3);
            cursor: pointer;
            transition: all 0.2s;
        }

        .kf-video-record-btn.recording {
            background: var(--ig-danger);
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: none;
        }

        .kf-video-control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kf-sound-select-btn {
            background: rgba(255,255,255,0.15);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 30px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* Loading Overlay */
        .kf-loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .kf-loading-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .kf-loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .kf-loading-text {
            font-size: 18px;
            font-weight: 700;
            color: white;
            margin-bottom: 8px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .kf-loading-subtext {
            font-size: 14px;
            color: rgba(255,255,255,0.9);
        }

        /* Custom Alert Modal */
        .kf-alert-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 4000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .kf-alert-modal.active {
            display: flex;
        }

        .kf-alert-content {
            background: white;
            border-radius: 30px;
            padding: 30px;
            max-width: 320px;
            width: 100%;
            text-align: center;
            animation: alertPop 0.3s ease;
        }

        @keyframes alertPop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .kf-alert-emoji {
            font-size: 60px;
            margin-bottom: 20px;
            animation: glowPulse 2s infinite;
        }

        .kf-alert-title {
            font-size: 22px;
            font-weight: 800;
            color: var(--ig-text);
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .kf-alert-message {
            font-size: 15px;
            color: var(--ig-text-light);
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .kf-alert-buttons {
            display: flex;
            gap: 12px;
        }

        .kf-alert-btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 40px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .kf-alert-btn.primary {
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            color: white;
        }

        .kf-alert-btn.secondary {
            background: var(--ig-separator);
            color: var(--ig-text);
        }

        .kf-alert-btn.danger {
            background: var(--ig-danger);
            color: white;
        }

        .hidden {
            display: none !important;
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="kf-loading-overlay" id="loadingOverlay">
        <div class="kf-loading-spinner"></div>
        <div class="kf-loading-text" id="loadingText">curating your aesthetic... âœ¨</div>
        <div class="kf-loading-subtext" id="loadingSubtext">no thoughts just vibes</div>
    </div>

    <!-- Custom Alert Modal -->
    <div class="kf-alert-modal" id="alertModal">
        <div class="kf-alert-content">
            <div class="kf-alert-emoji" id="alertEmoji">âœ¨</div>
            <div class="kf-alert-title" id="alertTitle">bestie alert</div>
            <div class="kf-alert-message" id="alertMessage">this is a custom alert</div>
            <div class="kf-alert-buttons" id="alertButtons">
                <button class="kf-alert-btn primary" onclick="closeAlert()">ok</button>
            </div>
        </div>
    </div>

    <!-- Snapchat-Style AR Camera Modal -->
    <div id="cameraModal" class="kf-camera-modal">
        <div class="kf-camera-preview">
            <video id="cameraLive" class="kf-camera-live" autoplay playsinline></video>
            <canvas id="arFilterCanvas" class="kf-ar-filter-canvas"></canvas>
            <div id="arOverlay" class="kf-ar-overlay"></div>
            <canvas id="faceMeshCanvas" class="kf-ar-face-mesh"></canvas>

            <!-- Lens name badge -->
            <div class="snap-lens-badge" id="snapLensBadge">Clean</div>

            <!-- AR Gesture Hint -->
            <div class="kf-ar-gesture-hint" id="arGestureHint">ðŸ‘† tap for sparkles</div>

            <!-- AR Timer -->
            <div class="kf-ar-timer" id="arTimer">00:00</div>

            <!-- TOP BAR -->
            <div class="kf-camera-header">
                <button class="kf-camera-close" onclick="closeCamera()">
                    <i class="fas fa-times"></i>
                </button>
                <div class="kf-camera-title"></div>
                <div class="snap-top-right">
                    <button class="snap-top-icon" id="snapFlashBtn" onclick="toggleFlash()">
                        <i class="fas fa-bolt"></i>
                    </button>
                    <button class="snap-top-icon" onclick="toggleARMode()" id="arModeBtn">
                        <i class="fas fa-magic"></i>
                    </button>
                </div>
            </div>

            <!-- RIGHT SIDEBAR -->
            <div class="snap-sidebar">
                <button class="snap-sidebar-btn" onclick="snapSidebarAction('music')"><i class="fas fa-music"></i></button>
                <button class="snap-sidebar-btn" onclick="snapSidebarAction('text')"><i class="fas fa-font"></i></button>
                <button class="snap-sidebar-btn" onclick="snapSidebarAction('sticker')"><i class="fas fa-smile"></i></button>
                <button class="snap-sidebar-btn" onclick="snapSidebarAction('scissors')"><i class="fas fa-cut"></i></button>
                <button class="snap-sidebar-btn" onclick="snapSidebarAction('timer')"><i class="fas fa-stopwatch"></i></button>
            </div>

            <!-- FACE EFFECTS ROW (shown when lens active) -->
            <div class="snap-effects-row-wrap" id="snapEffectsRow">
                <div class="snap-effects-row">
                    <div class="snap-effect-chip" onclick="addAREffect('blush'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">â˜ºï¸</div>
                        <span class="snap-effect-chip-label">Blush</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('aura-glow'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸŸ£</div>
                        <span class="snap-effect-chip-label">Aura</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('freckles'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸŒŸ</div>
                        <span class="snap-effect-chip-label">Freckles</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('glitter-tears'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸ’§</div>
                        <span class="snap-effect-chip-label">Glitter</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('heart-glasses'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸ’•</div>
                        <span class="snap-effect-chip-label">Heart Lens</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('aura-glasses'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸ•¶ï¸</div>
                        <span class="snap-effect-chip-label">Aura Shades</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('halo'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸ˜‡</div>
                        <span class="snap-effect-chip-label">Halo</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('rainbow'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸŒˆ</div>
                        <span class="snap-effect-chip-label">Rainbow</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('brat-text'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸ</div>
                        <span class="snap-effect-chip-label">brat</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('sparkles'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">âœ¨</div>
                        <span class="snap-effect-chip-label">Sparkles</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('flower-crown'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸŒ¸</div>
                        <span class="snap-effect-chip-label">Flower Crown</span>
                    </div>
                    <div class="snap-effect-chip" onclick="addAREffect('diamond-crown'); toggleEffectChip(this)">
                        <div class="snap-effect-chip-circle">ðŸ’Ž</div>
                        <span class="snap-effect-chip-label">Diamond</span>
                    </div>
                </div>
            </div>

            <!-- LENS CAROUSEL -->
            <div class="snap-lens-carousel-wrap">
                <div class="snap-lens-carousel" id="snapLensCarousel">
                    <div class="snap-lens-search" onclick="showARGestureHint('ðŸ” lens explorer')">
                        <i class="fas fa-search"></i>
                    </div>
                    <div class="snap-lens-item active" onclick="snapSelectLens(this,'none','Clean','âœ¨')">
                        <div class="snap-lens-circle">âœ¨</div>
                        <span class="snap-lens-label">Clean</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'aura','Aura','ðŸŸ£')">
                        <div class="snap-lens-circle">ðŸŸ£</div>
                        <span class="snap-lens-label">Aura</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'brat','Brat','ðŸ')">
                        <div class="snap-lens-circle">ðŸ</div>
                        <span class="snap-lens-label">Brat</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'golden-hour','Golden Hour','ðŸŒ‡')">
                        <div class="snap-lens-circle">ðŸŒ‡</div>
                        <span class="snap-lens-label">Golden Hr</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'mob-wife','Mob Wife','ðŸ†')">
                        <div class="snap-lens-circle">ðŸ†</div>
                        <span class="snap-lens-label">Mob Wife</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'clean-girl','Clean Girl','ðŸ¤')">
                        <div class="snap-lens-circle">ðŸ¤</div>
                        <span class="snap-lens-label">Clean Girl</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'dark-academia','Dark Academia','ðŸ“š')">
                        <div class="snap-lens-circle">ðŸ“š</div>
                        <span class="snap-lens-label">Dark Acad</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'cottagecore','Cottagecore','ðŸ„')">
                        <div class="snap-lens-circle">ðŸ„</div>
                        <span class="snap-lens-label">Cottagecore</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'fairycore','Fairycore','ðŸ§š')">
                        <div class="snap-lens-circle">ðŸ§š</div>
                        <span class="snap-lens-label">Fairycore</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'vaporwave','Vaporwave','ðŸŒŠ')">
                        <div class="snap-lens-circle">ðŸŒŠ</div>
                        <span class="snap-lens-label">Vaporwave</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'glitchcore','Glitchcore','âš¡')">
                        <div class="snap-lens-circle">âš¡</div>
                        <span class="snap-lens-label">Glitchcore</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'filmgrain','Film Grain','ðŸŽžï¸')">
                        <div class="snap-lens-circle">ðŸŽžï¸</div>
                        <span class="snap-lens-label">Film Grain</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'y2k','Y2K','ðŸ’¿')">
                        <div class="snap-lens-circle">ðŸ’¿</div>
                        <span class="snap-lens-label">Y2K</span>
                    </div>
                    <div class="snap-lens-item" onclick="snapSelectLens(this,'coastal-cowgirl','Coastal','ðŸ¤ ')">
                        <div class="snap-lens-circle">ðŸ¤ </div>
                        <span class="snap-lens-label">Coastal</span>
                    </div>
                </div>
            </div>

            <!-- BOTTOM SHUTTER BAR -->
            <div class="snap-bottom-bar">
                <div class="snap-main-controls">
                    <div class="snap-gallery-thumb">
                        <label class="snap-gallery-btn">
                            <input type="file" accept="image/*" style="display:none" onchange="handleSnapGallery(this)">
                            <i class="fas fa-images"></i>
                        </label>
                    </div>
                    <div class="snap-shutter-wrap">
                        <button class="snap-shutter" id="cameraCaptureBtn" onclick="capturePhoto()"></button>
                    </div>
                    <div class="snap-right-slot">
                        <button class="snap-flip-btn" onclick="flipCamera()">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Captured photo overlay -->
            <div id="capturedImageContainer" class="kf-captured-image hidden">
                <img id="capturedImage" src="" alt="Captured">
                <div class="snap-edit-bar">
                    <button class="snap-edit-btn"><i class="fas fa-pen"></i></button>
                    <button class="snap-edit-btn"><i class="fas fa-font"></i></button>
                    <button class="snap-edit-btn"><i class="fas fa-smile"></i></button>
                    <button class="snap-edit-btn"><i class="fas fa-crop-alt"></i></button>
                </div>
                <div class="kf-captured-actions">
                    <button class="kf-captured-action-btn retake" onclick="retakePhoto()">
                        <i class="fas fa-redo"></i> Retake
                    </button>
                    <button class="kf-captured-action-btn keep" onclick="keepPhoto()">
                        Save &amp; Use <i class="fas fa-arrow-right"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Hidden old controls for JS compatibility -->
        <div class="kf-camera-controls" style="display:none">
            <button class="kf-camera-flip-btn" onclick="flipCamera()"><i class="fas fa-sync-alt"></i></button>
            <button class="kf-camera-capture-btn" onclick="capturePhoto()"></button>
        </div>
    </div>

    <!-- Media Editor Modal -->
    <div class="kf-media-editor-modal" id="mediaEditorModal">
        <div class="kf-editor-header">
            <div class="kf-editor-title">
                <i class="fas fa-pen"></i> Edit Media
            </div>
            <button class="kf-editor-close" onclick="closeMediaEditor()">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="kf-editor-content">
            <div class="kf-editor-canvas-container" id="editorCanvasContainer" onclick="deselectOverlay()">
                <canvas id="editorCanvas" class="kf-editor-canvas"></canvas>
                <video id="editorVideo" class="kf-editor-canvas hidden" controls style="max-width:100%; max-height:100%;"></video>
            </div>
            
            <input type="text" class="kf-editor-text-input hidden" id="editorTextInput" placeholder="Type your text...">
            
            <div class="kf-editor-toolbar">
                <button class="kf-editor-tool-btn" onclick="showEditorPanel('filters', this)">
                    <i class="fas fa-filter"></i> Filters
                </button>
                <button class="kf-editor-tool-btn" onclick="showEditorPanel('adjust', this)">
                    <i class="fas fa-sliders-h"></i> Adjust
                </button>
                <button class="kf-editor-tool-btn" onclick="showEditorPanel('text', this)">
                    <i class="fas fa-font"></i> Text
                </button>
                <button class="kf-editor-tool-btn" onclick="showEditorPanel('stickers', this)">
                    <i class="fas fa-smile"></i> Stickers
                </button>
                <button class="kf-editor-tool-btn" onclick="showEditorPanel('draw', this)">
                    <i class="fas fa-pencil-alt"></i> Draw
                </button>
                <button class="kf-editor-tool-btn" onclick="showEditorPanel('trim', this)" id="trimVideoBtn">
                    <i class="fas fa-cut"></i> Trim
                </button>
            </div>
            
            <!-- Filters Panel -->
            <div class="kf-editor-panel" id="filtersPanel">
                <div class="kf-filter-grid">
                    <div class="kf-filter-option active" onclick="applyFilter('normal', this)">
                        <div class="kf-filter-preview" style="background: linear-gradient(45deg, #667eea, #764ba2);"></div>
                        <span class="kf-filter-name">Normal</span>
                    </div>
                    <div class="kf-filter-option" onclick="applyFilter('vintage', this)">
                        <div class="kf-filter-preview" style="background: linear-gradient(45deg, #f093fb, #f5576c);"></div>
                        <span class="kf-filter-name">Vintage</span>
                    </div>
                    <div class="kf-filter-option" onclick="applyFilter('bw', this)">
                        <div class="kf-filter-preview" style="background: linear-gradient(45deg, #4a4a4a, #6b6b6b);"></div>
                        <span class="kf-filter-name">B&W</span>
                    </div>
                    <div class="kf-filter-option" onclick="applyFilter('vivid', this)">
                        <div class="kf-filter-preview" style="background: linear-gradient(45deg, #00d2ff, #3a7bd5);"></div>
                        <span class="kf-filter-name">Vivid</span>
                    </div>
                    <div class="kf-filter-option" onclick="applyFilter('cool', this)">
                        <div class="kf-filter-preview" style="background: linear-gradient(45deg, #4facfe, #00f2fe);"></div>
                        <span class="kf-filter-name">Cool</span>
                    </div>
                    <div class="kf-filter-option" onclick="applyFilter('warm', this)">
                        <div class="kf-filter-preview" style="background: linear-gradient(45deg, #ff9a9e, #fad0c4);"></div>
                        <span class="kf-filter-name">Warm</span>
                    </div>
                </div>
            </div>
            
            <!-- Adjust Panel -->
            <div class="kf-editor-panel" id="adjustPanel">
                <div style="flex: 1;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <span style="color: white; width: 70px; font-size: 12px;">Brightness</span>
                        <div class="kf-slider" onclick="adjustBrightness(event)">
                            <div class="kf-slider-fill" id="brightnessFill" style="width: 50%;"></div>
                        </div>
                        <input type="number" class="kf-slider-input" id="brightnessValue" value="50" min="0" max="100" onchange="setBrightness(this.value)">
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="color: white; width: 70px; font-size: 12px;">Contrast</span>
                        <div class="kf-slider" onclick="adjustContrast(event)">
                            <div class="kf-slider-fill" id="contrastFill" style="width: 50%;"></div>
                        </div>
                        <input type="number" class="kf-slider-input" id="contrastValue" value="50" min="0" max="100" onchange="setContrast(this.value)">
                    </div>
                </div>
            </div>
            
            <!-- Text Panel -->
            <div class="kf-editor-panel" id="textPanel">
                <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                    <button class="kf-editor-tool-btn" onclick="addTextOverlay()" style="background: var(--ig-primary);">
                        <i class="fas fa-plus"></i> Add
                    </button>
                    <div class="kf-color-picker" style="background: #ff1493;" onclick="setTextColor('#ff1493')"></div>
                    <div class="kf-color-picker" style="background: #ffffff;" onclick="setTextColor('#ffffff')"></div>
                    <div class="kf-color-picker" style="background: #000000;" onclick="setTextColor('#000000')"></div>
                    <div class="kf-color-picker" style="background: #ffeb3b;" onclick="setTextColor('#ffeb3b')"></div>
                    <div class="kf-color-picker" style="background: #00cc66;" onclick="setTextColor('#00cc66')"></div>
                    <div class="kf-color-picker" style="background: #0095f6;" onclick="setTextColor('#0095f6')"></div>
                    
                    <select class="kf-slider-input" onchange="setTextFont(this.value)">
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Impact">Impact</option>
                        <option value="Courier New">Courier</option>
                    </select>
                    
                    <button class="kf-editor-tool-btn" onclick="increaseTextSize()">
                        <i class="fas fa-plus"></i>
                    </button>
                    <button class="kf-editor-tool-btn" onclick="decreaseTextSize()">
                        <i class="fas fa-minus"></i>
                    </button>
                </div>
            </div>
            
            <!-- Stickers Panel -->
            <div class="kf-editor-panel" id="stickersPanel">
                <div style="display: flex; gap: 8px; overflow-x: auto;">
                    <div class="kf-filter-option" onclick="addSticker('âœ¨')">
                        <div class="kf-filter-preview" style="font-size: 24px; display: flex; align-items: center; justify-content: center; background: linear-gradient(45deg, #667eea, #764ba2);">âœ¨</div>
                        <span class="kf-filter-name">Sparkles</span>
                    </div>
                    <div class="kf-filter-option" onclick="addSticker('ðŸ’…')">
                        <div class="kf-filter-preview" style="font-size: 24px; display: flex; align-items: center; justify-content: center; background: linear-gradient(45deg, #f093fb, #f5576c);">ðŸ’…</div>
                        <span class="kf-filter-name">Slay</span>
                    </div>
                    <div class="kf-filter-option" onclick="addSticker('ðŸ”¥')">
                        <div class="kf-filter-preview" style="font-size: 24px; display: flex; align-items: center; justify-content: center; background: linear-gradient(45deg, #ff9a9e, #fad0c4);">ðŸ”¥</div>
                        <span class="kf-filter-name">Fire</span>
                    </div>
                    <div class="kf-filter-option" onclick="addSticker('â­')">
                        <div class="kf-filter-preview" style="font-size: 24px; display: flex; align-items: center; justify-content: center; background: linear-gradient(45deg, #ffd700, #ffb347);">â­</div>
                        <span class="kf-filter-name">Star</span>
                    </div>
                    <div class="kf-filter-option" onclick="addSticker('ðŸŽµ')">
                        <div class="kf-filter-preview" style="font-size: 24px; display: flex; align-items: center; justify-content: center; background: linear-gradient(45deg, #4facfe, #00f2fe);">ðŸŽµ</div>
                        <span class="kf-filter-name">Music</span>
                    </div>
                    <div class="kf-filter-option" onclick="addSticker('ðŸ’¯')">
                        <div class="kf-filter-preview" style="font-size: 24px; display: flex; align-items: center; justify-content: center; background: linear-gradient(45deg, #00c853, #69f0ae);">ðŸ’¯</div>
                        <span class="kf-filter-name">100</span>
                    </div>
                </div>
            </div>
            
            <!-- Draw Panel -->
            <div class="kf-editor-panel" id="drawPanel">
                <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                    <div class="kf-color-picker" style="background: #ff1493;" onclick="setDrawColor('#ff1493')"></div>
                    <div class="kf-color-picker" style="background: #ffffff;" onclick="setDrawColor('#ffffff')"></div>
                    <div class="kf-color-picker" style="background: #000000;" onclick="setDrawColor('#000000')"></div>
                    <div class="kf-color-picker" style="background: #ffeb3b;" onclick="setDrawColor('#ffeb3b')"></div>
                    <div class="kf-color-picker" style="background: #00cc66;" onclick="setDrawColor('#00cc66')"></div>
                    <div class="kf-color-picker" style="background: #0095f6;" onclick="setDrawColor('#0095f6')"></div>
                    
                    <select class="kf-slider-input" onchange="setDrawSize(this.value)">
                        <option value="2">Small</option>
                        <option value="5" selected>Medium</option>
                        <option value="10">Large</option>
                    </select>
                    
                    <button class="kf-editor-tool-btn" onclick="clearDraw()">
                        <i class="fas fa-eraser"></i> Clear
                    </button>
                </div>
            </div>
            
            <!-- Trim Panel -->
            <div class="kf-editor-panel" id="trimPanel">
                <div style="display: flex; flex-direction: column; width: 100%; gap: 8px;">
                    <div style="display: flex; justify-content: space-between; color: white; font-size: 12px;">
                        <span>Start: <span id="trimStart">0:00</span></span>
                        <span>End: <span id="trimEnd">0:00</span></span>
                    </div>
                    <input type="range" id="trimStartSlider" min="0" max="100" value="0" style="width: 100%;" oninput="updateTrimStart()">
                    <input type="range" id="trimEndSlider" min="0" max="100" value="100" style="width: 100%;" oninput="updateTrimEnd()">
                    <button class="kf-editor-tool-btn" onclick="previewTrim()" style="background: var(--ig-primary);">Preview Trim</button>
                </div>
            </div>
            
            <div class="kf-editor-footer">
                <button class="kf-editor-btn kf-editor-btn-secondary" onclick="resetEdits()">
                    <i class="fas fa-undo"></i> Reset
                </button>
                <button class="kf-editor-btn kf-editor-btn-primary" onclick="saveEditedMedia()">
                    <i class="fas fa-check"></i> Apply
                </button>
            </div>
        </div>
    </div>

    <main class="kf-main-container">
        <div class="kf-post-card">
            <div class="kf-post-header">
                <button class="kf-post-close" onclick="closePost()">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <div class="kf-post-title">
                    <i class="fas fa-pen"></i> create a vibe
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button type="button" class="kf-vibe-check" id="vibeCheckBtn">
                        âœ¨
                    </button>
                    <button type="submit" form="postForm" class="kf-share-btn-header" id="sharePostBtn" disabled>
                        <i class="fas fa-paper-plane"></i> post
                    </button>
                </div>
            </div>

            <form id="postForm" action="{% url 'post' %}" method="post" enctype="multipart/form-data" class="kf-post-content">
                {% csrf_token %}
                
                <!-- Mood Selector -->
                <div class="kf-mood-section">
                    <div class="kf-mood-label">
                        <i class="fas fa-smile-wink"></i> mood
                    </div>
                    
                    <div class="kf-mood-row">
                        <div class="kf-mood-dropdown-container">
                            <div class="kf-mood-selector-btn" id="moodSelectorBtn" onclick="toggleMoodDropdown()">
                                <div class="kf-selected-mood">
                                    <span class="kf-selected-mood-emoji" id="selectedMoodEmoji">âœ¨</span>
                                    <span class="kf-selected-mood-text" id="selectedMoodText">select</span>
                                </div>
                                <i class="fas fa-chevron-down"></i>
                            </div>
                            
                            <div class="kf-mood-dropdown" id="moodDropdown">
                                <div class="kf-mood-option" onclick="selectMood('slay', 'ðŸ’…', 'main character')">
                                    <span class="kf-mood-option-emoji">ðŸ’…</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">slay</div>
                                        <div class="kf-mood-option-vibe">main character</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('vibing', 'ðŸŽµ', 'chill')">
                                    <span class="kf-mood-option-emoji">ðŸŽµ</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">vibing</div>
                                        <div class="kf-mood-option-vibe">chill</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('sheesh', 'ðŸ¥¶', 'cold')">
                                    <span class="kf-mood-option-emoji">ðŸ¥¶</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">sheesh</div>
                                        <div class="kf-mood-option-vibe">cold</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('periodt', 'â¸ï¸', 'period')">
                                    <span class="kf-mood-option-emoji">â¸ï¸</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">periodt</div>
                                        <div class="kf-mood-option-vibe">period</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('no-cap', 'ðŸŽ¯', 'for real')">
                                    <span class="kf-mood-option-emoji">ðŸŽ¯</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">no cap</div>
                                        <div class="kf-mood-option-vibe">for real</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('bussin', 'ðŸ”¥', 'fire')">
                                    <span class="kf-mood-option-emoji">ðŸ”¥</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">bussin</div>
                                        <div class="kf-mood-option-vibe">fire</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('mid', 'ðŸ˜', 'average')">
                                    <span class="kf-mood-option-emoji">ðŸ˜</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">mid</div>
                                        <div class="kf-mood-option-vibe">average</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('cringe', 'ðŸ˜¬', 'cheugy')">
                                    <span class="kf-mood-option-emoji">ðŸ˜¬</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">cringe</div>
                                        <div class="kf-mood-option-vibe">cheugy</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Custom Mood -->
                    <div class="kf-custom-mood-container">
                        <div class="kf-custom-mood-row">
                            <input type="text" 
                                   class="kf-custom-mood-input" 
                                   id="customMoodInput"
                                   placeholder="type your vibe..."
                                   maxlength="30">
                            <button type="button" class="kf-add-custom-btn" onclick="addCustomMood()">
                                <i class="fas fa-plus"></i> Add
                            </button>
                        </div>
                        
                        <div class="kf-custom-suggestions">
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('blessed âœ¨')">blessed âœ¨</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('ungovernable ðŸ”¥')">ungovernable ðŸ”¥</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('demure ðŸ’…')">demure ðŸ’…</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('delulu ðŸ¤ª')">delulu ðŸ¤ª</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('main character â­')">main character â­</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('unbothered ðŸ˜Œ')">unbothered ðŸ˜Œ</span>
                        </div>
                    </div>
                    
                    <!-- Hidden inputs -->
                    <input type="hidden" name="mood" id="moodInput">
                    <input type="hidden" name="custom_mood" id="customMoodInputHidden">
                    
                    <!-- Active mood display -->
                    <div id="activeMoodBadge" class="kf-active-mood hidden">
                        <span id="activeMoodEmoji">âœ¨</span>
                        <span id="activeMoodText">slay</span>
                    </div>
                </div>
                
                <div class="kf-textarea-container">
                    <textarea name="content" class="kf-textarea" placeholder="what's the tea? â˜•" rows="3" oninput="updatePreview()"></textarea>
                </div>
                
                <div class="kf-upload-section">
                    <div class="kf-upload-label">
                        <i class="fas fa-plus"></i> add media
                    </div>
                    
                    <!-- Media Options Grid -->
                    <div class="kf-media-grid">
                        <!-- AR Camera Option -->
                        <div class="kf-media-option camera" onclick="openCamera()">
                            <div class="kf-media-card">
                                <i class="fas fa-camera"></i>
                                <span class="kf-media-label">AR camera</span>
                                <span class="kf-media-sub-label">aesthetic filters</span>
                            </div>
                        </div>
                        
                        <div class="kf-media-option record" onclick="openVideoRecorder()">
                            <div class="kf-media-card">
                                <i class="fas fa-video"></i>
                                <span class="kf-media-label">record</span>
                                <span class="kf-media-sub-label">video</span>
                            </div>
                        </div>
                        
                        <label class="kf-media-option">
                            <input type="file" id="video_file_upload" accept="video/*" onchange="handleVideoSelect(this)" style="display: none;">
                            <div class="kf-media-card">
                                <i class="fas fa-cloud-upload-alt"></i>
                                <span class="kf-media-label">upload</span>
                                <span class="kf-media-sub-label">video</span>
                            </div>
                        </label>
                        
                        <div class="kf-media-option record" onclick="startAudioRecording()">
                            <div class="kf-media-card">
                                <i class="fas fa-microphone-alt"></i>
                                <span class="kf-media-label">record</span>
                                <span class="kf-media-sub-label">audio</span>
                            </div>
                        </div>
                        
                        <label class="kf-media-option">
                            <input type="file" id="audio_file_upload" accept="audio/*" onchange="handleAudioSelect(this)" style="display: none;">
                            <div class="kf-media-card">
                                <i class="fas fa-headphones"></i>
                                <span class="kf-media-label">upload</span>
                                <span class="kf-media-sub-label">audio</span>
                            </div>
                        </label>
                        
                        <label class="kf-media-option">
                            <input type="file" id="images" name="images" accept="image/*" multiple onchange="handleImageSelect(this)" style="display: none;">
                            <div class="kf-media-card">
                                <i class="fas fa-folder-open"></i>
                                <span class="kf-media-label">gallery</span>
                                <span class="kf-media-sub-label">choose</span>
                            </div>
                        </label>
                    </div>
                    
                    <!-- Hidden file inputs -->
                    <input type="file" name="video_file" id="video_file" accept="video/*" class="hidden">
                    <input type="file" name="audio_file" id="audio_file" accept="audio/*" class="hidden">
                    
                    <!-- Image Preview Grid -->
                    <div id="imagePreviewGrid" class="kf-image-preview-grid"></div>
                    
                    <!-- Video Recording Status -->
                    <div id="videoRecordingStatus" class="kf-recording-status hidden">
                        <div class="kf-recording-dot"></div>
                        <div class="kf-recording-text" id="videoRecordingText">dropping a video... ðŸŽ¥</div>
                        <div class="kf-recording-time" id="videoRecordingTime">00:00</div>
                        <button type="button" onclick="stopVideoRecording()" style="background:var(--ig-danger); color:white; border:none; padding:4px 12px; border-radius:20px; font-size:12px;">stop</button>
                    </div>
                    
                    <!-- Audio Recording Status -->
                    <div id="recordingStatus" class="kf-recording-status hidden">
                        <div class="kf-recording-dot"></div>
                        <div class="kf-recording-text" id="audioRecordingText">spitting facts... ðŸŽ¤</div>
                        <div class="kf-recording-time" id="recordingTime">00:00</div>
                        <button type="button" onclick="stopAudioRecording()" style="background:var(--ig-danger); color:white; border:none; padding:4px 12px; border-radius:20px; font-size:12px;">stop</button>
                    </div>
                    
                    <!-- Video Player -->
                    <div id="videoPlayer" class="kf-video-player">
                        <div class="kf-video-player-header">
                            <div class="kf-video-player-title">
                                <i class="fas fa-play-circle"></i> video preview
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button type="button" class="kf-video-player-close" onclick="editVideo()" style="color: var(--ig-primary);">
                                    <i class="fas fa-pen"></i>
                                </button>
                                <button type="button" class="kf-video-player-close" onclick="closeVideoPlayer()">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                        
                        <video class="kf-video-element" id="videoElement" controls></video>
                        
                        <div class="kf-video-actions">
                            <button type="button" onclick="keepVideo()" class="kf-video-action-btn kf-video-keep">keep</button>
                            <button type="button" onclick="discardVideo()" class="kf-video-action-btn">discard</button>
                        </div>
                    </div>
                    
                    <!-- Audio Player -->
                    <div id="audioPlayer" class="kf-audio-player">
                        <div class="kf-audio-player-header">
                            <div class="kf-audio-player-title">
                                <i class="fas fa-play-circle"></i> audio preview
                            </div>
                            <button type="button" class="kf-audio-player-close" onclick="closeAudioPlayer()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        
                        <div class="kf-custom-audio-player">
                            <div class="kf-audio-controls">
                                <button type="button" class="kf-audio-play-btn" id="playAudioBtn">
                                    <i class="fas fa-play"></i>
                                </button>
                                <div class="kf-audio-info">
                                    <div class="kf-audio-filename" id="audioFilename">audio recording</div>
                                    <div class="kf-audio-time">
                                        <span id="currentTime">0:00</span>
                                        <span id="durationTime">0:00</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="kf-audio-progress" id="audioProgress">
                                <div class="kf-audio-progress-filled" id="audioProgressFilled"></div>
                            </div>
                        </div>
                        
                        <div class="kf-audio-actions">
                            <button type="button" onclick="keepAudio()" class="kf-audio-action-btn kf-audio-keep">keep</button>
                            <button type="button" onclick="discardAudio()" class="kf-audio-action-btn">discard</button>
                        </div>
                    </div>
                    
                    <!-- Preview Box -->
                    <div class="kf-preview-container">
                        <div id="previewBox" class="kf-preview-box">
                            <div class="kf-preview-icon">
                                <i class="fas fa-eye"></i>
                            </div>
                            <div class="kf-preview-text">preview</div>
                            <div id="previewItem" class="kf-preview-item">nothing yet</div>
                            <div id="fileSizeInfo" class="kf-file-size-info"></div>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </main>

    <!-- Video Recorder Modal -->
    <div id="videoRecorderModal" class="kf-video-recorder-modal">
        <div class="kf-video-recorder-header">
            <button class="kf-video-recorder-close" onclick="closeVideoRecorder()">
                <i class="fas fa-times"></i>
            </button>
            <div class="kf-video-recorder-timer" id="recorderTimer">00:00</div>
            
            <label class="kf-sound-select-btn" id="selectSoundLabel">
                <i class="fas fa-music"></i>
                <span id="soundSelectionText">add sound</span>
                <input type="file" id="music_file_upload" accept="audio/*" class="hidden" onchange="handleMusicSelect(this)">
            </label>
        </div>
        
        <div class="kf-video-preview">
            <video id="videoLive" class="kf-video-live" autoplay muted playsinline></video>
            <div id="recordingIndicator" class="kf-video-recording-indicator hidden">
                <div class="kf-recording-dot-large"></div>
                <span>REC</span>
            </div>
            <div class="kf-video-watermark">
                <div class="kf-watermark-brand">
                    <i class="fas fa-star"></i> @Kishiface
                </div>
                <div class="kf-watermark-username">
                    <i class="fas fa-at"></i> {{request.user.username}}
                </div>
            </div>
        </div>
        
        <div class="kf-video-controls">
            <div class="kf-video-main-controls">
                <button class="kf-video-control-btn" onclick="flipVideoCamera()">
                    <i class="fas fa-sync-alt"></i>
                </button>
                
                <button class="kf-video-record-btn" id="videoRecordBtn" onclick="toggleVideoRecording()"></button>
                
                <button class="kf-video-control-btn" onclick="toggleMicrophone()" id="toggleMicBtn">
                    <i class="fas fa-microphone"></i>
                </button>
            </div>
            
            <div class="kf-video-secondary-controls">
                <button class="kf-video-control-btn" onclick="cancelVideoRecording()">
                    <i class="fas fa-ban"></i>
                </button>
                <button class="kf-video-control-btn" id="finishRecordingBtn" onclick="finishVideoRecording()" style="display: none;">
                    <i class="fas fa-check"></i>
                </button>
            </div>
        </div>
    </div>

    <script>
        // =================== Custom Alert Function ===================
        function showAlert(title, message, emoji = 'âœ¨', buttons = [{text: 'ok', type: 'primary'}]) {
            return new Promise((resolve) => {
                const modal = document.getElementById('alertModal');
                const emojiEl = document.getElementById('alertEmoji');
                const titleEl = document.getElementById('alertTitle');
                const messageEl = document.getElementById('alertMessage');
                const buttonsEl = document.getElementById('alertButtons');
                
                emojiEl.textContent = emoji;
                titleEl.textContent = title;
                messageEl.textContent = message;
                
                buttonsEl.innerHTML = '';
                
                buttons.forEach((btn, index) => {
                    const button = document.createElement('button');
                    button.className = `kf-alert-btn ${btn.type}`;
                    button.textContent = btn.text;
                    button.onclick = () => {
                        closeAlert();
                        resolve(btn.text);
                    };
                    buttonsEl.appendChild(button);
                });
                
                modal.classList.add('active');
            });
        }

        function closeAlert() {
            document.getElementById('alertModal').classList.remove('active');
        }

        // =================== State Variables ===================
        let selectedMood = null;
        let selectedCustomMood = null;
        let selectedImages = [];
        let currentVideoBlob = null;
        let currentAudioBlob = null;
        
        // Camera state - HIGH RESOLUTION
        let cameraStream = null;
        let isFrontCameraCamera = true;
        let capturedPhotoBlob = null;
        
        // Video recording state
        let videoStream = null;
        let videoMediaRecorder = null;
        let videoChunks = [];
        let isRecordingVideo = false;
        let videoRecordingStartTime = null;
        let videoRecordingTimer = null;
        let isFrontCameraVideo = true;
        let isMicOn = true;
        const MAX_RECORDING_TIME = 3 * 60 * 1000;
        
        // Audio recording state
        let audioMediaRecorder = null;
        let audioChunks = [];
        let isRecordingAudio = false;
        let audioRecordingStartTime = null;
        let audioRecordingTimer = null;
        let audioElement = new Audio();
        let isPlaying = false;
        
        // Audio context for music
        let audioContext = null;
        let musicBuffer = null;
        let musicSourceNode = null;
        let isMusicPlaying = false;
        let musicGainNode = null;
        let micGainNode = null;
        let destinationNode = null;
        let musicStartTime = 0;
        
        // Editor state
        let currentEditingFile = null;
        let currentEditingType = null;
        let originalImage = null;
        let canvasContext = null;
        let overlayElements = [];
        let activeOverlayElement = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        // Drawing state
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let drawColor = '#ff1493';
        let drawSize = 5;
        
        // Video editing state
        let videoEditorElement = document.getElementById('editorVideo');
        let videoTrimStart = 0;
        let videoTrimEnd = 100;
        let videoDuration = 0;
        
        // HIGH QUALITY SETTINGS - Professional Grade
        const VIDEO_SETTINGS = {
            quality: 0.95,
            bitrate: 8000000, // 8 Mbps for high quality
            width: 1920,
            height: 1080
        };
        
        // ULTRA HIGH QUALITY image settings
        const IMAGE_QUALITY = {
            quality: 0.98, // 98% quality for professional look
            format: 'image/jpeg',
            maxWidth: 3840, // 4K resolution
            maxHeight: 3840
        };
        
        // Gen Z loading messages
        const genZLoadingMessages = [
            "curating your aesthetic... âœ¨",
            "making it serve... ðŸ’…",
            "vibes loading... no cap ðŸŽµ",
            "this post is fire fr ðŸ”¥",
            "main character energy loading... ðŸŽ¬",
            "it's giving post... ðŸ’«",
            "slaying the algorithm... ðŸ’",
            "aesthetic loading... ðŸŽ¨"
        ];

        const genZLoadingSubtexts = [
            "adding the âœ¨main characterâœ¨ energy",
            "no thoughts just vibes",
            "for the algorithm bestie",
            "tea incoming â˜•",
            "iktr (i know that's right)",
            "periodt pooh",
            "serving looks",
            "main character moment"
        ];

        const genZRecordingPhrases = {
            video: [
                'dropping a video... no cap ðŸŽ¥',
                'capturing the aesthetic... âœ¨',
                'main character moment loading... ðŸŽ¬',
                'video loading... it\'s giving',
                'serving video looks... ðŸ“¹'
            ],
            audio: [
                'spitting facts... ðŸŽ¤',
                'dropping bars... fr fr ðŸŽµ',
                'fire audio incoming... ðŸ”¥',
                'recording thoughts... no cap ðŸ’­',
                'audio aesthetic loading... ðŸŽ§'
            ]
        };

        const moodEmojis = {
            'slay': 'ðŸ’…',
            'vibing': 'ðŸŽµ',
            'sheesh': 'ðŸ¥¶',
            'periodt': 'â¸ï¸',
            'no-cap': 'ðŸŽ¯',
            'bussin': 'ðŸ”¥',
            'mid': 'ðŸ˜',
            'cringe': 'ðŸ˜¬'
        };

        const moodColors = {
            'slay': '#ff1493',
            'vibing': '#9933ff',
            'sheesh': '#00cc66',
            'periodt': '#ff6b00',
            'no-cap': '#ff4444',
            'bussin': '#ffd700',
            'mid': '#808080',
            'cringe': '#8b4513'
        };

        // =================== DOM Elements ===================
        const moodSelectorBtn = document.getElementById('moodSelectorBtn');
        const moodDropdown = document.getElementById('moodDropdown');
        const selectedMoodEmoji = document.getElementById('selectedMoodEmoji');
        const selectedMoodText = document.getElementById('selectedMoodText');
        const moodInput = document.getElementById('moodInput');
        const customMoodInput = document.getElementById('customMoodInput');
        const customMoodInputHidden = document.getElementById('customMoodInputHidden');
        const activeMoodBadge = document.getElementById('activeMoodBadge');
        const activeMoodEmoji = document.getElementById('activeMoodEmoji');
        const activeMoodText = document.getElementById('activeMoodText');
        
        const imageInput = document.getElementById('images');
        const imagePreviewGrid = document.getElementById('imagePreviewGrid');
        const videoFileInput = document.getElementById('video_file');
        const videoUploadInput = document.getElementById('video_file_upload');
        const audioFileInput = document.getElementById('audio_file');
        const audioUploadInput = document.getElementById('audio_file_upload');
        
        const cameraModal = document.getElementById('cameraModal');
        const cameraLive = document.getElementById('cameraLive');
        const capturedImageContainer = document.getElementById('capturedImageContainer');
        const capturedImage = document.getElementById('capturedImage');
        
        const videoRecorderModal = document.getElementById('videoRecorderModal');
        const videoLive = document.getElementById('videoLive');
        const videoRecordBtn = document.getElementById('videoRecordBtn');
        const recorderTimer = document.getElementById('recorderTimer');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const toggleMicBtn = document.getElementById('toggleMicBtn');
        const finishRecordingBtn = document.getElementById('finishRecordingBtn');
        const soundSelectionText = document.getElementById('soundSelectionText');
        const musicFileUpload = document.getElementById('music_file_upload');
        
        const videoPlayer = document.getElementById('videoPlayer');
        const videoElement = document.getElementById('videoElement');
        
        const audioPlayer = document.getElementById('audioPlayer');
        const playAudioBtn = document.getElementById('playAudioBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        const videoRecordingStatus = document.getElementById('videoRecordingStatus');
        const recordingTimeEl = document.getElementById('recordingTime');
        const videoRecordingTimeEl = document.getElementById('videoRecordingTime');
        const audioFilename = document.getElementById('audioFilename');
        const currentTimeEl = document.getElementById('currentTime');
        const durationTimeEl = document.getElementById('durationTime');
        const audioProgress = document.getElementById('audioProgress');
        const audioProgressFilled = document.getElementById('audioProgressFilled');
        
        const previewBox = document.getElementById('previewBox');
        const previewItem = document.getElementById('previewItem');
        const textarea = document.querySelector('textarea[name="content"]');
        const sharePostBtn = document.getElementById('sharePostBtn');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const loadingSubtext = document.getElementById('loadingSubtext');
        const fileSizeInfo = document.getElementById('fileSizeInfo');
        const vibeCheckBtn = document.getElementById('vibeCheckBtn');
        
        const mediaEditorModal = document.getElementById('mediaEditorModal');
        const editorCanvas = document.getElementById('editorCanvas');
        const editorCanvasContainer = document.getElementById('editorCanvasContainer');
        const editorTextInput = document.getElementById('editorTextInput');

        // =================== AR Camera Variables ===================
        let arCanvas = document.getElementById('arFilterCanvas');
        let arCtx = arCanvas ? arCanvas.getContext('2d') : null;
        let arOverlay = document.getElementById('arOverlay');
        let faceMeshCanvas = document.getElementById('faceMeshCanvas');
        let faceMeshCtx = faceMeshCanvas ? faceMeshCanvas.getContext('2d') : null;
        
        // AR State
        let currentARFilter = 'none';
        let activeAREffects = [];
        let arAnimationFrame = null;
        let arLastFrameTime = 0;
        let arTimeEffect = 'normal';
        let arFrameCount = 0;
        let arDetectedFaces = [];
        let isARModeActive = true;
        let arGestureHintTimeout = null;
        
        // AR Elements for effects
        let arSparkles = [];
        let arHearts = [];
        let arStars = [];
        let arButterflies = [];
        let arGlitter = [];

        // =================== Utility Functions ===================
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function createFloatingEmoji(emoji, x, y) {
            const el = document.createElement('div');
            el.textContent = emoji;
            el.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                font-size: 32px;
                pointer-events: none;
                z-index: 9999;
                animation: floatEmoji 1.5s ease-out forwards;
                filter: drop-shadow(0 0 10px rgba(255,255,255,0.5));
            `;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1500);
        }

        function vibeVibrate(pattern = 10) {
            if (window.navigator && window.navigator.vibrate) {
                window.navigator.vibrate(pattern);
            }
        }

        function updateFileSizeDisplay() {
            let totalSize = 0;
            selectedImages.forEach(file => totalSize += file.size);
            if (currentVideoBlob) totalSize += currentVideoBlob.size;
            if (currentAudioBlob) totalSize += currentAudioBlob.size;
            
            if (totalSize > 0) {
                fileSizeInfo.textContent = `size: ${formatFileSize(totalSize)} (4K ready)`;
                if (totalSize > 100 * 1024 * 1024) {
                    fileSizeInfo.style.color = 'var(--ig-danger)';
                } else {
                    fileSizeInfo.style.color = 'var(--ig-text-light)';
                }
            } else {
                fileSizeInfo.textContent = '';
            }
        }

        function updatePreview() {
            const hasImages = selectedImages.length > 0;
            const hasVideo = currentVideoBlob !== null;
            const hasAudio = currentAudioBlob !== null;
            const hasText = textarea.value.trim().length > 0;
            const hasMood = selectedMood || selectedCustomMood;

            if (hasImages || hasVideo || hasAudio || hasText || hasMood) {
                previewBox.classList.add('has-content');
                
                if (hasImages) {
                    previewItem.textContent = `${selectedImages.length} photo${selectedImages.length > 1 ? 's' : ''} (4K) ðŸ“¸`;
                } else if (hasVideo) {
                    previewItem.textContent = `video ready (HD) ðŸŽ¥`;
                } else if (hasAudio) {
                    previewItem.textContent = `audio ready ðŸŽµ`;
                } else if (hasText) {
                    previewItem.textContent = `caption ready ðŸ’­`;
                } else if (hasMood) {
                    previewItem.textContent = `mood: ${selectedMood || selectedCustomMood} âœ¨`;
                }
            } else {
                previewBox.classList.remove('has-content');
                previewItem.textContent = 'nothing yet';
            }
            
            updateShareButtonState();
            updateFileSizeDisplay();
        }

        function updateShareButtonState() {
            const hasContent = textarea.value.trim().length > 0 || selectedImages.length > 0 || currentVideoBlob || currentAudioBlob;
            sharePostBtn.disabled = !hasContent;
        }

        // =================== Mood Functions ===================
        function toggleMoodDropdown() {
            moodDropdown.classList.toggle('show');
            moodSelectorBtn.classList.toggle('active');
        }

        function selectMood(mood, emoji, vibe) {
            selectedMood = mood;
            selectedCustomMood = null;
            
            selectedMoodEmoji.textContent = emoji;
            selectedMoodText.textContent = mood;
            moodInput.value = mood;
            customMoodInputHidden.value = '';
            
            activeMoodBadge.classList.remove('hidden');
            activeMoodEmoji.textContent = emoji;
            activeMoodText.textContent = mood;
            
            const color = moodColors[mood] || 'var(--ig-primary)';
            activeMoodBadge.style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
            
            moodDropdown.classList.remove('show');
            moodSelectorBtn.classList.remove('active');
            
            createFloatingEmoji(emoji, window.innerWidth/2, 100);
            vibeVibrate(20);
            
            updatePreview();
        }

        function setCustomMoodInput(value) {
            customMoodInput.value = value;
        }

        function addCustomMood() {
            const customMood = customMoodInput.value.trim();
            if (customMood) {
                selectedCustomMood = customMood;
                selectedMood = null;
                
                const emojiMatch = customMood.match(/([\u{1F300}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])$/u);
                const moodText = emojiMatch ? customMood.slice(0, -emojiMatch[0].length).trim() : customMood;
                const moodEmoji = emojiMatch ? emojiMatch[0] : 'âœ¨';
                
                selectedMoodEmoji.textContent = moodEmoji;
                selectedMoodText.textContent = moodText;
                moodInput.value = '';
                customMoodInputHidden.value = customMood;
                
                activeMoodBadge.classList.remove('hidden');
                activeMoodEmoji.textContent = moodEmoji;
                activeMoodText.textContent = moodText;
                activeMoodBadge.style.background = `linear-gradient(135deg, #0095f6, #00b8ff)`;
                
                customMoodInput.value = '';
                createFloatingEmoji(moodEmoji, window.innerWidth/2, 100);
                vibeVibrate(20);
                
                updatePreview();
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.kf-mood-dropdown-container')) {
                moodDropdown.classList.remove('show');
                moodSelectorBtn.classList.remove('active');
            }
        });

        // =================== PROFESSIONAL AR CAMERA FUNCTIONS ===================
        function openCamera() {
            cameraModal.classList.add('active');
            capturedImageContainer.classList.add('hidden');
            startCameraPreview();
            startARTimer();
        }

        function closeCamera() {
            cameraModal.classList.remove('active');
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            if (arAnimationFrame) {
                cancelAnimationFrame(arAnimationFrame);
                arAnimationFrame = null;
            }
        }

        async function startCameraPreview() {
            try {
                // HIGHEST QUALITY camera settings
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: isFrontCameraCamera ? 'user' : 'environment',
                        width: { ideal: 3840 }, // 4K
                        height: { ideal: 2160 },
                        frameRate: { ideal: 60 }
                    }
                });
                
                cameraLive.srcObject = cameraStream;
                await cameraLive.play();
                
                // Set canvas dimensions to match video for maximum quality
                setTimeout(() => {
                    if (cameraLive.videoWidth) {
                        arCanvas.width = cameraLive.videoWidth;
                        arCanvas.height = cameraLive.videoHeight;
                        faceMeshCanvas.width = arCanvas.width;
                        faceMeshCanvas.height = arCanvas.height;
                        
                        // Start AR animation loop
                        startARAnimation();
                        
                        // Initialize face detection
                        initFaceDetection();
                        
                        showARGestureHint('ðŸ‘† tap for sparkles');
                    }
                }, 500);
                
            } catch (err) {
                console.error('Camera error:', err);
                showAlert('camera access', 'Camera access is required for aesthetic pics.', 'ðŸ“·', [
                    {text: 'got it', type: 'primary'}
                ]);
                closeCamera();
            }
        }

        async function flipCamera() {
            isFrontCameraCamera = !isFrontCameraCamera;
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                await startCameraPreview();
            }
        }

        function toggleARMode() {
            isARModeActive = !isARModeActive;
            const btn = document.getElementById('arModeBtn');
            
            if (isARModeActive) {
                btn.innerHTML = '<i class="fas fa-magic"></i>';
                showARGestureHint('âœ¨ AR mode on');
            } else {
                btn.innerHTML = '<i class="fas fa-camera"></i>';
                showARGestureHint('ðŸ“· Camera mode');
                
                if (arCtx) {
                    arCtx.clearRect(0, 0, arCanvas.width, arCanvas.height);
                }
            }
        }

        // Face detection (simplified but more accurate)
        function initFaceDetection() {
            setInterval(simulateFaceDetection, 50); // Faster updates for smoother AR
        }
        
        function simulateFaceDetection() {
            if (!cameraLive || !cameraLive.videoWidth) return;
            
            const videoWidth = cameraLive.videoWidth;
            const videoHeight = cameraLive.videoHeight;
            
            // More precise face detection simulation
            arDetectedFaces = [{
                x: videoWidth * 0.3,
                y: videoHeight * 0.2,
                width: videoWidth * 0.4,
                height: videoHeight * 0.5,
                noseX: videoWidth * 0.5,
                noseY: videoHeight * 0.4,
                leftEyeX: videoWidth * 0.4,
                leftEyeY: videoHeight * 0.3,
                rightEyeX: videoWidth * 0.6,
                rightEyeY: videoHeight * 0.3,
                leftCheekX: videoWidth * 0.35,
                leftCheekY: videoHeight * 0.45,
                rightCheekX: videoWidth * 0.65,
                rightCheekY: videoHeight * 0.45,
                foreheadX: videoWidth * 0.5,
                foreheadY: videoHeight * 0.2,
                mouthX: videoWidth * 0.5,
                mouthY: videoHeight * 0.55
            }];
        }

        // AR Animation Loop - High Performance
        function startARAnimation() {
            function animate(currentTime) {
                if (!cameraLive || cameraLive.paused || cameraLive.ended || !cameraLive.videoWidth) {
                    arAnimationFrame = requestAnimationFrame(animate);
                    return;
                }
                
                // Time effects
                if (arTimeEffect === 'slow') {
                    if (currentTime - arLastFrameTime < 66) {
                        arAnimationFrame = requestAnimationFrame(animate);
                        return;
                    }
                }
                
                arLastFrameTime = currentTime;
                
                if (isARModeActive) {
                    // Clear canvases
                    arCtx.clearRect(0, 0, arCanvas.width, arCanvas.height);
                    if (faceMeshCtx) {
                        faceMeshCtx.clearRect(0, 0, faceMeshCanvas.width, faceMeshCanvas.height);
                    }
                    
                    // Draw video frame
                    arCtx.drawImage(cameraLive, 0, 0, arCanvas.width, arCanvas.height);
                    
                    // Apply professional filters
                    applyProfessionalARFilter();
                    
                    // Draw face mesh (for debugging, can be removed)
                    drawFaceMesh();
                    
                    // Draw Gen Z effects
                    drawGenZEffects();
                    
                    // Update particle effects
                    updateParticleEffects();
                }
                
                arAnimationFrame = requestAnimationFrame(animate);
            }
            
            arAnimationFrame = requestAnimationFrame(animate);
        }

        // PROFESSIONAL FILTERS - Gen Z Aesthetic
        function applyProfessionalARFilter() {
            const imageData = arCtx.getImageData(0, 0, arCanvas.width, arCanvas.height);
            const data = imageData.data;
            
            switch(currentARFilter) {
                case 'soft-glow':
                    // Soft, dreamy glow with pastel tones
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.1);      // Slight warmth
                        data[i+1] = Math.min(255, data[i+1] * 1.05); // Slight green
                        data[i+2] = Math.min(255, data[i+2] * 1.2);  // Boost blue for dreamy effect
                        
                        // Soft glow
                        if (Math.random() > 0.995) {
                            data[i] = 255;
                            data[i+1] = 240;
                            data[i+2] = 255;
                        }
                    }
                    break;
                    
                case 'aesthetic':
                    // Modern aesthetic - slightly desaturated with pink undertones
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                        data[i] = Math.min(255, avg * 0.9 + 30);      // Pink tint
                        data[i+1] = Math.min(255, avg * 0.85);        // Desaturated green
                        data[i+2] = Math.min(255, avg * 0.95 + 20);   // Slight blue
                    }
                    break;
                    
                case 'y2k':
                    // Y2K aesthetic - high contrast, slightly yellow
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.2);      // Boost red
                        data[i+1] = Math.min(255, data[i+1] * 1.1);  // Boost green
                        data[i+2] = data[i+2] * 0.9;                 // Reduce blue
                        
                        // High contrast
                        if (data[i] + data[i+1] + data[i+2] > 382) {
                            data[i] = data[i+1] = data[i+2] = 255;
                        }
                    }
                    break;
                    
                case 'vaporwave':
                    // Vaporwave aesthetic - purple/pink with teal
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i+1];
                        const b = data[i+2];
                        
                        data[i] = Math.min(255, r * 0.9 + 50);       // Pink tint
                        data[i+1] = Math.min(255, g * 0.8);          // Desaturated green
                        data[i+2] = Math.min(255, b * 1.3);          // Boost blue/teal
                    }
                    break;
                    
                case 'neon':
                    // Neon aesthetic - vibrant, high saturation
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.4);      // Boost red
                        data[i+1] = Math.min(255, data[i+1] * 1.3);  // Boost green
                        data[i+2] = Math.min(255, data[i+2] * 1.5);  // Boost blue
                        
                        // Neon glow effect
                        if (data[i] > 200 || data[i+1] > 200 || data[i+2] > 200) {
                            data[i] = 255;
                            data[i+1] = data[i+2] = 0;
                        }
                    }
                    break;
                    
                case 'soft-girl':
                    // Soft girl aesthetic - pastel pink, low contrast
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                        data[i] = Math.min(255, avg * 0.8 + 50);      // Pink tint
                        data[i+1] = Math.min(255, avg * 0.7 + 60);    // Soft green
                        data[i+2] = Math.min(255, avg * 0.6 + 70);    // Soft blue
                    }
                    break;
                    
                case 'egirl':
                    // E-girl aesthetic - cool tones with purple shadows
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = data[i] * 0.9;                      // Reduce red
                        data[i+1] = data[i+1] * 0.8;                  // Reduce green
                        data[i+2] = Math.min(255, data[i+2] * 1.2);   // Boost blue
                        
                        // Purple shadows in dark areas
                        if (data[i] + data[i+1] + data[i+2] < 150) {
                            data[i] = Math.min(255, data[i] + 30);
                            data[i+2] = Math.min(255, data[i+2] + 50);
                        }
                    }
                    break;
                    
                case 'vsco':
                    // VSCO aesthetic - faded, warm, film-like
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.1);      // Warm
                        data[i+1] = data[i+1] * 0.95;                 // Slight fade
                        data[i+2] = data[i+2] * 0.9;                  // Cool down
                        
                        // Add grain
                        if (Math.random() > 0.95) {
                            data[i] = data[i+1] = data[i+2] = 255;
                        }
                    }
                    break;
                    
                case 'lo-fi':
                    // Lo-fi aesthetic - muted, vintage, blueish
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                        data[i] = avg * 0.9;                          // Muted red
                        data[i+1] = avg * 0.95;                        // Muted green
                        data[i+2] = avg * 1.1;                         // Slight blue
                    }
                    break;
                    
                case 'dreamcore':
                    // Dreamcore aesthetic - ethereal, overexposed, soft
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.3);      // Overexposed
                        data[i+1] = Math.min(255, data[i+1] * 1.3);
                        data[i+2] = Math.min(255, data[i+2] * 1.3);
                        
                        // Soft blur effect via pixelation
                        if (i % 8 === 0) {
                            const val = (data[i] + data[i+1] + data[i+2]) / 3;
                            data[i] = data[i+1] = data[i+2] = val;
                        }
                    }
                    break;
                    
                case 'weirdcore':
                    // Weirdcore aesthetic - unsettling, high contrast, glitchy
                    for (let i = 0; i < data.length; i += 4) {
                        if (Math.random() > 0.99) {
                            data[i] = 255 - data[i];                  // Invert random pixels
                            data[i+1] = 255 - data[i+1];
                            data[i+2] = 255 - data[i+2];
                        }
                        
                        // High contrast
                        if (data[i] + data[i+1] + data[i+2] > 382) {
                            data[i] = data[i+1] = data[i+2] = 255;
                        } else {
                            data[i] = data[i+1] = data[i+2] = 0;
                        }
                    }
                    break;
            }
            
            arCtx.putImageData(imageData, 0, 0);
            arFrameCount++;
        }

        // Draw face mesh (for effect placement)
        function drawFaceMesh() {
            if (!faceMeshCtx || arDetectedFaces.length === 0) return;
            
            const face = arDetectedFaces[0];
            
            faceMeshCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            faceMeshCtx.lineWidth = 1;
            faceMeshCtx.strokeRect(face.x, face.y, face.width, face.height);
        }

        // GEN Z EFFECTS
        function drawGenZEffects() {
            if (arDetectedFaces.length === 0) return;
            
            const face = arDetectedFaces[0];
            
            activeAREffects.forEach(effect => {
                switch(effect) {
                    case 'heart-glasses':
                        drawHeartGlasses(face);
                        break;
                    case 'butterfly':
                        drawButterfly(face);
                        break;
                    case 'star-crown':
                        drawStarCrown(face);
                        break;
                    case 'cherry':
                        drawCherry(face);
                        break;
                    case 'flower-crown':
                        drawFlowerCrown(face);
                        break;
                    case 'heart-eyes':
                        drawHeartEyes(face);
                        break;
                    case 'glitter-tears':
                        drawGlitterTears(face);
                        break;
                    case 'blush':
                        drawBlush(face);
                        break;
                    case 'freckles':
                        drawFreckles(face);
                        break;
                    case 'sparkles':
                        addSparkle();
                        break;
                    case 'clouds':
                        drawClouds(face);
                        break;
                    case 'stars':
                        addStar();
                        break;
                    case 'rainbow':
                        drawRainbow(face);
                        break;
                    case 'halo':
                        drawHalo(face);
                        break;
                }
            });
        }

        // PROFESSIONAL EFFECT DRAWING FUNCTIONS
        function drawHeartGlasses(face) {
            const lensSize = face.width * 0.2;
            
            // Left heart lens
            arCtx.fillStyle = 'rgba(255,105,180,0.7)';
            arCtx.shadowColor = 'rgba(255,105,180,0.5)';
            arCtx.shadowBlur = 15;
            drawHeart(arCtx, face.leftEyeX, face.leftEyeY, lensSize);
            
            // Right heart lens
            drawHeart(arCtx, face.rightEyeX, face.rightEyeY, lensSize);
            
            // Bridge
            arCtx.strokeStyle = 'rgba(255,105,180,0.7)';
            arCtx.lineWidth = 3;
            arCtx.shadowBlur = 10;
            arCtx.beginPath();
            arCtx.moveTo(face.leftEyeX + lensSize/2, face.leftEyeY);
            arCtx.lineTo(face.rightEyeX - lensSize/2, face.rightEyeY);
            arCtx.stroke();
            
            arCtx.shadowBlur = 0;
        }

        function drawButterfly(face) {
            const size = face.width * 0.15;
            const x = face.rightEyeX + size;
            const y = face.y - size;
            
            arCtx.fillStyle = 'rgba(255,192,203,0.8)';
            arCtx.shadowColor = 'rgba(255,192,203,0.5)';
            arCtx.shadowBlur = 15;
            
            // Draw butterfly (simplified)
            arCtx.beginPath();
            arCtx.ellipse(x - size/2, y, size/2, size, 0, 0, Math.PI * 2);
            arCtx.fill();
            
            arCtx.beginPath();
            arCtx.ellipse(x + size/2, y, size/2, size, 0, 0, Math.PI * 2);
            arCtx.fill();
            
            arCtx.beginPath();
            arCtx.ellipse(x, y + size/3, size/3, size/3, 0, 0, Math.PI * 2);
            arCtx.fillStyle = 'rgba(255,255,255,0.9)';
            arCtx.fill();
            
            arCtx.shadowBlur = 0;
        }

        function drawStarCrown(face) {
            const crownWidth = face.width * 0.8;
            const crownHeight = face.height * 0.2;
            const x = face.x + face.width * 0.1;
            const y = face.y - crownHeight;
            
            arCtx.fillStyle = 'rgba(255,215,0,0.8)';
            arCtx.shadowColor = 'rgba(255,215,0,0.5)';
            arCtx.shadowBlur = 15;
            
            for (let i = 0; i < 5; i++) {
                const starX = x + (i * crownWidth/4);
                drawStar(arCtx, starX, y, crownHeight/2);
            }
            
            arCtx.shadowBlur = 0;
        }

        function drawCherry(face) {
            const size = face.width * 0.1;
            const x = face.leftEyeX - size;
            const y = face.y;
            
            arCtx.fillStyle = 'rgba(255,0,0,0.8)';
            arCtx.shadowColor = 'rgba(255,0,0,0.5)';
            arCtx.shadowBlur = 15;
            
            // Cherries
            arCtx.beginPath();
            arCtx.arc(x, y, size/2, 0, Math.PI * 2);
            arCtx.fill();
            
            arCtx.beginPath();
            arCtx.arc(x + size, y - size/2, size/2, 0, Math.PI * 2);
            arCtx.fill();
            
            // Stems
            arCtx.strokeStyle = 'rgba(0,128,0,0.8)';
            arCtx.lineWidth = 2;
            arCtx.beginPath();
            arCtx.moveTo(x, y - size/2);
            arCtx.lineTo(x - size/2, y - size);
            arCtx.stroke();
            
            arCtx.beginPath();
            arCtx.moveTo(x + size, y - size);
            arCtx.lineTo(x + size - size/2, y - size*1.5);
            arCtx.stroke();
            
            arCtx.shadowBlur = 0;
        }

        function drawFlowerCrown(face) {
            const flowerSize = face.width * 0.1;
            const startX = face.x;
            const endX = face.x + face.width;
            const y = face.y - flowerSize;
            
            for (let x = startX; x <= endX; x += flowerSize) {
                drawFlower(arCtx, x, y, flowerSize);
            }
        }

        function drawFlower(ctx, x, y, size) {
            ctx.fillStyle = 'rgba(255,105,180,0.7)';
            ctx.shadowColor = 'rgba(255,105,180,0.5)';
            ctx.shadowBlur = 10;
            
            // Petals
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const petalX = x + Math.cos(angle) * size/2;
                const petalY = y + Math.sin(angle) * size/2;
                
                ctx.beginPath();
                ctx.ellipse(petalX, petalY, size/3, size/2, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Center
            ctx.fillStyle = 'rgba(255,215,0,0.8)';
            ctx.beginPath();
            ctx.arc(x, y, size/3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
        }

        function drawHeartEyes(face) {
            const heartSize = face.width * 0.1;
            
            ctx.fillStyle = 'rgba(255,105,180,0.9)';
            ctx.shadowColor = 'rgba(255,105,180,0.5)';
            ctx.shadowBlur = 15;
            
            drawHeart(ctx, face.leftEyeX, face.leftEyeY, heartSize);
            drawHeart(ctx, face.rightEyeX, face.rightEyeY, heartSize);
            
            ctx.shadowBlur = 0;
        }

        function drawGlitterTears(face) {
            const tearSize = face.width * 0.03;
            
            for (let i = 0; i < 5; i++) {
                const x = face.leftCheekX + (Math.random() - 0.5) * face.width * 0.1;
                const y = face.leftCheekY + i * tearSize * 2;
                
                arCtx.fillStyle = 'rgba(255,255,255,0.8)';
                arCtx.shadowColor = 'rgba(255,255,255,0.5)';
                arCtx.shadowBlur = 10;
                
                arCtx.beginPath();
                arCtx.arc(x, y, tearSize, 0, Math.PI * 2);
                arCtx.fill();
            }
            
            for (let i = 0; i < 5; i++) {
                const x = face.rightCheekX + (Math.random() - 0.5) * face.width * 0.1;
                const y = face.rightCheekY + i * tearSize * 2;
                
                arCtx.beginPath();
                arCtx.arc(x, y, tearSize, 0, Math.PI * 2);
                arCtx.fill();
            }
            
            arCtx.shadowBlur = 0;
        }

        function drawBlush(face) {
            arCtx.fillStyle = 'rgba(255,192,203,0.3)';
            arCtx.shadowColor = 'rgba(255,192,203,0.2)';
            arCtx.shadowBlur = 30;
            
            // Left cheek
            arCtx.beginPath();
            arCtx.ellipse(face.leftCheekX, face.leftCheekY, face.width*0.1, face.width*0.05, 0, 0, Math.PI * 2);
            arCtx.fill();
            
            // Right cheek
            arCtx.beginPath();
            arCtx.ellipse(face.rightCheekX, face.rightCheekY, face.width*0.1, face.width*0.05, 0, 0, Math.PI * 2);
            arCtx.fill();
            
            arCtx.shadowBlur = 0;
        }

        function drawFreckles(face) {
            arCtx.fillStyle = 'rgba(139,69,19,0.3)';
            
            for (let i = 0; i < 10; i++) {
                const x = face.noseX + (Math.random() - 0.5) * face.width * 0.3;
                const y = face.noseY + (Math.random() - 0.5) * face.height * 0.2;
                
                arCtx.beginPath();
                arCtx.arc(x, y, 2, 0, Math.PI * 2);
                arCtx.fill();
            }
        }

        function drawClouds(face) {
            const cloudSize = face.width * 0.2;
            const x = face.x + face.width + cloudSize;
            const y = face.y;
            
            arCtx.fillStyle = 'rgba(255,255,255,0.5)';
            arCtx.shadowColor = 'rgba(255,255,255,0.3)';
            arCtx.shadowBlur = 20;
            
            // Draw cloud
            arCtx.beginPath();
            arCtx.arc(x, y, cloudSize/2, 0, Math.PI * 2);
            arCtx.arc(x + cloudSize/2, y - cloudSize/4, cloudSize/2.5, 0, Math.PI * 2);
            arCtx.arc(x + cloudSize, y, cloudSize/2, 0, Math.PI * 2);
            arCtx.fill();
            
            arCtx.shadowBlur = 0;
        }

        function drawRainbow(face) {
            const centerX = face.x + face.width/2;
            const startY = face.y - face.height * 0.3;
            
            const colors = ['rgba(255,0,0,0.3)', 'rgba(255,165,0,0.3)', 'rgba(255,255,0,0.3)', 
                           'rgba(0,255,0,0.3)', 'rgba(0,0,255,0.3)', 'rgba(75,0,130,0.3)', 'rgba(238,130,238,0.3)'];
            
            for (let i = 0; i < colors.length; i++) {
                arCtx.strokeStyle = colors[i];
                arCtx.lineWidth = face.width * 0.05;
                arCtx.beginPath();
                arCtx.arc(centerX, startY + i * 10, face.width * (0.5 + i * 0.1), 0.8, 2.4);
                arCtx.stroke();
            }
        }

        function drawHalo(face) {
            const centerX = face.x + face.width/2;
            const y = face.y - face.height * 0.2;
            
            arCtx.strokeStyle = 'rgba(255,215,0,0.6)';
            arCtx.lineWidth = 5;
            arCtx.shadowColor = 'rgba(255,215,0,0.3)';
            arCtx.shadowBlur = 20;
            
            arCtx.beginPath();
            arCtx.ellipse(centerX, y, face.width*0.3, face.width*0.1, 0, 0, Math.PI * 2);
            arCtx.stroke();
            
            arCtx.shadowBlur = 0;
        }

        // Helper function to draw hearts
        function drawHeart(ctx, x, y, size) {
            ctx.beginPath();
            ctx.moveTo(x, y - size/4);
            ctx.bezierCurveTo(x - size/2, y - size/2, x - size, y + size/3, x, y + size/2);
            ctx.bezierCurveTo(x + size, y + size/3, x + size/2, y - size/2, x, y - size/4);
            ctx.fill();
        }

        // Helper function to draw stars
        function drawStar(ctx, x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const starX = x + Math.cos(angle) * size;
                const starY = y + Math.sin(angle) * size;
                ctx.lineTo(starX, starY);
            }
            ctx.closePath();
            ctx.fill();
        }

        // Particle effects
        function addSparkle() {
            arSparkles.push({
                x: Math.random() * arCanvas.width,
                y: Math.random() * arCanvas.height,
                size: 5 + Math.random() * 15,
                speed: 0.5 + Math.random() * 2,
                angle: Math.random() * Math.PI * 2
            });
        }

        function addStar() {
            arStars.push({
                x: Math.random() * arCanvas.width,
                y: Math.random() * arCanvas.height,
                size: 10 + Math.random() * 20,
                twinkle: Math.random() * Math.PI * 2,
                speed: 0.01 + Math.random() * 0.05
            });
        }

        function updateParticleEffects() {
            // Update sparkles
            arSparkles = arSparkles.filter(sparkle => {
                sparkle.y -= sparkle.speed;
                sparkle.angle += 0.1;
                
                arCtx.fillStyle = `rgba(255,255,255,${0.5 + 0.5 * Math.sin(sparkle.angle)})`;
                arCtx.shadowColor = 'rgba(255,255,255,0.8)';
                arCtx.shadowBlur = 15;
                
                arCtx.beginPath();
                arCtx.arc(sparkle.x, sparkle.y, sparkle.size/2, 0, Math.PI * 2);
                arCtx.fill();
                
                return sparkle.y > 0;
            });
            
            // Update stars
            arStars = arStars.filter(star => {
                star.twinkle += star.speed;
                
                arCtx.fillStyle = `rgba(255,255,255,${0.3 + 0.7 * Math.sin(star.twinkle)})`;
                arCtx.shadowColor = 'rgba(255,255,255,0.8)';
                arCtx.shadowBlur = 20;
                
                arCtx.beginPath();
                arCtx.arc(star.x, star.y, star.size/2, 0, Math.PI * 2);
                arCtx.fill();
                
                return true;
            });
            
            arCtx.shadowBlur = 0;
        }

        // Select AR filter
        function selectARFilter(filter) {
            currentARFilter = filter;
            
            document.querySelectorAll('.kf-ar-filter-option').forEach(opt => {
                opt.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
            
            showARGestureHint(`âœ¨ ${filter} aesthetic`);
        }

        // Add AR effect
        function addAREffect(effect) {
            const index = activeAREffects.indexOf(effect);
            if (index > -1) {
                activeAREffects.splice(index, 1);
                event.currentTarget.classList.remove('active');
                showARGestureHint(`âŒ ${effect} removed`);
            } else {
                activeAREffects.push(effect);
                event.currentTarget.classList.add('active');
                showARGestureHint(`âœ¨ ${effect} added`);
            }
        }

        // Set time effect
        function setARTimeEffect(effect) {
            arTimeEffect = effect;
            
            document.querySelectorAll('.kf-ar-speed-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
            
            showARGestureHint(`â±ï¸ ${effect} speed`);
        }

        // Show gesture hint
        function showARGestureHint(text) {
            const hint = document.getElementById('arGestureHint');
            hint.textContent = text;
            hint.style.opacity = '1';
            
            if (arGestureHintTimeout) {
                clearTimeout(arGestureHintTimeout);
            }
            
            arGestureHintTimeout = setTimeout(() => {
                hint.style.opacity = '0';
            }, 2000);
        }

        // Update AR timer
        function startARTimer() {
            let seconds = 0;
            setInterval(() => {
                seconds++;
                document.getElementById('arTimer').textContent = formatTime(seconds);
            }, 1000);
        }

        // Touch interaction for AR
        if (cameraLive) {
            cameraLive.addEventListener('click', function(e) {
                if (!isARModeActive) return;
                
                const rect = cameraLive.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Create touch effect
                const effect = document.createElement('div');
                effect.className = 'kf-ar-touch-effect';
                effect.style.left = e.clientX + 'px';
                effect.style.top = e.clientY + 'px';
                document.body.appendChild(effect);
                setTimeout(() => effect.remove(), 800);
                
                // Add sparkle effect
                const sparkleEffects = ['âœ¨', 'ðŸ’«', 'â­', 'ðŸŒŸ', 'ðŸ’¥', 'ðŸŒ¸', 'ðŸ’•', 'ðŸ¦‹'];
                const randomEffect = sparkleEffects[Math.floor(Math.random() * sparkleEffects.length)];
                
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const floatingEmoji = document.createElement('div');
                        floatingEmoji.className = 'kf-ar-object';
                        floatingEmoji.style.left = (e.clientX + (Math.random() - 0.5) * 100) + 'px';
                        floatingEmoji.style.top = (e.clientY + (Math.random() - 0.5) * 100) + 'px';
                        floatingEmoji.style.fontSize = (24 + Math.random() * 24) + 'px';
                        floatingEmoji.textContent = randomEffect;
                        floatingEmoji.style.animation = 'float 3s ease-in-out infinite';
                        document.body.appendChild(floatingEmoji);
                        setTimeout(() => floatingEmoji.remove(), 3000);
                    }, i * 100);
                }
                
                // Add to AR overlay
                if (arOverlay) {
                    const overlayEmoji = document.createElement('div');
                    overlayEmoji.className = 'kf-ar-object';
                    overlayEmoji.style.left = x + 'px';
                    overlayEmoji.style.top = y + 'px';
                    overlayEmoji.style.fontSize = '48px';
                    overlayEmoji.textContent = randomEffect;
                    overlayEmoji.style.animation = 'float 3s ease-in-out infinite';
                    arOverlay.appendChild(overlayEmoji);
                    setTimeout(() => overlayEmoji.remove(), 3000);
                }
                
                vibeVibrate(20);
            });

            // Long press for burst effects
            let longPressTimer;
            cameraLive.addEventListener('touchstart', function(e) {
                if (!isARModeActive) return;
                
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            const burstEmoji = document.createElement('div');
                            burstEmoji.className = 'kf-ar-object';
                            burstEmoji.style.left = (touch.clientX + (Math.random() - 0.5) * 200) + 'px';
                            burstEmoji.style.top = (touch.clientY + (Math.random() - 0.5) * 200) + 'px';
                            burstEmoji.style.fontSize = (20 + Math.random() * 40) + 'px';
                            burstEmoji.textContent = 'âœ¨';
                            burstEmoji.style.animation = 'float 2s ease-out';
                            document.body.appendChild(burstEmoji);
                            setTimeout(() => burstEmoji.remove(), 2000);
                        }, i * 30);
                    }
                    
                    showARGestureHint('âœ¨ aesthetic burst! âœ¨');
                    vibeVibrate([100, 50, 100, 50, 100]);
                }, 500);
            });
            
            cameraLive.addEventListener('touchend', function() {
                clearTimeout(longPressTimer);
            });
        }

        // ULTRA HIGH QUALITY capture photo with AR effects
        function capturePhoto() {
            // Create high-res canvas
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = cameraLive.videoWidth || 3840;
            captureCanvas.height = cameraLive.videoHeight || 2160;
            const captureCtx = captureCanvas.getContext('2d');
            captureCtx.imageSmoothingEnabled = true;
            captureCtx.imageSmoothingQuality = 'high';
            
            // Draw video frame at full resolution
            captureCtx.drawImage(cameraLive, 0, 0, captureCanvas.width, captureCanvas.height);
            
            // Apply filter if in AR mode
            if (isARModeActive && currentARFilter !== 'none') {
                const imageData = captureCtx.getImageData(0, 0, captureCanvas.width, captureCanvas.height);
                const data = imageData.data;
                
                // Apply selected filter at full resolution
                switch(currentARFilter) {
                    case 'soft-glow':
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = Math.min(255, data[i] * 1.1);
                            data[i+1] = Math.min(255, data[i+1] * 1.05);
                            data[i+2] = Math.min(255, data[i+2] * 1.2);
                        }
                        break;
                    case 'aesthetic':
                        for (let i = 0; i < data.length; i += 4) {
                            const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                            data[i] = Math.min(255, avg * 0.9 + 30);
                            data[i+1] = Math.min(255, avg * 0.85);
                            data[i+2] = Math.min(255, avg * 0.95 + 20);
                        }
                        break;
                    case 'y2k':
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = Math.min(255, data[i] * 1.2);
                            data[i+1] = Math.min(255, data[i+1] * 1.1);
                            data[i+2] = data[i+2] * 0.9;
                        }
                        break;
                    case 'vaporwave':
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = Math.min(255, data[i] * 0.9 + 50);
                            data[i+1] = data[i+1] * 0.8;
                            data[i+2] = Math.min(255, data[i+2] * 1.3);
                        }
                        break;
                    case 'neon':
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = Math.min(255, data[i] * 1.4);
                            data[i+1] = Math.min(255, data[i+1] * 1.3);
                            data[i+2] = Math.min(255, data[i+2] * 1.5);
                        }
                        break;
                    case 'egirl':
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = data[i] * 0.9;
                            data[i+1] = data[i+1] * 0.8;
                            data[i+2] = Math.min(255, data[i+2] * 1.2);
                        }
                        break;
                }
                
                captureCtx.putImageData(imageData, 0, 0);
            }
            
            // Draw AR effects if any (scaled to full resolution)
            if (activeAREffects.length > 0 && arDetectedFaces.length > 0) {
                const scaleX = captureCanvas.width / arCanvas.width;
                const scaleY = captureCanvas.height / arCanvas.height;
                
                const scaledFace = {
                    ...arDetectedFaces[0],
                    x: arDetectedFaces[0].x * scaleX,
                    y: arDetectedFaces[0].y * scaleY,
                    width: arDetectedFaces[0].width * scaleX,
                    height: arDetectedFaces[0].height * scaleY,
                    noseX: arDetectedFaces[0].noseX * scaleX,
                    noseY: arDetectedFaces[0].noseY * scaleY,
                    leftEyeX: arDetectedFaces[0].leftEyeX * scaleX,
                    leftEyeY: arDetectedFaces[0].leftEyeY * scaleY,
                    rightEyeX: arDetectedFaces[0].rightEyeX * scaleX,
                    rightEyeY: arDetectedFaces[0].rightEyeY * scaleY,
                    leftCheekX: arDetectedFaces[0].leftCheekX * scaleX,
                    leftCheekY: arDetectedFaces[0].leftCheekY * scaleY,
                    rightCheekX: arDetectedFaces[0].rightCheekX * scaleX,
                    rightCheekY: arDetectedFaces[0].rightCheekY * scaleY,
                    mouthX: arDetectedFaces[0].mouthX * scaleX,
                    mouthY: arDetectedFaces[0].mouthY * scaleY
                };
                
                // Save current context and draw effects
                const originalCtx = arCtx;
                arCtx = captureCtx;
                
                activeAREffects.forEach(effect => {
                    switch(effect) {
                        case 'heart-glasses': drawHeartGlasses(scaledFace); break;
                        case 'butterfly': drawButterfly(scaledFace); break;
                        case 'star-crown': drawStarCrown(scaledFace); break;
                        case 'cherry': drawCherry(scaledFace); break;
                        case 'flower-crown': drawFlowerCrown(scaledFace); break;
                        case 'heart-eyes': drawHeartEyes(scaledFace); break;
                        case 'glitter-tears': drawGlitterTears(scaledFace); break;
                        case 'blush': drawBlush(scaledFace); break;
                        case 'freckles': drawFreckles(scaledFace); break;
                        case 'clouds': drawClouds(scaledFace); break;
                        case 'rainbow': drawRainbow(scaledFace); break;
                        case 'halo': drawHalo(scaledFace); break;
                    }
                });
                
                arCtx = originalCtx;
            }
            
            // Convert to ultra high quality blob
            captureCanvas.toBlob(function(blob) {
                capturedPhotoBlob = blob;
                
                const imageUrl = URL.createObjectURL(blob);
                capturedImage.src = imageUrl;
                capturedImageContainer.classList.remove('hidden');
                
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                    cameraStream = null;
                }
                
                createFloatingEmoji('ðŸ“¸', window.innerWidth/2, 100);
                vibeVibrate(50);
                
            }, IMAGE_QUALITY.format, IMAGE_QUALITY.quality);
        }

        function retakePhoto() {
            capturedImageContainer.classList.add('hidden');
            capturedPhotoBlob = null;
            startCameraPreview();
        }

        function keepPhoto() {
            if (capturedPhotoBlob) {
                const file = new File([capturedPhotoBlob], `aesthetic_${Date.now()}.jpg`, { type: IMAGE_QUALITY.format });
                
                selectedImages = [...selectedImages, file];
                
                const dt = new DataTransfer();
                selectedImages.forEach(f => dt.items.add(f));
                imageInput.files = dt.files;
                
                renderImagePreviews();
                updatePreview();
                updateFileSizeDisplay();
                
                closeCamera();
                
                createFloatingEmoji('ðŸ’¾', window.innerWidth/2, 100);
                vibeVibrate(20);
            }
        }

        // =================== Image Functions ===================
        function handleImageSelect(input) {
            const files = Array.from(input.files);
            
            // Check for high quality
            files.forEach(file => {
                if (file.size > 50 * 1024 * 1024) {
                    showAlert('large file', 'File is larger than 50MB, might take time to upload', 'ðŸ“', [
                        {text: 'ok', type: 'primary'}
                    ]);
                }
            });
            
            selectedImages = [...selectedImages, ...files];
            renderImagePreviews();
            updatePreview();
            updateFileSizeDisplay();
            
            createFloatingEmoji('ðŸ“¸', window.innerWidth/2, 100);
            vibeVibrate(20);
        }

        function renderImagePreviews() {
            imagePreviewGrid.innerHTML = '';
            selectedImages.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const div = document.createElement('div');
                    div.className = 'kf-image-preview-item';
                    div.innerHTML = `
                        <img src="${e.target.result}">
                        <div class="kf-image-preview-overlay" onclick="editImage(${index})"><i class="fas fa-pen"></i></div>
                        <div class="kf-image-preview-remove" onclick="removeImage(${index})"><i class="fas fa-times"></i></div>
                    `;
                    imagePreviewGrid.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
        }

        function editImage(index) {
            currentEditingFile = selectedImages[index];
            currentEditingType = 'image';
            openMediaEditor();
        }

        function removeImage(index) {
            selectedImages.splice(index, 1);
            const dt = new DataTransfer();
            selectedImages.forEach(f => dt.items.add(f));
            imageInput.files = dt.files;
            renderImagePreviews();
            updatePreview();
            updateFileSizeDisplay();
            
            createFloatingEmoji('ðŸ—‘ï¸', window.innerWidth/2, 100);
        }

        // =================== VIDEO RECORDING FUNCTIONS ===================
        function openVideoRecorder() {
            videoRecorderModal.classList.add('active');
            startVideoPreview();
        }

        function closeVideoRecorder() {
            videoRecorderModal.classList.remove('active');
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            stopBackgroundMusic();
        }

        async function startVideoPreview() {
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: isFrontCameraVideo ? 'user' : 'environment',
                        width: { ideal: 1920 }, // HD
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 48000
                    }
                });
                
                videoLive.srcObject = videoStream;
                await videoLive.play();
                
                videoStream.getAudioTracks().forEach(track => {
                    track.enabled = isMicOn;
                });
                
                toggleMicBtn.innerHTML = isMicOn ? 
                    '<i class="fas fa-microphone"></i>' : 
                    '<i class="fas fa-microphone-slash"></i>';
                    
            } catch (err) {
                console.error('Camera error:', err);
                showAlert('camera access', 'Camera access is required to record video.', 'ðŸ“·', [
                    {text: 'got it', type: 'primary'}
                ]);
                closeVideoRecorder();
            }
        }

        function toggleVideoRecording() {
            if (!isRecordingVideo) {
                startVideoRecording();
            } else {
                stopVideoRecording();
            }
        }

        async function startVideoRecording() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state !== 'running') {
                    await audioContext.resume();
                }
                
                destinationNode = audioContext.createMediaStreamDestination();
                
                const micAudioTrack = videoStream.getAudioTracks()[0];
                if (micAudioTrack) {
                    const micStream = new MediaStream([micAudioTrack]);
                    const micSource = audioContext.createMediaStreamSource(micStream);
                    
                    micGainNode = audioContext.createGain();
                    micGainNode.gain.value = isMicOn ? 1.0 : 0.0;
                    
                    micSource.connect(micGainNode).connect(destinationNode);
                }
                
                if (musicBuffer) {
                    musicSourceNode = audioContext.createBufferSource();
                    musicSourceNode.buffer = musicBuffer;
                    musicSourceNode.loop = true;
                    
                    musicGainNode = audioContext.createGain();
                    musicGainNode.gain.value = 0.5;
                    
                    musicSourceNode.connect(musicGainNode).connect(destinationNode);
                    musicSourceNode.connect(musicGainNode).connect(audioContext.destination);
                    
                    musicStartTime = audioContext.currentTime;
                    musicSourceNode.start(0);
                    isMusicPlaying = true;
                }
                
                const videoTrack = videoStream.getVideoTracks()[0];
                const mixedAudioTrack = destinationNode.stream.getAudioTracks()[0];
                
                let mixedStream;
                if (mixedAudioTrack) {
                    mixedStream = new MediaStream([videoTrack, mixedAudioTrack]);
                } else {
                    mixedStream = new MediaStream([videoTrack]);
                }
                
                // High quality recording settings
                const options = {
                    mimeType: 'video/webm;codecs=vp9,opus',
                    videoBitsPerSecond: VIDEO_SETTINGS.bitrate
                };
                
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm;codecs=vp8,opus';
                    options.videoBitsPerSecond = VIDEO_SETTINGS.bitrate * 1.2;
                }
                
                videoMediaRecorder = new MediaRecorder(mixedStream, options);
                videoChunks = [];
                
                videoMediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        videoChunks.push(event.data);
                    }
                };
                
                videoMediaRecorder.onstop = () => {
                    if (musicSourceNode) {
                        try {
                            musicSourceNode.stop();
                        } catch(e) {}
                        musicSourceNode.disconnect();
                        musicSourceNode = null;
                        isMusicPlaying = false;
                    }
                    
                    const videoBlob = new Blob(videoChunks, { type: 'video/webm' });
                    currentVideoBlob = videoBlob;
                    
                    const videoUrl = URL.createObjectURL(videoBlob);
                    videoElement.src = videoUrl;
                    videoElement.load();
                    
                    videoPlayer.classList.add('active');
                    videoRecorderModal.classList.remove('active');
                    
                    if (videoStream) {
                        videoStream.getTracks().forEach(track => track.stop());
                        videoStream = null;
                    }
                    
                    videoRecordBtn.classList.remove('recording');
                    recordingIndicator.classList.add('hidden');
                    finishRecordingBtn.style.display = 'none';
                    recorderTimer.textContent = '00:00';
                    
                    const videoStatusText = document.getElementById('videoRecordingText');
                    if (videoStatusText) {
                        videoStatusText.textContent = genZRecordingPhrases.video[Math.floor(Math.random() * genZRecordingPhrases.video.length)];
                    }
                    videoRecordingStatus.classList.add('hidden');
                    
                    const file = new File([videoBlob], 'video.webm', { type: 'video/webm' });
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    videoFileInput.files = dt.files;
                    
                    updatePreview();
                    updateShareButtonState();
                    
                    createFloatingEmoji('ðŸŽ¥', window.innerWidth/2, 100);
                    vibeVibrate(50);
                };
                
                videoMediaRecorder.start(1000);
                isRecordingVideo = true;
                videoRecordingStartTime = Date.now();
                
                updateVideoRecordingTimer();
                videoRecordingTimer = setInterval(updateVideoRecordingTimer, 1000);
                
                videoRecordBtn.classList.add('recording');
                recordingIndicator.classList.remove('hidden');
                finishRecordingBtn.style.display = 'block';
                
                const videoStatusText = document.getElementById('videoRecordingText');
                if (videoStatusText) {
                    videoStatusText.textContent = genZRecordingPhrases.video[Math.floor(Math.random() * genZRecordingPhrases.video.length)];
                }
                videoRecordingStatus.classList.remove('hidden');
                
            } catch (err) {
                console.error('Video recording error:', err);
                showAlert('recording error', 'Error starting recording. please try again.', 'ðŸ˜¢', [
                    {text: 'ok', type: 'primary'}
                ]);
            }
        }

        function stopVideoRecording() {
            if (videoMediaRecorder && isRecordingVideo) {
                videoMediaRecorder.stop();
                isRecordingVideo = false;
                
                clearInterval(videoRecordingTimer);
                
                videoRecordBtn.classList.remove('recording');
                recordingIndicator.classList.add('hidden');
                videoRecordingStatus.classList.add('hidden');
                
                stopBackgroundMusic();
                
                vibeVibrate([30, 50, 30]);
            }
        }

        function updateVideoRecordingTimer() {
            if (!isRecordingVideo) return;
            
            const elapsedTime = Date.now() - videoRecordingStartTime;
            const elapsedSeconds = Math.floor(elapsedTime / 1000);
            
            recorderTimer.textContent = formatTime(elapsedSeconds);
            videoRecordingTimeEl.textContent = formatTime(elapsedSeconds);
            
            if (elapsedTime >= MAX_RECORDING_TIME) {
                stopVideoRecording();
                finishVideoRecording();
            }
        }

        function finishVideoRecording() {
            if (isRecordingVideo) {
                stopVideoRecording();
            }
        }

        function cancelVideoRecording() {
            if (isRecordingVideo) {
                stopVideoRecording();
            }
            videoChunks = [];
            currentVideoBlob = null;
            videoRecorderModal.classList.remove('active');
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            stopBackgroundMusic();
        }

        async function flipVideoCamera() {
            isFrontCameraVideo = !isFrontCameraVideo;
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                await startVideoPreview();
            }
        }

        function toggleMicrophone() {
            isMicOn = !isMicOn;
            if (videoStream) {
                videoStream.getAudioTracks().forEach(track => {
                    track.enabled = isMicOn;
                });
            }
            if (micGainNode) {
                micGainNode.gain.value = isMicOn ? 1.0 : 0.0;
            }
            toggleMicBtn.innerHTML = isMicOn ? 
                '<i class="fas fa-microphone"></i>' : 
                '<i class="fas fa-microphone-slash"></i>';
        }

        function handleMusicSelect(input) {
            if (input.files.length > 0) {
                const file = input.files[0];
                
                if (!file.type.startsWith('audio/')) {
                    showAlert('invalid file', 'Please select a valid audio file.', 'ðŸŽµ', [
                        {text: 'ok', type: 'primary'}
                    ]);
                    input.value = '';
                    musicBuffer = null;
                    soundSelectionText.textContent = 'add sound';
                    return;
                }

                const fileName = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
                soundSelectionText.textContent = fileName + ' âœ“';
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        if (!audioContext) {
                            audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        }
                        if (audioContext.state !== 'running') {
                            await audioContext.resume();
                        }
                        musicBuffer = await audioContext.decodeAudioData(e.target.result);
                        
                        if (isRecordingVideo) {
                            playBackgroundMusic();
                        }
                    } catch (error) {
                        console.error('Error decoding audio:', error);
                        musicBuffer = null;
                        soundSelectionText.textContent = 'add sound';
                        showAlert('audio error', 'Could not process the audio file.', 'ðŸ˜¢', [
                            {text: 'ok', type: 'primary'}
                        ]);
                    }
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function playBackgroundMusic() {
            if (!musicBuffer || !audioContext) return;
            
            if (musicSourceNode) {
                try {
                    musicSourceNode.stop();
                } catch(e) {}
                musicSourceNode.disconnect();
            }
            
            musicSourceNode = audioContext.createBufferSource();
            musicSourceNode.buffer = musicBuffer;
            musicSourceNode.loop = true;
            
            musicGainNode = audioContext.createGain();
            musicGainNode.gain.value = 0.3;
            
            musicSourceNode.connect(musicGainNode);
            musicGainNode.connect(audioContext.destination);
            
            musicSourceNode.start(0);
            isMusicPlaying = true;
        }

        function stopBackgroundMusic() {
            if (musicSourceNode) {
                try {
                    musicSourceNode.stop();
                } catch(e) {}
                musicSourceNode.disconnect();
                musicSourceNode = null;
            }
            isMusicPlaying = false;
        }

        function handleVideoSelect(input) {
            if (input.files.length > 0) {
                const file = input.files[0];
                
                if (!file.type.startsWith('video/')) {
                    showAlert('invalid file', 'Please select a video file.', 'ðŸŽ¥', [
                        {text: 'ok', type: 'primary'}
                    ]);
                    input.value = '';
                    return;
                }
                
                if (file.size > 200 * 1024 * 1024) {
                    showAlert('file too large', 'Video file must be less than 200MB.', 'ðŸ“', [
                        {text: 'ok', type: 'primary'}
                    ]);
                    input.value = '';
                    return;
                }
                
                currentVideoBlob = file;
                const videoUrl = URL.createObjectURL(file);
                videoElement.src = videoUrl;
                videoElement.load();
                
                const dt = new DataTransfer();
                dt.items.add(file);
                videoFileInput.files = dt.files;
                
                videoPlayer.classList.add('active');
                
                updatePreview();
                updateFileSizeDisplay();
                
                createFloatingEmoji('ðŸ“¹', window.innerWidth/2, 100);
                vibeVibrate(20);
            }
            updateShareButtonState();
        }

        function keepVideo() {
            if (currentVideoBlob) {
                const file = new File([currentVideoBlob], 'video.webm', { type: 'video/webm' });
                const dt = new DataTransfer();
                dt.items.add(file);
                videoFileInput.files = dt.files;
                
                updatePreview();
                createFloatingEmoji('ðŸ’¾', window.innerWidth/2, 100);
            }
        }

        function discardVideo() {
            videoPlayer.classList.remove('active');
            videoElement.pause();
            videoElement.src = '';
            currentVideoBlob = null;
            
            videoFileInput.value = '';
            videoUploadInput.value = '';
            
            updatePreview();
            updateShareButtonState();
            
            createFloatingEmoji('ðŸ—‘ï¸', window.innerWidth/2, 100);
        }

        function closeVideoPlayer() {
            videoPlayer.classList.remove('active');
        }

        function editVideo() {
            if (currentVideoBlob) {
                currentEditingFile = currentVideoBlob;
                currentEditingType = 'video';
                openMediaEditor();
            }
        }

        // =================== Audio Recording Functions ===================
        async function startAudioRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        channelCount: 2,
                        sampleRate: 48000
                    } 
                });
                
                audioMediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 128000 // High quality audio
                });
                
                audioChunks = [];
                
                audioMediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                audioMediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    currentAudioBlob = audioBlob;
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    audioElement.src = audioUrl;
                    audioElement.load();
                    
                    audioFilename.textContent = 'recording';
                    
                    audioPlayer.classList.add('active');
                    
                    stream.getTracks().forEach(track => track.stop());
                    
                    const file = new File([audioBlob], 'audio.webm', { type: 'audio/webm' });
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    audioFileInput.files = dt.files;
                    
                    updatePreview();
                    updateFileSizeDisplay();
                    updateShareButtonState();
                    
                    const audioStatusText = document.querySelector('#recordingStatus .kf-recording-text');
                    if (audioStatusText) {
                        audioStatusText.textContent = genZRecordingPhrases.audio[Math.floor(Math.random() * genZRecordingPhrases.audio.length)];
                    }
                    
                    createFloatingEmoji('ðŸŽ¤', window.innerWidth/2, 100);
                };
                
                audioMediaRecorder.start(100);
                isRecordingAudio = true;
                audioRecordingStartTime = Date.now();
                
                audioRecordingTimer = setInterval(updateAudioRecordingTimer, 1000);
                
                recordingStatus.classList.remove('hidden');
                vibeVibrate(30);
                
            } catch(err) {
                showAlert('microphone access', 'Microphone access is required to record audio.', 'ðŸŽ¤', [
                    {text: 'got it', type: 'primary'}
                ]);
                console.error('Recording error:', err);
            }
        }

        function updateAudioRecordingTimer() {
            if (!isRecordingAudio) return;
            const elapsedSeconds = Math.floor((Date.now() - audioRecordingStartTime) / 1000);
            recordingTimeEl.textContent = formatTime(elapsedSeconds);
        }

        function stopAudioRecording() {
            if (audioMediaRecorder && isRecordingAudio) {
                audioMediaRecorder.stop();
                isRecordingAudio = false;
                
                clearInterval(audioRecordingTimer);
                
                recordingStatus.classList.add('hidden');
                
                createFloatingEmoji('â¹ï¸', window.innerWidth/2, 100);
                vibeVibrate([30, 50, 30]);
            }
        }

        function handleAudioSelect(input) {
            if (input.files.length > 0) {
                const file = input.files[0];
                
                if (!file.type.startsWith('audio/')) {
                    showAlert('invalid file', 'Please select an audio file.', 'ðŸŽµ', [
                        {text: 'ok', type: 'primary'}
                    ]);
                    input.value = '';
                    return;
                }
                
                currentAudioBlob = file;
                const audioUrl = URL.createObjectURL(file);
                audioElement.src = audioUrl;
                audioElement.load();
                
                const dt = new DataTransfer();
                dt.items.add(file);
                audioFileInput.files = dt.files;
                
                audioFilename.textContent = file.name.length > 30 ? file.name.substring(0, 27) + '...' : file.name;
                
                audioPlayer.classList.add('active');
                
                updatePreview();
                updateFileSizeDisplay();
                
                createFloatingEmoji('ðŸ“»', window.innerWidth/2, 100);
                vibeVibrate(20);
            }
            updateShareButtonState();
        }

        function keepAudio() {
            if (currentAudioBlob) {
                const file = new File([currentAudioBlob], 'audio.webm', { type: 'audio/webm' });
                const dt = new DataTransfer();
                dt.items.add(file);
                audioFileInput.files = dt.files;
                
                updatePreview();
                createFloatingEmoji('ðŸ’¾', window.innerWidth/2, 100);
            }
        }

        function discardAudio() {
            audioPlayer.classList.remove('active');
            audioElement.pause();
            audioElement.src = '';
            currentAudioBlob = null;
            isPlaying = false;
            
            audioFileInput.value = '';
            audioUploadInput.value = '';
            
            updatePreview();
            updateShareButtonState();
            
            createFloatingEmoji('ðŸ—‘ï¸', window.innerWidth/2, 100);
        }

        function closeAudioPlayer() {
            audioPlayer.classList.remove('active');
        }

        // Audio player controls
        audioElement.volume = 0.8;

        playAudioBtn.addEventListener('click', function() {
            if (!audioElement.src) return;
            
            if (isPlaying) {
                audioElement.pause();
                playAudioBtn.innerHTML = '<i class="fas fa-play"></i>';
                playAudioBtn.classList.remove('playing');
            } else {
                audioElement.play().then(() => {
                    playAudioBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    playAudioBtn.classList.add('playing');
                }).catch(err => console.error('Playback error:', err));
            }
            isPlaying = !isPlaying;
        });

        audioElement.addEventListener('timeupdate', function() {
            if (audioElement.duration) {
                const progress = (audioElement.currentTime / audioElement.duration) * 100;
                audioProgressFilled.style.width = `${progress}%`;
                currentTimeEl.textContent = formatTime(audioElement.currentTime);
                durationTimeEl.textContent = formatTime(audioElement.duration);
            }
        });

        audioElement.addEventListener('ended', function() {
            playAudioBtn.innerHTML = '<i class="fas fa-play"></i>';
            playAudioBtn.classList.remove('playing');
            isPlaying = false;
            audioProgressFilled.style.width = '0%';
            currentTimeEl.textContent = '0:00';
        });

        audioProgress.addEventListener('click', function(e) {
            if (!audioElement.duration) return;
            const rect = audioProgress.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            audioElement.currentTime = pos * audioElement.duration;
        });

        // =================== Editor Functions ===================
        function openMediaEditor() {
            mediaEditorModal.classList.add('active');
            
            setTimeout(() => {
                if (currentEditingType === 'image') {
                    editorCanvas.classList.remove('hidden');
                    videoEditorElement.classList.add('hidden');
                    const url = URL.createObjectURL(currentEditingFile);
                    loadImageIntoEditor(url);
                } else if (currentEditingType === 'video') {
                    editorCanvas.classList.add('hidden');
                    videoEditorElement.classList.remove('hidden');
                    const url = URL.createObjectURL(currentEditingFile);
                    videoEditorElement.src = url;
                    videoEditorElement.load();
                    
                    videoEditorElement.addEventListener('loadedmetadata', () => {
                        videoDuration = videoEditorElement.duration;
                        document.getElementById('trimStart').textContent = formatTime(0);
                        document.getElementById('trimEnd').textContent = formatTime(videoDuration);
                        
                        document.getElementById('trimStartSlider').max = 100;
                        document.getElementById('trimEndSlider').max = 100;
                        document.getElementById('trimStartSlider').value = 0;
                        document.getElementById('trimEndSlider').value = 100;
                    });
                }
            }, 100);
        }

        function closeMediaEditor() {
            mediaEditorModal.classList.remove('active');
            overlayElements.forEach(el => el.remove());
            overlayElements = [];
            
            if (videoEditorElement) {
                videoEditorElement.pause();
                videoEditorElement.src = '';
            }
        }

        function loadImageIntoEditor(url) {
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            img.onload = function() {
                originalImage = img;
                
                const container = editorCanvasContainer;
                const maxWidth = container.clientWidth - 40;
                const maxHeight = container.clientHeight - 40;
                
                let width = img.width;
                let height = img.height;
                const ratio = Math.min(maxWidth / width, maxHeight / height, 1);
                
                editorCanvas.width = width * ratio;
                editorCanvas.height = height * ratio;
                
                canvasContext = editorCanvas.getContext('2d');
                canvasContext.imageSmoothingEnabled = true;
                canvasContext.imageSmoothingQuality = 'high';
                canvasContext.drawImage(img, 0, 0, editorCanvas.width, editorCanvas.height);
            };
            img.src = url;
        }

        function showEditorPanel(panelName, btn) {
            document.querySelectorAll('.kf-editor-panel').forEach(p => p.classList.remove('active'));
            document.getElementById(panelName + 'Panel').classList.add('active');
            
            document.querySelectorAll('.kf-editor-tool-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            if (currentEditingType === 'image' && panelName === 'trim') {
                document.getElementById('trimPanel').classList.remove('active');
            }
        }

        // =================== Video Trim Functions ===================
        function updateTrimStart() {
            const slider = document.getElementById('trimStartSlider');
            const startPercent = slider.value;
            const startTime = (startPercent / 100) * videoDuration;
            document.getElementById('trimStart').textContent = formatTime(startTime);
            videoTrimStart = startPercent;
        }

        function updateTrimEnd() {
            const slider = document.getElementById('trimEndSlider');
            const endPercent = slider.value;
            const endTime = (endPercent / 100) * videoDuration;
            document.getElementById('trimEnd').textContent = formatTime(endTime);
            videoTrimEnd = endPercent;
        }

        function previewTrim() {
            const startTime = (videoTrimStart / 100) * videoDuration;
            const endTime = (videoTrimEnd / 100) * videoDuration;
            
            videoEditorElement.currentTime = startTime;
            videoEditorElement.play();
            
            setTimeout(() => {
                videoEditorElement.pause();
                videoEditorElement.currentTime = startTime;
            }, (endTime - startTime) * 1000);
        }

        // =================== Text Overlay with Drag ===================
        function addTextOverlay() {
            editorTextInput.classList.remove('hidden');
            editorTextInput.focus();
            
            editorTextInput.onchange = function() {
                const text = this.value.trim();
                if (text) {
                    createDraggableElement(text, 'text');
                }
                editorTextInput.classList.add('hidden');
                editorTextInput.value = '';
            };
        }

        function createDraggableElement(content, type) {
            const div = document.createElement('div');
            div.className = 'kf-editor-overlay-text';
            
            if (type === 'sticker') {
                div.textContent = content;
                div.style.fontSize = '48px';
                div.style.background = 'transparent';
                div.style.border = '2px dashed rgba(255,255,255,0.5)';
            } else {
                div.textContent = content;
                div.style.fontSize = '32px';
            }
            
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'kf-overlay-delete';
            deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                div.remove();
                overlayElements = overlayElements.filter(el => el !== div);
                if (activeOverlayElement === div) {
                    activeOverlayElement = null;
                }
            };
            div.appendChild(deleteBtn);
            
            const containerRect = editorCanvasContainer.getBoundingClientRect();
            div.style.left = '50%';
            div.style.top = '50%';
            
            div.addEventListener('mousedown', startDrag);
            div.addEventListener('touchstart', startDrag, { passive: false });
            
            div.addEventListener('click', (e) => {
                e.stopPropagation();
                selectOverlay(div);
            });
            
            editorCanvasContainer.appendChild(div);
            overlayElements.push(div);
            selectOverlay(div);
        }

        function selectOverlay(element) {
            overlayElements.forEach(el => {
                el.classList.remove('selected');
            });
            element.classList.add('selected');
            activeOverlayElement = element;
        }

        function deselectOverlay() {
            overlayElements.forEach(el => {
                el.classList.remove('selected');
            });
            activeOverlayElement = null;
        }

        function startDrag(e) {
            e.preventDefault();
            const element = e.target.closest('.kf-editor-overlay-text');
            if (!element) return;
            
            isDragging = true;
            selectOverlay(element);
            element.classList.add('dragging');
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            if (!clientX || !clientY) return;
            
            const rect = element.getBoundingClientRect();
            dragOffset.x = clientX - rect.left;
            dragOffset.y = clientY - rect.top;
            
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function onDrag(e) {
            if (!isDragging || !activeOverlayElement) return;
            e.preventDefault();
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            if (!clientX || !clientY) return;
            
            const containerRect = editorCanvasContainer.getBoundingClientRect();
            const elementRect = activeOverlayElement.getBoundingClientRect();
            
            let x = clientX - containerRect.left - dragOffset.x;
            let y = clientY - containerRect.top - dragOffset.y;
            
            x = Math.max(0, Math.min(x, containerRect.width - elementRect.width));
            y = Math.max(0, Math.min(y, containerRect.height - elementRect.height));
            
            activeOverlayElement.style.left = x + 'px';
            activeOverlayElement.style.top = y + 'px';
            activeOverlayElement.style.transform = 'none';
        }

        function stopDrag() {
            isDragging = false;
            if (activeOverlayElement) {
                activeOverlayElement.classList.remove('dragging');
            }
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('touchmove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }

        function setTextColor(color) {
            if (activeOverlayElement) {
                activeOverlayElement.style.color = color;
            }
        }

        function setTextFont(font) {
            if (activeOverlayElement) {
                activeOverlayElement.style.fontFamily = font;
            }
        }

        function increaseTextSize() {
            if (activeOverlayElement) {
                const current = parseInt(activeOverlayElement.style.fontSize) || 32;
                activeOverlayElement.style.fontSize = (current + 4) + 'px';
            }
        }

        function decreaseTextSize() {
            if (activeOverlayElement) {
                const current = parseInt(activeOverlayElement.style.fontSize) || 32;
                if (current > 12) {
                    activeOverlayElement.style.fontSize = (current - 4) + 'px';
                }
            }
        }

        function addSticker(sticker) {
            createDraggableElement(sticker, 'sticker');
        }

        // =================== Filter Functions ===================
        function applyFilter(filter, element) {
            if (!canvasContext || !originalImage) return;
            
            canvasContext.drawImage(originalImage, 0, 0, editorCanvas.width, editorCanvas.height);
            
            const imageData = canvasContext.getImageData(0, 0, editorCanvas.width, editorCanvas.height);
            const data = imageData.data;
            
            switch(filter) {
                case 'vintage':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = data[i] * 0.9;
                        data[i+1] = data[i+1] * 0.8;
                        data[i+2] = data[i+2] * 0.7;
                    }
                    break;
                case 'bw':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                        data[i] = data[i+1] = data[i+2] = avg;
                    }
                    break;
                case 'vivid':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.3);
                        data[i+1] = Math.min(255, data[i+1] * 1.2);
                        data[i+2] = Math.min(255, data[i+2] * 1.1);
                    }
                    break;
                case 'cool':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = data[i] * 0.8;
                        data[i+1] = data[i+1] * 0.9;
                        data[i+2] = data[i+2] * 1.2;
                    }
                    break;
                case 'warm':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.2);
                        data[i+1] = data[i+1] * 1.0;
                        data[i+2] = data[i+2] * 0.8;
                    }
                    break;
            }
            
            canvasContext.putImageData(imageData, 0, 0);
            
            document.querySelectorAll('.kf-filter-option').forEach(opt => opt.classList.remove('active'));
            element.classList.add('active');
        }

        // =================== Drawing Functions ===================
        editorCanvas.addEventListener('mousedown', startDrawing);
        editorCanvas.addEventListener('mousemove', draw);
        editorCanvas.addEventListener('mouseup', stopDrawing);
        editorCanvas.addEventListener('mouseleave', stopDrawing);
        
        editorCanvas.addEventListener('touchstart', startDrawingTouch, { passive: false });
        editorCanvas.addEventListener('touchmove', drawTouch, { passive: false });
        editorCanvas.addEventListener('touchend', stopDrawing);
        editorCanvas.addEventListener('touchcancel', stopDrawing);

        function startDrawing(e) {
            if (!canvasContext) return;
            e.preventDefault();
            isDrawing = true;
            
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            
            lastX = (e.clientX - rect.left) * scaleX;
            lastY = (e.clientY - rect.top) * scaleY;
        }

        function startDrawingTouch(e) {
            if (!canvasContext) return;
            e.preventDefault();
            isDrawing = true;
            
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            
            lastX = (e.touches[0].clientX - rect.left) * scaleX;
            lastY = (e.touches[0].clientY - rect.top) * scaleY;
        }

        function draw(e) {
            if (!isDrawing || !canvasContext) return;
            e.preventDefault();
            
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            canvasContext.beginPath();
            canvasContext.strokeStyle = drawColor;
            canvasContext.lineWidth = drawSize;
            canvasContext.lineCap = 'round';
            canvasContext.moveTo(lastX, lastY);
            canvasContext.lineTo(x, y);
            canvasContext.stroke();
            
            lastX = x;
            lastY = y;
        }

        function drawTouch(e) {
            if (!isDrawing || !canvasContext) return;
            e.preventDefault();
            
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            
            const x = (e.touches[0].clientX - rect.left) * scaleX;
            const y = (e.touches[0].clientY - rect.top) * scaleY;
            
            canvasContext.beginPath();
            canvasContext.strokeStyle = drawColor;
            canvasContext.lineWidth = drawSize;
            canvasContext.lineCap = 'round';
            canvasContext.moveTo(lastX, lastY);
            canvasContext.lineTo(x, y);
            canvasContext.stroke();
            
            lastX = x;
            lastY = y;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function setDrawColor(color) {
            drawColor = color;
        }

        function setDrawSize(size) {
            drawSize = parseInt(size);
        }

        function clearDraw() {
            if (!canvasContext || !originalImage) return;
            canvasContext.drawImage(originalImage, 0, 0, editorCanvas.width, editorCanvas.height);
        }

        // =================== Adjustment Functions ===================
        function adjustBrightness(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const value = Math.round(((e.clientX - rect.left) / rect.width) * 100);
            document.getElementById('brightnessValue').value = value;
            document.getElementById('brightnessFill').style.width = value + '%';
        }

        function adjustContrast(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const value = Math.round(((e.clientX - rect.left) / rect.width) * 100);
            document.getElementById('contrastValue').value = value;
            document.getElementById('contrastFill').style.width = value + '%';
        }

        function setBrightness(value) {
            document.getElementById('brightnessFill').style.width = value + '%';
        }

        function setContrast(value) {
            document.getElementById('contrastFill').style.width = value + '%';
        }

        function resetEdits() {
            if (currentEditingType === 'image' && originalImage && canvasContext) {
                canvasContext.drawImage(originalImage, 0, 0, editorCanvas.width, editorCanvas.height);
            } else if (currentEditingType === 'video') {
                videoEditorElement.currentTime = 0;
                videoTrimStart = 0;
                videoTrimEnd = 100;
                document.getElementById('trimStartSlider').value = 0;
                document.getElementById('trimEndSlider').value = 100;
                if (videoDuration) {
                    document.getElementById('trimStart').textContent = formatTime(0);
                    document.getElementById('trimEnd').textContent = formatTime(videoDuration);
                }
            }
            
            overlayElements.forEach(el => el.remove());
            overlayElements = [];
            
            document.querySelectorAll('.kf-filter-option').forEach(opt => opt.classList.remove('active'));
            document.querySelector('.kf-filter-option:first-child').classList.add('active');
        }

        // =================== Save Edited Media (High Quality) ===================
        function saveEditedMedia() {
            if (currentEditingType === 'image') {
                // Create high-res canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalImage.width;
                tempCanvas.height = originalImage.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.imageSmoothingEnabled = true;
                tempCtx.imageSmoothingQuality = 'high';
                
                // Draw original image
                tempCtx.drawImage(originalImage, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // Apply edits from editor canvas
                const scaledEditorCanvas = document.createElement('canvas');
                scaledEditorCanvas.width = tempCanvas.width;
                scaledEditorCanvas.height = tempCanvas.height;
                const scaledCtx = scaledEditorCanvas.getContext('2d');
                scaledCtx.imageSmoothingEnabled = true;
                scaledCtx.imageSmoothingQuality = 'high';
                
                scaledCtx.drawImage(editorCanvas, 0, 0, scaledEditorCanvas.width, scaledEditorCanvas.height);
                tempCtx.globalCompositeOperation = 'source-over';
                tempCtx.drawImage(scaledEditorCanvas, 0, 0);
                
                // Draw overlays at full resolution
                const containerRect = editorCanvasContainer.getBoundingClientRect();
                const canvasRect = editorCanvas.getBoundingClientRect();
                
                overlayElements.forEach(el => {
                    const style = window.getComputedStyle(el);
                    const text = el.textContent.replace('âœ•', '').trim();
                    
                    const elRect = el.getBoundingClientRect();
                    
                    if (elRect.right < canvasRect.left || elRect.left > canvasRect.right || 
                        elRect.bottom < canvasRect.top || elRect.top > canvasRect.bottom) {
                        return;
                    }
                    
                    let x = elRect.left - canvasRect.left;
                    let y = elRect.top - canvasRect.top;
                    
                    const scaleX = tempCanvas.width / canvasRect.width;
                    const scaleY = tempCanvas.height / canvasRect.height;
                    
                    x = x * scaleX;
                    y = y * scaleY;
                    
                    const fontSize = parseInt(style.fontSize) * (scaleX);
                    
                    tempCtx.font = `${fontSize}px ${style.fontFamily}`;
                    tempCtx.fillStyle = style.color;
                    tempCtx.textBaseline = 'top';
                    tempCtx.shadowColor = 'rgba(0,0,0,0.5)';
                    tempCtx.shadowBlur = fontSize * 0.1;
                    tempCtx.shadowOffsetX = fontSize * 0.05;
                    tempCtx.shadowOffsetY = fontSize * 0.05;
                    
                    tempCtx.fillText(text, x, y);
                });
                
                // Save at highest quality
                tempCanvas.toBlob(function(blob) {
                    const file = new File([blob], 'edited_image.jpg', { type: IMAGE_QUALITY.format });
                    
                    const index = selectedImages.findIndex(f => f === currentEditingFile);
                    if (index !== -1) {
                        selectedImages[index] = file;
                        
                        const dt = new DataTransfer();
                        selectedImages.forEach(f => dt.items.add(f));
                        imageInput.files = dt.files;
                        
                        renderImagePreviews();
                    }
                    
                    closeMediaEditor();
                    updatePreview();
                    updateFileSizeDisplay();
                    
                    createFloatingEmoji('âœ¨', window.innerWidth/2, 100);
                    vibeVibrate(30);
                    
                }, IMAGE_QUALITY.format, IMAGE_QUALITY.quality);
            } else if (currentEditingType === 'video') {
                if (videoTrimStart > 0 || videoTrimEnd < 100) {
                    showAlert('trim preview', 'Video trimming requires backend processing. The original video will be used for now.', 'ðŸŽ¬', [
                        {text: 'got it', type: 'primary'}
                    ]);
                }
                
                closeMediaEditor();
                createFloatingEmoji('ðŸŽ¬', window.innerWidth/2, 100);
            }
        }

        // =================== Other Functions ===================
        function closePost() {
            if (textarea.value.trim() || selectedImages.length > 0 || currentVideoBlob || currentAudioBlob || selectedMood || selectedCustomMood) {
                showAlert('discard vibe?', 'discard this aesthetic? ðŸ’”', 'ðŸ’”', [
                    {text: 'cancel', type: 'secondary'},
                    {text: 'discard', type: 'danger'}
                ]).then(result => {
                    if (result === 'discard') {
                        window.location.href = '/';
                    }
                });
            } else {
                window.location.href = '/';
            }
        }

        // Vibe Check Button
        vibeCheckBtn.addEventListener('click', function() {
            const text = textarea.value.trim();
            
            if (text) {
                const reactions = ['âœ¨ vibes immaculate', 'ðŸ”¥ no cap', 'ðŸ’… serving', 'â­ main character', 'ðŸŽµ it\'s giving', 'ðŸ’¯ hits different', 'ðŸ¥¶ sheesh', 'â¸ï¸ periodt'];
                const reaction = reactions[Math.floor(Math.random() * reactions.length)];
                
                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    color: white;
                    padding: 20px 30px;
                    border-radius: 40px;
                    font-size: 24px;
                    z-index: 10000;
                    animation: floatEmoji 2s ease-out forwards;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                    font-weight: 700;
                `;
                popup.textContent = reaction;
                document.body.appendChild(popup);
                setTimeout(() => popup.remove(), 2000);
                
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const emojis = ['âœ¨', 'ðŸ”¥', 'ðŸ’…', 'â­', 'ðŸŽµ', 'ðŸŒ¸', 'ðŸ’«', 'ðŸŒŸ'];
                        createFloatingEmoji(emojis[Math.floor(Math.random() * emojis.length)], 
                            window.innerWidth/2, window.innerHeight/2);
                    }, i * 100);
                }
                
                vibeVibrate([50, 100, 50]);
            } else {
                showAlert('no text', 'add some text first bestie âœ¨', 'ðŸ’…', [
                    {text: 'ok', type: 'primary'}
                ]);
                textarea.focus();
            }
        });

        // Form submission
        document.getElementById('postForm').addEventListener('submit', function(e) {
            const hasContent = textarea.value.trim().length > 0 || selectedImages.length > 0 || currentVideoBlob || currentAudioBlob;
            
            if (!hasContent) {
                e.preventDefault();
                showAlert('empty post', 'add something bestie âœ¨', 'ðŸ’…', [
                    {text: 'ok', type: 'primary'}
                ]);
                return;
            }
            
            const randomMessage = genZLoadingMessages[Math.floor(Math.random() * genZLoadingMessages.length)];
            const randomSubtext = genZLoadingSubtexts[Math.floor(Math.random() * genZLoadingSubtexts.length)];
            loadingText.textContent = randomMessage;
            loadingSubtext.textContent = randomSubtext;
            
            loadingOverlay.classList.add('active');
            sharePostBtn.disabled = true;
            sharePostBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> posting...';
            
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const emojis = ['âœ¨', 'ðŸ”¥', 'ðŸ’…', 'â­', 'ðŸŽµ', 'ðŸš€', 'ðŸŒ¸', 'ðŸ’«'];
                    createFloatingEmoji(emojis[Math.floor(Math.random() * emojis.length)], 
                        window.innerWidth/2, window.innerHeight/2);
                }, i * 150);
            }
        });

        // Initialize
        updatePreview();

        // =================== SNAPCHAT-STYLE LENS & UI FUNCTIONS ===================

        /**
         * snapSelectLens â€” called when tapping a lens in the carousel.
         * Applies the filter, highlights the tile, shows the badge & effects row.
         */
        function snapSelectLens(el, filterId, name, emoji) {
            // Update carousel active state
            document.querySelectorAll('.snap-lens-item').forEach(i => i.classList.remove('active'));
            el.classList.add('active');

            // Apply the AR filter
            currentARFilter = filterId;

            // Show lens badge briefly
            const badge = document.getElementById('snapLensBadge');
            badge.textContent = emoji + ' ' + name;
            badge.classList.add('visible');
            setTimeout(() => badge.classList.remove('visible'), 2200);

            // Show face effects row whenever a non-clean lens is active
            const effectsRow = document.getElementById('snapEffectsRow');
            if (filterId === 'none') {
                effectsRow.classList.remove('visible');
            } else {
                effectsRow.classList.add('visible');
            }

            showARGestureHint(emoji + ' ' + name);
            vibeVibrate(15);
        }

        /**
         * toggleEffectChip â€” toggle the active state of face-effect chips.
         */
        function toggleEffectChip(el) {
            el.classList.toggle('active');
        }

        /**
         * handleSnapGallery â€” when user picks from gallery in camera mode,
         * treat it the same as picking from the main gallery.
         */
        function handleSnapGallery(input) {
            if (!input.files || !input.files.length) return;
            const file = input.files[0];
            selectedImages = [...selectedImages, file];
            const dt = new DataTransfer();
            selectedImages.forEach(f => dt.items.add(f));
            imageInput.files = dt.files;
            renderImagePreviews();
            updatePreview();
            updateFileSizeDisplay();
            closeCamera();
            createFloatingEmoji('ðŸ–¼ï¸', window.innerWidth / 2, 100);
            vibeVibrate(20);
        }

        /**
         * toggleFlash â€” stub for flash toggle (visual feedback only on web).
         */
        let _flashOn = false;
        function toggleFlash() {
            _flashOn = !_flashOn;
            const btn = document.getElementById('snapFlashBtn');
            if (btn) {
                btn.style.color = _flashOn ? '#FFFC00' : 'white';
                btn.style.textShadow = _flashOn ? '0 0 10px #FFFC00' : 'none';
            }
            showARGestureHint(_flashOn ? 'âš¡ Flash on' : 'âš¡ Flash off');
        }

        /**
         * snapSidebarAction â€” stubs for right-sidebar icon buttons.
         */
        function snapSidebarAction(action) {
            const labels = {
                music: 'ðŸŽµ add music',
                text: 'âœï¸ add text',
                sticker: 'ðŸ˜Š add sticker',
                scissors: 'âœ‚ï¸ scissors',
                timer: 'â±ï¸ set timer'
            };
            showARGestureHint(labels[action] || action);
            vibeVibrate(10);
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            if (arAnimationFrame) {
                cancelAnimationFrame(arAnimationFrame);
            }
            stopBackgroundMusic();
        });
    </script>
</body>
</html>
