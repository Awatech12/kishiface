{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>create a vibe ðŸŽ¨ - Kishiface</title>
    <link rel="shortcut icon" href="{% static 'images/logo.jpg' %}" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Kishiface-Inspired Design Variables */
        :root {
            --ig-bg: #ffffff;
            --ig-header-bg: #ffffff;
            --ig-border: #dbdbdb;
            --ig-primary: #0095f6;
            --ig-danger: #ed4956;
            --ig-text: #262626;
            --ig-text-light: #8e8e8e;
            --ig-text-lighter: #c7c7c7;
            --ig-separator: #efefef;
            --ig-input-bg: #fafafa;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            
            /* Mood Colors */
            --mood-slay: #ff1493;
            --mood-vibing: #9933ff;
            --mood-sheesh: #00cc66;
            --mood-periodt: #ff6b00;
            --mood-no-cap: #ff4444;
            --mood-bussin: #ffd700;
            --mood-mid: #808080;
            --mood-cringe: #8b4513;
            
            /* Editor Colors */
            --editor-toolbar: #1a1a1a;
            --editor-border: #333333;
            --editor-overlay: rgba(0,0,0,0.9);
            
            /* Custom Alert */
            --alert-bg: rgba(0,0,0,0.9);
            --alert-text: white;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--ig-bg);
            color: var(--ig-text);
            line-height: 1.5;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Main Container */
        .kf-main-container {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            background-color: var(--ig-bg);
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Post Creation Card */
        .kf-post-card {
            background-color: var(--ig-bg);
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .kf-post-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--ig-separator);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--ig-header-bg);
            flex-shrink: 0;
        }

        .kf-post-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--ig-text);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .kf-post-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--ig-text);
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kf-share-btn-header {
            background: none;
            border: none;
            color: var(--ig-primary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .kf-share-btn-header:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .kf-vibe-check {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            animation: subtleWiggle 3s infinite;
        }

        @keyframes subtleWiggle {
            0%, 100% { transform: rotate(0deg); }
            5% { transform: rotate(5deg); }
            10% { transform: rotate(-5deg); }
            15% { transform: rotate(0deg); }
        }

        @keyframes floatEmoji {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-100px) scale(1.5); opacity: 0; }
        }

        /* Content Area - Scrollable */
        .kf-post-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: 20px;
            scrollbar-width: thin;
        }

        .kf-post-content::-webkit-scrollbar {
            width: 4px;
        }

        .kf-post-content::-webkit-scrollbar-track {
            background: var(--ig-separator);
        }

        .kf-post-content::-webkit-scrollbar-thumb {
            background: var(--ig-text-light);
            border-radius: 2px;
        }

        /* ===== MOOD SELECTOR - Compact ===== */
        .kf-mood-section {
            padding: 12px 16px;
            border-bottom: 1px solid var(--ig-separator);
            background: linear-gradient(145deg, #fff9f9 0%, #f9f9ff 100%);
        }

        .kf-mood-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--ig-text);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kf-mood-label i {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Mood Row - Compact */
        .kf-mood-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .kf-mood-dropdown-container {
            position: relative;
            flex: 1;
        }

        .kf-mood-selector-btn {
            width: 100%;
            padding: 10px 12px;
            background: var(--ig-white);
            border: 2px solid var(--ig-separator);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            font-size: 14px;
            color: var(--ig-text);
        }

        .kf-mood-selector-btn:hover {
            border-color: var(--ig-primary);
        }

        .kf-mood-selector-btn i {
            color: var(--ig-text-light);
            transition: transform 0.3s ease;
        }

        .kf-mood-selector-btn.active i {
            transform: rotate(180deg);
        }

        .kf-selected-mood {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kf-selected-mood-emoji {
            font-size: 18px;
        }

        .kf-selected-mood-text {
            font-weight: 500;
            font-size: 13px;
        }

        /* Mood Dropdown */
        .kf-mood-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: var(--ig-white);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            max-height: 250px;
            overflow-y: auto;
            display: none;
            animation: slideDown 0.2s ease;
        }

        .kf-mood-dropdown.show {
            display: block;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .kf-mood-option {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            border-bottom: 1px solid var(--ig-separator);
        }

        .kf-mood-option:last-child {
            border-bottom: none;
        }

        .kf-mood-option:hover {
            background: var(--ig-input-bg);
        }

        .kf-mood-option-emoji {
            font-size: 18px;
            width: 30px;
            text-align: center;
        }

        .kf-mood-option-info {
            flex: 1;
        }

        .kf-mood-option-name {
            font-weight: 600;
            font-size: 13px;
        }

        .kf-mood-option-vibe {
            font-size: 11px;
            color: var(--ig-text-light);
        }

        /* Custom Mood - Simple */
        .kf-custom-mood-container {
            margin-top: 8px;
        }

        .kf-custom-mood-row {
            display: flex;
            gap: 6px;
        }

        .kf-custom-mood-input {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid var(--ig-separator);
            border-radius: 12px;
            font-size: 13px;
            outline: none;
        }

        .kf-custom-mood-input:focus {
            border-color: var(--ig-primary);
        }

        .kf-add-custom-btn {
            padding: 10px 16px;
            background: var(--ig-primary);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .kf-add-custom-btn:hover {
            opacity: 0.9;
        }

        .kf-custom-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .kf-custom-suggestion {
            padding: 6px 12px;
            background: var(--ig-input-bg);
            border: 1px solid var(--ig-separator);
            border-radius: 16px;
            font-size: 11px;
            cursor: pointer;
        }

        .kf-custom-suggestion:hover {
            background: var(--ig-primary);
            color: white;
        }

        /* Active Mood Badge */
        .kf-active-mood {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            background: linear-gradient(135deg, var(--ig-primary), #00b8ff);
            border-radius: 20px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            margin-top: 8px;
            animation: moodPop 0.3s ease;
        }

        .kf-active-mood.hidden {
            display: none;
        }

        @keyframes moodPop {
            0% { transform: scale(0); }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Textarea */
        .kf-textarea-container {
            padding: 12px 16px;
            border-bottom: 1px solid var(--ig-separator);
        }

        .kf-textarea {
            width: 100%;
            padding: 0;
            border: none;
            font-family: var(--font-family);
            font-size: 15px;
            resize: none;
            min-height: 60px;
            outline: none;
            background-color: transparent;
        }

        .kf-textarea::placeholder {
            color: var(--ig-text-light);
        }

        /* Media Grid */
        .kf-upload-section {
            padding: 12px 16px;
        }

        .kf-upload-label {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kf-media-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .kf-media-option {
            cursor: pointer;
        }

        .kf-media-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px 8px;
            background: var(--ig-white);
            border: 2px solid var(--ig-separator);
            border-radius: 12px;
            text-align: center;
            gap: 4px;
            transition: all 0.2s ease;
        }

        .kf-media-card:hover {
            border-color: var(--ig-primary);
            transform: translateY(-2px);
        }

        .kf-media-card i {
            font-size: 24px;
            color: var(--ig-text);
        }

        .kf-media-label {
            font-size: 12px;
            font-weight: 600;
        }

        .kf-media-sub-label {
            font-size: 9px;
            color: var(--ig-text-light);
        }

        .kf-media-option.camera .kf-media-card {
            background: linear-gradient(145deg, #fff0f0, #ffe5e5);
            border-color: var(--ig-primary);
        }

        .kf-media-option.camera .kf-media-card i {
            color: var(--ig-primary);
        }

        /* Image Preview Grid */
        .kf-image-preview-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin: 12px 0;
        }

        .kf-image-preview-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid var(--ig-separator);
        }

        .kf-image-preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .kf-image-preview-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        .kf-image-preview-item:hover .kf-image-preview-overlay {
            opacity: 1;
        }

        .kf-image-preview-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            background: var(--ig-danger);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            cursor: pointer;
            opacity: 0;
            z-index: 10;
        }

        .kf-image-preview-item:hover .kf-image-preview-remove {
            opacity: 1;
        }

        /* Camera Modal */
        .kf-camera-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 2000;
            flex-direction: column;
        }

        .kf-camera-modal.active {
            display: flex;
        }

        .kf-camera-header {
            padding: 16px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: absolute;
            top: 0;
            width: 100%;
            z-index: 10;
        }

        .kf-camera-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kf-camera-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kf-camera-preview {
            width: 100%;
            height: 100%;
            background: #000;
            position: relative;
        }

        .kf-camera-live {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .kf-camera-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            padding: 30px 20px 20px;
        }

        .kf-camera-capture-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: white;
            border: 5px solid rgba(255,255,255,0.3);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .kf-camera-capture-btn:active {
            transform: scale(0.95);
        }

        .kf-camera-flip-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .kf-captured-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
        }

        .kf-captured-image.hidden {
            display: none;
        }

        .kf-captured-image img {
            flex: 1;
            object-fit: contain;
            background: #000;
        }

        .kf-captured-actions {
            display: flex;
            gap: 16px;
            padding: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            position: absolute;
            bottom: 0;
            width: 100%;
            justify-content: center;
        }

        .kf-captured-action-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 30px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kf-captured-action-btn.keep {
            background: var(--ig-primary);
            color: white;
        }

        .kf-captured-action-btn.retake {
            background: rgba(255,255,255,0.2);
            color: white;
            backdrop-filter: blur(4px);
        }

        /* ===== CAMERA REAL-TIME EDITOR â€” Full Upgrade ===== */
        @import url('https://fonts.googleapis.com/css2?family=Pacifico&family=Bangers&family=Press+Start+2P&family=Dancing+Script:wght@700&family=Righteous&family=Black+Ops+One&display=swap');

        .kf-camera-modal {
            background: #000;
            flex-direction: column;
        }

        /* Bottom panel that switches between modes */
        .kf-cam-bottom-panel {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            z-index: 20;
            display: flex;
            flex-direction: column;
        }

        /* Mode tab bar */
        .kf-cam-mode-bar {
            display: flex;
            overflow-x: auto;
            scrollbar-width: none;
            background: rgba(0,0,0,0.0);
            padding: 0 8px;
        }
        .kf-cam-mode-bar::-webkit-scrollbar { display: none; }
        .kf-cam-mode-tab {
            flex-shrink: 0;
            padding: 6px 14px;
            color: rgba(255,255,255,0.55);
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .kf-cam-mode-tab.active {
            color: white;
            border-bottom-color: #fe2c55;
        }

        /* Sub-panel content areas */
        .kf-cam-sub-panel {
            display: none;
        }
        .kf-cam-sub-panel.show { display: flex; flex-direction: column; }

        /* Filter row */
        .kf-cam-filter-row {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 16px 6px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(12px);
            scrollbar-width: none;
        }
        .kf-cam-filter-row::-webkit-scrollbar { display: none; }
        .kf-cam-filter-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            flex-shrink: 0;
        }
        .kf-cam-filter-thumb {
            width: 56px; height: 56px;
            border-radius: 12px;
            overflow: hidden;
            border: 2.5px solid transparent;
            transition: border-color 0.2s, transform 0.18s;
            position: relative;
        }
        .kf-cam-filter-item.active .kf-cam-filter-thumb {
            border-color: #fe2c55;
            transform: scale(1.1);
        }
        .kf-cam-filter-thumb-bg {
            width: 100%; height: 100%;
            border-radius: 10px;
        }
        .kf-cam-filter-label {
            font-size: 10px;
            color: rgba(255,255,255,0.75);
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        .kf-cam-filter-item.active .kf-cam-filter-label { color: #fe2c55; }

        /* Adjustments sliders */
        .kf-cam-adjustments-panel {
            padding: 12px 16px 4px;
            background: rgba(0,0,0,0.75);
            backdrop-filter: blur(12px);
            display: flex;
            flex-direction: column;
            gap: 9px;
            max-height: 220px;
            overflow-y: auto;
        }
        .kf-cam-slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .kf-cam-slider-label {
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            width: 68px;
            text-align: right;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .kf-cam-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 3px;
            border-radius: 2px;
            background: rgba(255,255,255,0.25);
            outline: none;
            cursor: pointer;
        }
        .kf-cam-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px; height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fe2c55, #ff6b35);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(254,44,85,0.5);
        }
        .kf-cam-slider-value {
            font-size: 11px;
            color: #fe2c55;
            width: 32px;
            text-align: left;
            font-weight: 700;
            font-family: monospace;
        }

        /* Face effects panel */
        .kf-cam-face-panel {
            padding: 10px 16px 6px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(12px);
        }
        .kf-cam-face-row {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            scrollbar-width: none;
        }
        .kf-cam-face-row::-webkit-scrollbar { display: none; }
        .kf-cam-face-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            flex-shrink: 0;
        }
        .kf-cam-face-icon {
            width: 60px; height: 60px;
            border-radius: 14px;
            background: rgba(255,255,255,0.1);
            display: flex; align-items: center; justify-content: center;
            font-size: 30px;
            border: 2px solid transparent;
            transition: all 0.18s;
        }
        .kf-cam-face-item.active .kf-cam-face-icon {
            border-color: #fe2c55;
            background: rgba(254,44,85,0.2);
            transform: scale(1.1);
        }
        .kf-cam-face-label {
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            font-weight: 700;
            letter-spacing: 0.3px;
        }
        .kf-cam-face-item.active .kf-cam-face-label { color: #fe2c55; }

        /* Text overlay panel */
        .kf-cam-text-panel {
            padding: 10px 14px 6px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(12px);
        }
        .kf-cam-text-input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .kf-cam-text-input {
            flex: 1;
            padding: 10px 14px;
            border-radius: 24px;
            border: 1.5px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
            outline: none;
        }
        .kf-cam-text-input::placeholder { color: rgba(255,255,255,0.4); }
        .kf-cam-text-input:focus { border-color: #fe2c55; }
        .kf-cam-text-add-btn {
            padding: 10px 16px;
            border-radius: 24px;
            background: linear-gradient(135deg, #fe2c55, #ff6b35);
            border: none;
            color: white;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            white-space: nowrap;
        }
        /* Font family row */
        .kf-cam-font-row {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            scrollbar-width: none;
            margin-bottom: 8px;
        }
        .kf-cam-font-row::-webkit-scrollbar { display: none; }
        .kf-cam-font-btn {
            flex-shrink: 0;
            padding: 6px 12px;
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
            border: 1.5px solid rgba(255,255,255,0.15);
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }
        .kf-cam-font-btn.active {
            background: rgba(254,44,85,0.8);
            border-color: #fe2c55;
        }
        /* Color row */
        .kf-cam-color-row {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            scrollbar-width: none;
            margin-bottom: 6px;
        }
        .kf-cam-color-row::-webkit-scrollbar { display: none; }
        .kf-cam-color-dot {
            width: 28px; height: 28px;
            border-radius: 50%;
            cursor: pointer;
            flex-shrink: 0;
            border: 2.5px solid transparent;
            transition: transform 0.15s, border-color 0.15s;
        }
        .kf-cam-color-dot.active {
            border-color: white;
            transform: scale(1.2);
        }
        /* Text size row */
        .kf-cam-textsize-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .kf-cam-textsize-label {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            font-weight: 700;
            text-transform: uppercase;
            width: 36px;
        }

        /* Stickers panel */
        .kf-cam-sticker-panel {
            padding: 10px 16px 6px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(12px);
        }
        .kf-cam-sticker-cats {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            overflow-x: auto;
            scrollbar-width: none;
        }
        .kf-cam-sticker-cats::-webkit-scrollbar { display: none; }
        .kf-cam-sticker-cat {
            flex-shrink: 0;
            padding: 4px 12px;
            border-radius: 16px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.7);
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s;
        }
        .kf-cam-sticker-cat.active {
            background: rgba(254,44,85,0.8);
            border-color: #fe2c55;
            color: white;
        }
        .kf-cam-sticker-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-height: 120px;
            overflow-y: auto;
            scrollbar-width: none;
        }
        .kf-cam-sticker-grid::-webkit-scrollbar { display: none; }
        .kf-cam-sticker-btn {
            width: 46px; height: 46px;
            font-size: 28px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            border-radius: 10px;
            background: rgba(255,255,255,0.06);
            transition: transform 0.15s, background 0.15s;
            border: none;
        }
        .kf-cam-sticker-btn:active { transform: scale(1.25); background: rgba(254,44,85,0.3); }

        /* Main capture controls row */
        .kf-cam-controls-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 32px;
            padding: 16px 24px 28px;
            background: rgba(0,0,0,0.0);
        }
        .kf-cam-capture-btn {
            width: 76px; height: 76px;
            border-radius: 50%;
            background: white;
            border: 5px solid rgba(255,255,255,0.35);
            cursor: pointer;
            transition: transform 0.15s;
            position: relative;
        }
        .kf-cam-capture-btn:active { transform: scale(0.93); }
        /* Inner ring for the shutter button */
        .kf-cam-capture-btn::after {
            content: '';
            position: absolute;
            top: 4px; left: 4px; right: 4px; bottom: 4px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fe2c55 0%, #ff6b35 100%);
            opacity: 0;
            transition: opacity 0.15s;
        }
        .kf-cam-capture-btn:active::after { opacity: 0.3; }

        .kf-cam-side-btn {
            width: 50px; height: 50px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(8px);
            border: 1.5px solid rgba(255,255,255,0.2);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.15s;
        }
        .kf-cam-side-btn:active { transform: scale(0.9); }

        /* Right-side floating tool buttons */
        .kf-cam-right-tools {
            position: absolute;
            top: 60px; right: 10px;
            display: flex; flex-direction: column;
            gap: 10px; z-index: 18;
        }
        .kf-cam-tool-btn {
            width: 44px; height: 44px;
            border-radius: 50%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            border: 1.5px solid rgba(255,255,255,0.2);
            color: white;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column;
            cursor: pointer;
            font-size: 17px;
            gap: 1px;
            transition: all 0.15s;
        }
        .kf-cam-tool-btn span { font-size: 8px; font-weight: 700; line-height: 1; }
        .kf-cam-tool-btn:active { transform: scale(0.88); }
        .kf-cam-tool-btn.active { background: rgba(254,44,85,0.85); border-color: #fe2c55; }

        /* Canvas filter overlay */
        #cameraFilterCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        /* Overlay text elements (draggable) */
        .cam-overlay-text {
            position: absolute;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.8);
            z-index: 12;
            cursor: move;
            user-select: none;
            padding: 6px 10px;
            border: 1.5px dashed rgba(255,255,255,0.5);
            border-radius: 6px;
            touch-action: none;
            pointer-events: auto;
            white-space: nowrap;
            max-width: 90%;
        }
        .cam-overlay-text.selected { border-color: #fe2c55; border-style: solid; }
        .cam-overlay-text .cam-text-del {
            position: absolute;
            top: -12px; right: -12px;
            width: 22px; height: 22px;
            background: #fe2c55;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 10px; cursor: pointer;
            z-index: 20; border: 2px solid white;
            opacity: 0; transition: opacity 0.15s;
        }
        .cam-overlay-text.selected .cam-text-del { opacity: 1; }

        /* Face effect overlay canvas */
        #camFaceCanvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* Flash */
        .kf-camera-flash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 22;
            transition: opacity 0.06s;
        }
        .kf-camera-flash.flash { opacity: 0.95; }

        /* Timer countdown */
        #camTimerCountdown {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%,-50%);
            font-size: 100px;
            font-weight: 900;
            color: white;
            text-shadow: 0 0 40px rgba(0,0,0,0.9), 0 0 80px rgba(254,44,85,0.5);
            z-index: 25;
            display: none;
            line-height: 1;
            animation: countPulse 0.8s ease-out;
        }
        @keyframes countPulse {
            0% { transform: translate(-50%,-50%) scale(1.6); opacity: 0; }
            100% { transform: translate(-50%,-50%) scale(1); opacity: 1; }
        }

        /* Captured preview */
        .kf-captured-image {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            z-index: 30;
        }
        .kf-captured-image.hidden { display: none; }
        .kf-captured-image img {
            flex: 1;
            object-fit: contain;
            background: #000;
            width: 100%;
        }
        .kf-captured-actions {
            display: flex;
            gap: 12px;
            padding: 16px 20px 28px;
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
            justify-content: center;
        }
        .kf-captured-action-btn {
            padding: 13px 28px;
            border: none;
            border-radius: 30px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            display: flex; align-items: center; gap: 8px;
            transition: transform 0.15s;
        }
        .kf-captured-action-btn:active { transform: scale(0.95); }
        .kf-captured-action-btn.retake {
            background: rgba(255,255,255,0.15);
            color: white;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.25);
        }
        .kf-captured-action-btn.keep {
            background: linear-gradient(135deg, #fe2c55, #ff6b35);
            color: white;
        }
        .kf-captured-action-btn.save-device {
            background: rgba(37,244,238,0.2);
            color: #25f4ee;
            border: 1px solid rgba(37,244,238,0.35);
        }

        /* Grid overlay */
        #cameraGrid {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 6; pointer-events: none; display: none; opacity: 0.4;
        }

        /* Shine / sparkle animation for beauty mode */
        @keyframes shimmer {
            0%,100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* Recording Status */
        .kf-recording-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 12px 0;
            padding: 10px 12px;
            background: linear-gradient(90deg, #ffe5e5, #fff0f0);
            border: 1px solid var(--ig-separator);
            border-radius: 12px;
            animation: glowPulse 2s infinite;
        }

        .kf-recording-status.hidden {
            display: none;
        }

        @keyframes glowPulse {
            0%, 100% { background: linear-gradient(90deg, #ffe5e5, #fff0f0); }
            50% { background: linear-gradient(90deg, #ffd6d6, #ffe5e5); }
        }

        .kf-recording-dot {
            width: 8px;
            height: 8px;
            background-color: var(--ig-danger);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .kf-recording-text {
            font-size: 13px;
            font-weight: 500;
            color: var(--ig-danger);
            flex: 1;
        }

        .kf-recording-time {
            font-size: 12px;
            color: var(--ig-text);
            font-family: monospace;
        }

        /* Video/Audio Players */
        .kf-video-player, .kf-audio-player {
            margin: 12px 0;
            padding: 12px;
            background-color: var(--ig-input-bg);
            border: 1px solid var(--ig-separator);
            border-radius: 12px;
            display: none;
        }

        .kf-video-player.active, .kf-audio-player.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        .kf-video-player-header, .kf-audio-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .kf-video-player-title, .kf-audio-player-title {
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .kf-video-player-close, .kf-audio-player-close {
            background: none;
            border: none;
            font-size: 18px;
            color: var(--ig-text);
            cursor: pointer;
        }

        .kf-video-element {
            width: 100%;
            border-radius: 8px;
            background-color: #000;
            aspect-ratio: 16/9;
        }

        .kf-video-actions, .kf-audio-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .kf-video-action-btn, .kf-audio-action-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .kf-video-keep, .kf-audio-keep {
            background-color: var(--ig-primary);
            color: white;
        }

        /* Audio Player */
        .kf-custom-audio-player {
            width: 100%;
        }

        .kf-audio-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .kf-audio-play-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--ig-primary);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kf-audio-play-btn.playing {
            background: linear-gradient(135deg, var(--ig-primary), #00b8ff);
        }

        .kf-audio-info {
            flex: 1;
        }

        .kf-audio-filename {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .kf-audio-time {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--ig-text-light);
            font-family: monospace;
        }

        .kf-audio-progress {
            width: 100%;
            height: 3px;
            background-color: var(--ig-separator);
            border-radius: 2px;
            overflow: hidden;
            cursor: pointer;
            margin: 4px 0;
        }

        .kf-audio-progress-filled {
            height: 100%;
            background: linear-gradient(90deg, var(--ig-primary), #00b8ff);
            width: 0%;
            transition: width 0.1s linear;
        }

        /* Preview Box */
        .kf-preview-container {
            margin-top: 12px;
        }

        .kf-preview-box {
            border: 1px solid var(--ig-separator);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .kf-preview-box.has-content {
            border-color: var(--ig-primary);
            background: linear-gradient(145deg, var(--ig-input-bg), white);
        }

        .kf-preview-icon {
            font-size: 24px;
            color: var(--ig-text-light);
            margin-bottom: 4px;
        }

        .kf-preview-text {
            color: var(--ig-text-light);
            font-size: 13px;
        }

        .kf-preview-item {
            margin-top: 4px;
            font-size: 13px;
            color: var(--ig-primary);
            font-weight: 600;
        }

        .kf-file-size-info {
            font-size: 11px;
            color: var(--ig-text-light);
            margin-top: 4px;
        }

        /* ===== MEDIA EDITOR MODAL ===== */
        /* ===================== TIKTOK EDITOR - Full Upgrade ===================== */
        @import url('https://fonts.googleapis.com/css2?family=Pacifico&family=Permanent+Marker&family=Bangers&family=Press+Start+2P&family=Dancing+Script:wght@700&family=Righteous&display=swap');

        .kf-media-editor-modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #0a0a0a;
            z-index: 2000;
            flex-direction: column;
        }
        .kf-media-editor-modal.active { display: flex; }

        /* Top bar */
        .kf-editor-header {
            padding: 10px 14px;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        .kf-editor-title {
            font-size: 15px; font-weight: 700;
            display: flex; align-items: center; gap: 8px;
            background: linear-gradient(90deg, #fe2c55, #25f4ee);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .kf-editor-close {
            background: rgba(255,255,255,0.1); border: none; color: white;
            font-size: 18px; cursor: pointer; width: 36px; height: 36px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%; transition: background 0.2s;
        }
        .kf-editor-close:hover { background: rgba(255,255,255,0.2); }
        .kf-editor-apply-btn {
            background: linear-gradient(135deg, #fe2c55, #ff6b35);
            border: none; color: white; padding: 8px 18px;
            border-radius: 20px; font-size: 13px; font-weight: 700;
            cursor: pointer; transition: transform 0.15s;
        }
        .kf-editor-apply-btn:active { transform: scale(0.96); }

        /* Canvas wrapper */
        .kf-editor-content {
            flex: 1; display: flex; flex-direction: column;
            min-height: 0; background: #0a0a0a; position: relative;
        }
        .kf-editor-canvas-container {
            flex: 1; min-height: 0;
            display: flex; align-items: center; justify-content: center;
            position: relative; background: #0a0a0a; overflow: hidden;
        }
        .kf-editor-canvas {
            max-width: 100%; max-height: 100%;
            object-fit: contain; display: block;
            position: relative; z-index: 1;
        }
        .kf-editor-canvas.draw-mode { cursor: crosshair; }

        /* Right side quick-tools (TikTok style vertical bar) */
        .kf-editor-side-tools {
            position: absolute; right: 8px; top: 50%;
            transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 12px;
            z-index: 50;
        }
        .kf-side-tool-btn {
            width: 44px; height: 44px;
            background: rgba(0,0,0,0.55);
            backdrop-filter: blur(8px);
            border: 1.5px solid rgba(255,255,255,0.18);
            border-radius: 50%; color: white;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; cursor: pointer;
            font-size: 18px; gap: 1px;
            transition: background 0.2s, transform 0.15s;
        }
        .kf-side-tool-btn:active { transform: scale(0.92); background: rgba(254,44,85,0.7); }
        .kf-side-tool-btn span { font-size: 9px; font-weight: 600; line-height: 1; }
        .kf-side-tool-btn.active-tool { background: rgba(254,44,85,0.8); border-color: #fe2c55; }

        /* Overlay Elements - draggable */
        .kf-editor-overlay-text {
            position: absolute;
            color: white; font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            z-index: 10; cursor: move; user-select: none;
            padding: 6px 10px;
            border: 1.5px dashed rgba(255,255,255,0.4);
            border-radius: 6px;
            font-size: 28px;
            transform: translate(-50%, -50%);
            touch-action: none; pointer-events: auto;
            transition: border-color 0.15s;
            white-space: nowrap;
        }
        .kf-editor-overlay-text.no-bg { background: transparent; }
        .kf-editor-overlay-text.bg-dark { background: rgba(0,0,0,0.6); padding: 6px 10px; border-radius: 6px; }
        .kf-editor-overlay-text.bg-light { background: rgba(255,255,255,0.85); color: #000; padding: 6px 10px; border-radius: 6px; }
        .kf-editor-overlay-text.bg-color { padding: 6px 10px; border-radius: 6px; }
        .kf-editor-overlay-text.dragging { opacity: 0.8; border-color: #fe2c55; cursor: grabbing; }
        .kf-editor-overlay-text.selected { border-color: #25f4ee; border-style: solid; }
        .kf-editor-overlay-text.no-border { border-color: transparent !important; }

        /* Pinch-to-resize handles */
        .kf-overlay-delete {
            position: absolute; top: -12px; right: -12px;
            width: 22px; height: 22px;
            background: #fe2c55; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 10px; cursor: pointer;
            z-index: 20; border: 2px solid white;
            opacity: 0; transition: opacity 0.2s;
        }
        .kf-editor-overlay-text.selected .kf-overlay-delete { opacity: 1; }
        .kf-overlay-resize {
            position: absolute; bottom: -10px; right: -10px;
            width: 20px; height: 20px;
            background: #25f4ee; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: #000; font-size: 9px; cursor: se-resize;
            z-index: 20; border: 2px solid white;
            opacity: 0; transition: opacity 0.2s;
        }
        .kf-editor-overlay-text.selected .kf-overlay-resize { opacity: 1; }

        /* Face filters overlay canvas */
        #faceFilterCanvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; z-index: 5;
        }

        /* Bottom tab toolbar */
        .kf-editor-tabs {
            background: rgba(10,10,10,0.95);
            border-top: 1px solid rgba(255,255,255,0.08);
            display: flex; overflow-x: auto; flex-shrink: 0;
            scrollbar-width: none; gap: 0;
        }
        .kf-editor-tabs::-webkit-scrollbar { display: none; }
        .kf-editor-tab {
            flex-shrink: 0; min-width: 70px;
            padding: 8px 6px; display: flex;
            flex-direction: column; align-items: center; gap: 3px;
            cursor: pointer; color: rgba(255,255,255,0.5);
            font-size: 10px; font-weight: 600;
            border-bottom: 2px solid transparent;
            transition: all 0.2s; text-align: center;
        }
        .kf-editor-tab i { font-size: 18px; }
        .kf-editor-tab.active { color: #fe2c55; border-bottom-color: #fe2c55; }
        .kf-editor-tab:hover { color: white; }

        /* Panel container */
        .kf-editor-panel-wrap {
            background: rgba(10,10,10,0.98);
            border-top: 1px solid rgba(255,255,255,0.06);
            flex-shrink: 0; overflow: hidden;
            transition: max-height 0.25s ease;
        }
        .kf-editor-panel {
            display: none; padding: 10px 12px;
            min-height: 80px; max-height: 160px;
            overflow-y: auto; overflow-x: auto;
        }
        .kf-editor-panel.active { display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-start; }
        .kf-editor-panel::-webkit-scrollbar { height: 3px; width: 3px; }
        .kf-editor-panel::-webkit-scrollbar-thumb { background: #333; }

        /* Filter thumbnails */
        .kf-filter-scroll { display: flex; gap: 10px; overflow-x: auto; width: 100%; }
        .kf-filter-scroll::-webkit-scrollbar { display: none; }
        .kf-filter-option {
            display: flex; flex-direction: column; align-items: center;
            gap: 5px; cursor: pointer; flex-shrink: 0;
        }
        .kf-filter-preview {
            width: 58px; height: 58px; border-radius: 10px; overflow: hidden;
            border: 2.5px solid transparent; transition: border-color 0.2s, transform 0.2s;
            position: relative;
        }
        .kf-filter-preview img { width: 100%; height: 100%; object-fit: cover; }
        .kf-filter-option:active .kf-filter-preview { transform: scale(0.95); }
        .kf-filter-option.active .kf-filter-preview { border-color: #fe2c55; }
        .kf-filter-name { font-size: 10px; color: rgba(255,255,255,0.8); font-weight: 600; }

        /* Adjust sliders */
        .kf-adjust-row {
            display: flex; align-items: center; gap: 8px;
            width: 100%; padding: 3px 0;
        }
        .kf-adjust-label { color: rgba(255,255,255,0.6); font-size: 11px; width: 80px; flex-shrink: 0; }
        .kf-adjust-slider {
            flex: 1; -webkit-appearance: none; height: 3px;
            background: #333; border-radius: 2px; outline: none;
        }
        .kf-adjust-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            border-radius: 50%; background: #fe2c55; cursor: pointer;
            border: 2px solid white;
        }
        .kf-adjust-val { color: white; font-size: 11px; width: 28px; text-align: right; }

        /* Text panel */
        .kf-text-toolbar { display: flex; gap: 6px; width: 100%; flex-direction: column; }
        .kf-text-row { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
        .kf-font-chip {
            padding: 5px 10px; border-radius: 14px;
            background: #222; border: 1.5px solid #333;
            color: white; cursor: pointer; font-size: 12px;
            transition: all 0.15s; white-space: nowrap;
        }
        .kf-font-chip.active { background: #fe2c55; border-color: #fe2c55; }
        .kf-color-dot {
            width: 26px; height: 26px; border-radius: 50%;
            border: 2.5px solid rgba(255,255,255,0.3); cursor: pointer;
            transition: transform 0.15s, border-color 0.15s;
            flex-shrink: 0;
        }
        .kf-color-dot.active { border-color: white; transform: scale(1.15); }
        .kf-color-dot:active { transform: scale(0.9); }
        .kf-text-style-btn {
            padding: 5px 10px; border-radius: 12px; border: 1.5px solid #333;
            background: #222; color: white; cursor: pointer; font-size: 11px;
            font-weight: 600; transition: all 0.15s;
        }
        .kf-text-style-btn.active { background: #25f4ee; color: #000; border-color: #25f4ee; }

        /* Sticker/emoji panel */
        .kf-sticker-grid {
            display: grid; grid-template-columns: repeat(6, 1fr);
            gap: 6px; width: 100%;
        }
        .kf-sticker-btn {
            font-size: 28px; text-align: center; cursor: pointer;
            padding: 4px; border-radius: 8px;
            transition: background 0.15s, transform 0.15s;
            background: rgba(255,255,255,0.05);
            border: none;
        }
        .kf-sticker-btn:active { background: rgba(254,44,85,0.3); transform: scale(0.9); }

        /* Face filters panel */
        .kf-face-filter-scroll { display: flex; gap: 10px; overflow-x: auto; width: 100%; }
        .kf-face-filter-scroll::-webkit-scrollbar { display: none; }
        .kf-face-filter-btn {
            display: flex; flex-direction: column; align-items: center;
            gap: 5px; cursor: pointer; flex-shrink: 0;
        }
        .kf-face-filter-preview {
            width: 58px; height: 58px; border-radius: 50%;
            border: 2.5px solid transparent; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
            font-size: 30px; background: #1a1a1a;
            transition: border-color 0.2s, transform 0.15s;
        }
        .kf-face-filter-btn.active .kf-face-filter-preview { border-color: #fe2c55; }
        .kf-face-filter-name { font-size: 10px; color: rgba(255,255,255,0.7); font-weight: 600; }

        /* Overlay image panel */
        .kf-overlay-img-grid {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 8px; width: 100%;
        }
        .kf-overlay-img-btn {
            aspect-ratio: 1; border-radius: 8px; overflow: hidden;
            background: #1a1a1a; border: 1.5px solid #333;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 22px; transition: all 0.15s;
        }
        .kf-overlay-img-btn:active { border-color: #fe2c55; transform: scale(0.95); }
        .kf-upload-overlay-btn {
            background: rgba(254,44,85,0.15); border-color: rgba(254,44,85,0.4);
            color: #fe2c55; font-size: 20px; font-weight: 700;
        }

        /* Sound panel */
        .kf-sound-panel { display: flex; flex-direction: column; gap: 8px; width: 100%; }
        .kf-sound-row { display: flex; align-items: center; gap: 10px; }
        .kf-sound-track {
            flex: 1; display: flex; align-items: center; gap: 8px;
            padding: 8px 12px; background: #1a1a1a; border-radius: 10px;
            cursor: pointer; border: 1.5px solid #333; transition: border-color 0.2s;
        }
        .kf-sound-track.active { border-color: #25f4ee; background: rgba(37,244,238,0.1); }
        .kf-sound-track-icon { font-size: 20px; flex-shrink: 0; }
        .kf-sound-track-info { flex: 1; min-width: 0; }
        .kf-sound-track-name { font-size: 12px; color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .kf-sound-track-dur { font-size: 10px; color: rgba(255,255,255,0.4); }
        .kf-sound-vol-row { display: flex; align-items: center; gap: 8px; }
        .kf-sound-vol-label { font-size: 11px; color: rgba(255,255,255,0.5); width: 60px; }

        /* Draw panel */
        .kf-draw-tools { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; width: 100%; }
        .kf-brush-btn {
            padding: 5px 10px; border-radius: 12px; border: 1.5px solid #333;
            background: #222; color: white; cursor: pointer; font-size: 11px;
            font-weight: 600; transition: all 0.15s;
        }
        .kf-brush-btn.active { background: #fe2c55; border-color: #fe2c55; }
        .kf-size-slider {
            -webkit-appearance: none; height: 3px;
            background: #333; border-radius: 2px; outline: none; width: 80px;
        }
        .kf-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px;
            border-radius: 50%; background: #fe2c55; cursor: pointer;
        }
        .kf-draw-color-row { display: flex; gap: 5px; flex-wrap: wrap; }

        /* Text input overlay */
        .kf-editor-text-input {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            width: 88%; max-width: 380px;
            padding: 13px 18px; border: none; border-radius: 16px;
            font-size: 16px; outline: none; z-index: 2100;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            background: rgba(30,30,30,0.95); color: white;
            backdrop-filter: blur(12px);
        }
        .kf-editor-text-input::placeholder { color: rgba(255,255,255,0.35); }
        .kf-editor-text-input.hidden { display: none; }

        /* Bottom footer */
        .kf-editor-footer {
            padding: 8px 14px; background: rgba(0,0,0,0.9);
            border-top: 1px solid rgba(255,255,255,0.06);
            display: flex; justify-content: space-between; align-items: center;
            flex-shrink: 0; gap: 10px;
        }
        .kf-editor-btn {
            padding: 8px 20px; border-radius: 20px;
            font-size: 13px; font-weight: 700; cursor: pointer; border: none;
            transition: transform 0.15s;
        }
        .kf-editor-btn:active { transform: scale(0.95); }
        .kf-editor-btn-primary {
            background: linear-gradient(135deg, #fe2c55, #ff6b35);
            color: white; flex: 1;
        }
        .kf-editor-btn-secondary {
            background: rgba(255,255,255,0.08); color: white;
            border: 1px solid rgba(255,255,255,0.15);
        }

        /* Color picker */
        .kf-color-picker { display: none; }
        .kf-color-input-wrap {
            width: 26px; height: 26px; border-radius: 50%;
            border: 2.5px solid white; overflow: hidden; cursor: pointer;
            flex-shrink: 0; background: conic-gradient(red, yellow, lime, cyan, blue, magenta, red);
        }
        .kf-color-input-wrap input[type=color] {
            width: 200%; height: 200%; margin: -50%; opacity: 0; cursor: pointer;
        }

        /* Video Recorder Modal */
        .kf-video-recorder-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1000;
            flex-direction: column;
        }

        .kf-video-recorder-modal.active {
            display: flex;
        }

        .kf-video-recorder-header {
            padding: 16px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: absolute;
            top: 0;
            width: 100%;
            z-index: 10;
        }

        .kf-video-recorder-timer {
            font-size: 14px;
            font-weight: 500;
            background: rgba(0,0,0,0.6);
            padding: 4px 12px;
            border-radius: 20px;
            font-family: monospace;
        }

        .kf-video-recorder-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kf-video-preview {
            width: 100%;
            height: 100%;
            background: #000;
            position: relative;
        }

        .kf-video-live {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .kf-video-recording-indicator {
            position: absolute;
            top: 70px;
            right: 20px;
            background: var(--ig-danger);
            padding: 4px 12px;
            border-radius: 20px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .kf-video-recording-indicator.hidden {
            display: none;
        }

        .kf-recording-dot-large {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulseLarge 1s infinite;
        }

        @keyframes pulseLarge {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.3); }
        }

        .kf-video-watermark {
            position: absolute;
            bottom: 120px;
            left: 20px;
            color: white;
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(0,0,0,0.9);
            z-index: 5;
        }

        .kf-watermark-brand {
            font-size: 16px;
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .kf-watermark-username {
            font-size: 12px;
            font-weight: 600;
            opacity: 0.95;
        }

        .kf-video-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            padding: 30px 20px 20px;
        }

        .kf-video-main-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
        }

        .kf-video-record-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: white;
            border: 5px solid rgba(255,255,255,0.3);
            cursor: pointer;
        }

        .kf-video-record-btn.recording {
            background: var(--ig-danger);
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: none;
        }

        .kf-video-control-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .kf-sound-select-btn {
            background: rgba(255,255,255,0.15);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(4px);
        }

        /* Loading Overlay */
        .kf-loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .kf-loading-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .kf-loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 16px;
        }

        .kf-loading-text {
            font-size: 16px;
            font-weight: 600;
            color: white;
            margin-bottom: 4px;
        }

        .kf-loading-subtext {
            font-size: 13px;
            color: rgba(255,255,255,0.9);
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Custom Alert Modal */
        .kf-alert-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 4000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .kf-alert-modal.active {
            display: flex;
        }

        .kf-alert-content {
            background: white;
            border-radius: 20px;
            padding: 24px;
            max-width: 320px;
            width: 100%;
            text-align: center;
            animation: alertPop 0.3s ease;
        }

        @keyframes alertPop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .kf-alert-emoji {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .kf-alert-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--ig-text);
            margin-bottom: 8px;
        }

        .kf-alert-message {
            font-size: 14px;
            color: var(--ig-text-light);
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .kf-alert-buttons {
            display: flex;
            gap: 12px;
        }

        .kf-alert-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .kf-alert-btn.primary {
            background: var(--ig-primary);
            color: white;
        }

        .kf-alert-btn.primary:hover {
            opacity: 0.9;
        }

        .kf-alert-btn.secondary {
            background: var(--ig-separator);
            color: var(--ig-text);
        }

        .kf-alert-btn.secondary:hover {
            background: var(--ig-text-light);
            color: white;
        }

        .kf-alert-btn.danger {
            background: var(--ig-danger);
            color: white;
        }

        .hidden {
            display: none !important;
        }

        input[type="file"] {
            display: none;
        }

        /* ===== IMAGE-TO-VIDEO EXPORT MODAL ===== */
        .kf-vid-export-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            z-index: 3500;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }
        .kf-vid-export-modal.active { display: flex; }
        .kf-vid-export-card {
            background: #111;
            border-radius: 20px;
            padding: 28px 24px;
            width: 100%;
            max-width: 380px;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: 0 24px 60px rgba(0,0,0,0.7);
        }
        .kf-vid-export-title {
            font-size: 18px;
            font-weight: 800;
            background: linear-gradient(90deg, #fe2c55, #25f4ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 6px;
        }
        .kf-vid-export-sub {
            font-size: 12px;
            color: rgba(255,255,255,0.4);
            margin-bottom: 20px;
        }
        .kf-vid-export-progress-wrap {
            background: rgba(255,255,255,0.08);
            border-radius: 99px;
            height: 8px;
            overflow: hidden;
            margin: 12px 0 6px;
        }
        .kf-vid-export-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #fe2c55, #25f4ee);
            border-radius: 99px;
            width: 0%;
            transition: width 0.3s ease;
        }
        .kf-vid-export-status {
            font-size: 12px;
            color: rgba(255,255,255,0.5);
            text-align: center;
            margin-bottom: 16px;
        }
        .kf-vid-export-btns {
            display: flex;
            gap: 10px;
            margin-top: 16px;
        }
        .kf-vid-export-btn {
            flex: 1;
            padding: 12px;
            border-radius: 14px;
            border: none;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: opacity 0.15s, transform 0.15s;
        }
        .kf-vid-export-btn:active { transform: scale(0.96); }
        .kf-vid-export-btn.primary {
            background: linear-gradient(135deg, #fe2c55, #ff6b35);
            color: white;
        }
        .kf-vid-export-btn.secondary {
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.8);
            border: 1px solid rgba(255,255,255,0.15);
        }
        .kf-vid-export-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .kf-vid-export-preview video {
            width: 100%;
            border-radius: 12px;
            margin-top: 14px;
            background: #000;
        }

        /* ===== SLIDESHOW BUILDER MODAL (CapCut-style) ===== */
        .kf-slideshow-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: #0a0a0a;
            z-index: 2500;
            flex-direction: column;
        }
        .kf-slideshow-modal.active { display: flex; }

        /* Slideshow header */
        .kf-ss-header {
            padding: 14px 16px;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.07);
            flex-shrink: 0;
        }
        .kf-ss-title {
            font-size: 16px;
            font-weight: 800;
            background: linear-gradient(90deg, #fe2c55, #ff6b35, #25f4ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .kf-ss-export-btn {
            background: linear-gradient(135deg, #fe2c55, #ff6b35);
            border: none;
            color: white;
            padding: 9px 20px;
            border-radius: 22px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 7px;
            transition: opacity 0.15s, transform 0.12s;
        }
        .kf-ss-export-btn:active { transform: scale(0.95); }
        .kf-ss-close-btn {
            background: rgba(255,255,255,0.08);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Preview canvas */
        .kf-ss-preview-area {
            flex: 1;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
        }
        #ssPreviewCanvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 4px;
        }
        .kf-ss-play-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        .kf-ss-play-btn-big {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: rgba(255,255,255,0.18);
            backdrop-filter: blur(6px);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 26px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s, background 0.15s;
            pointer-events: auto;
        }
        .kf-ss-play-btn-big:active { transform: scale(0.9); }

        /* Settings panel */
        .kf-ss-settings {
            background: rgba(10,10,10,0.98);
            border-top: 1px solid rgba(255,255,255,0.07);
            padding: 12px 16px;
            flex-shrink: 0;
        }
        .kf-ss-settings-row {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            scrollbar-width: none;
            margin-bottom: 10px;
        }
        .kf-ss-settings-row::-webkit-scrollbar { display: none; }

        /* Transition picker */
        .kf-ss-transition-btn {
            flex-shrink: 0;
            padding: 7px 14px;
            border-radius: 20px;
            background: rgba(255,255,255,0.08);
            border: 1.5px solid rgba(255,255,255,0.12);
            color: rgba(255,255,255,0.7);
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }
        .kf-ss-transition-btn.active {
            background: rgba(254,44,85,0.85);
            border-color: #fe2c55;
            color: white;
        }

        /* Duration slider row */
        .kf-ss-dur-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .kf-ss-dur-label {
            font-size: 11px;
            color: rgba(255,255,255,0.5);
            width: 80px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .kf-ss-dur-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 3px;
            border-radius: 2px;
            background: rgba(255,255,255,0.2);
            outline: none;
            cursor: pointer;
        }
        .kf-ss-dur-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px; height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fe2c55, #ff6b35);
            cursor: pointer;
            border: 2px solid white;
        }
        .kf-ss-dur-val {
            font-size: 12px;
            color: #fe2c55;
            font-weight: 700;
            width: 36px;
            font-family: monospace;
        }

        /* Sound row in slideshow */
        .kf-ss-sound-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 0;
            border-top: 1px solid rgba(255,255,255,0.06);
        }
        .kf-ss-sound-btn {
            flex-shrink: 0;
            padding: 8px 16px;
            border-radius: 20px;
            border: 1.5px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.07);
            color: white;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .kf-ss-sound-btn.has-sound {
            border-color: #25f4ee;
            background: rgba(37,244,238,0.1);
            color: #25f4ee;
        }
        .kf-ss-sound-name {
            flex: 1;
            font-size: 11px;
            color: rgba(255,255,255,0.4);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Timeline strip */
        .kf-ss-timeline {
            background: rgba(5,5,5,0.99);
            border-top: 1px solid rgba(255,255,255,0.07);
            padding: 10px 16px 14px;
            flex-shrink: 0;
        }
        .kf-ss-timeline-label {
            font-size: 10px;
            color: rgba(255,255,255,0.3);
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .kf-ss-timeline-strip {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 6px;
            scrollbar-width: thin;
            scrollbar-color: rgba(254,44,85,0.4) transparent;
            align-items: flex-end;
        }
        .kf-ss-timeline-strip::-webkit-scrollbar { height: 3px; }
        .kf-ss-timeline-strip::-webkit-scrollbar-thumb { background: rgba(254,44,85,0.4); border-radius: 2px; }

        /* Add clip button */
        .kf-ss-add-clip {
            flex-shrink: 0;
            width: 68px;
            height: 68px;
            border-radius: 12px;
            border: 2px dashed rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.04);
            color: rgba(255,255,255,0.4);
            font-size: 26px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .kf-ss-add-clip:hover { border-color: #fe2c55; color: #fe2c55; background: rgba(254,44,85,0.08); }

        /* Timeline clip item */
        .kf-ss-clip {
            flex-shrink: 0;
            position: relative;
            width: 68px;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            border: 2.5px solid transparent;
            transition: border-color 0.15s, transform 0.15s;
            background: #222;
        }
        .kf-ss-clip.active { border-color: #fe2c55; transform: scale(1.06); }
        .kf-ss-clip img {
            width: 68px;
            height: 68px;
            object-fit: cover;
            display: block;
        }
        .kf-ss-clip-dur {
            position: absolute;
            bottom: 2px;
            left: 0; right: 0;
            text-align: center;
            font-size: 9px;
            font-weight: 700;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 2px 0;
        }
        .kf-ss-clip-del {
            position: absolute;
            top: -1px; right: -1px;
            width: 20px; height: 20px;
            background: #fe2c55;
            border-radius: 0 10px 0 8px;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 9px;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .kf-ss-clip:hover .kf-ss-clip-del { opacity: 1; }
        .kf-ss-clip-idx {
            position: absolute;
            top: 2px; left: 4px;
            font-size: 9px;
            font-weight: 900;
            color: white;
            text-shadow: 0 1px 3px rgba(0,0,0,0.9);
        }

        /* Transition connector between clips */
        .kf-ss-transition-connector {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            width: 30px;
            align-self: center;
            cursor: pointer;
        }
        .kf-ss-tc-icon {
            width: 28px; height: 28px;
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            display: flex; align-items: center; justify-content: center;
            font-size: 12px;
            transition: all 0.15s;
        }
        .kf-ss-tc-icon:hover { background: rgba(254,44,85,0.4); border-color: #fe2c55; }
        .kf-ss-tc-label {
            font-size: 8px;
            color: rgba(255,255,255,0.3);
            font-weight: 700;
            letter-spacing: 0.3px;
            white-space: nowrap;
        }

        /* Video export progress overlay */
        .kf-ss-exporting {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.88);
            backdrop-filter: blur(8px);
            z-index: 10;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
        }
        .kf-ss-exporting.show { display: flex; }
        .kf-ss-exp-title {
            font-size: 20px;
            font-weight: 800;
            color: white;
        }
        .kf-ss-exp-sub {
            font-size: 13px;
            color: rgba(255,255,255,0.5);
        }
        .kf-ss-exp-bar-wrap {
            width: 260px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 99px;
            overflow: hidden;
        }
        .kf-ss-exp-bar {
            height: 100%;
            background: linear-gradient(90deg, #fe2c55, #25f4ee);
            width: 0%;
            border-radius: 99px;
            transition: width 0.2s linear;
        }
        .kf-ss-exp-pct {
            font-size: 28px;
            font-weight: 900;
            color: white;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="kf-loading-overlay" id="loadingOverlay">
        <div class="kf-loading-spinner"></div>
        <div class="kf-loading-text" id="loadingText">slaying your post... âœ¨</div>
        <div class="kf-loading-subtext" id="loadingSubtext">making it aesthetic</div>
    </div>

    <!-- Custom Alert Modal -->
    <div class="kf-alert-modal" id="alertModal">
        <div class="kf-alert-content">
            <div class="kf-alert-emoji" id="alertEmoji">âœ¨</div>
            <div class="kf-alert-title" id="alertTitle">bestie alert</div>
            <div class="kf-alert-message" id="alertMessage">this is a custom alert</div>
            <div class="kf-alert-buttons" id="alertButtons">
                <button class="kf-alert-btn primary" onclick="closeAlert()">ok</button>
            </div>
        </div>
    </div>

    <!-- Camera Modal â€” Full Real-Time Editor -->
    <div id="cameraModal" class="kf-camera-modal">

        <!-- Header -->
        <div class="kf-camera-header" style="position:absolute;top:0;left:0;right:0;z-index:20;background:linear-gradient(to bottom,rgba(0,0,0,0.7),transparent);padding:14px 16px;display:flex;justify-content:space-between;align-items:center;">
            <button onclick="closeCamera()" style="background:none;border:none;color:white;font-size:22px;cursor:pointer;width:36px;height:36px;display:flex;align-items:center;justify-content:center;">
                <i class="fas fa-times"></i>
            </button>
            <div style="font-size:15px;font-weight:700;color:white;display:flex;align-items:center;gap:6px;">
                <i class="fas fa-camera"></i> snap âœ¨
            </div>
            <button id="camResetBtn" onclick="resetCameraEdits()" style="background:none;border:none;color:rgba(255,255,255,0.7);font-size:11px;font-weight:700;cursor:pointer;letter-spacing:0.8px;padding:6px 10px;border-radius:14px;border:1px solid rgba(255,255,255,0.2);">RESET</button>
        </div>

        <!-- Preview area -->
        <div id="camPreviewArea" style="position:relative;flex:1;overflow:hidden;background:#000;">
            <video id="cameraLive" autoplay playsinline style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:1;visibility:hidden;"></video>
            <canvas id="cameraFilterCanvas"></canvas>
            <canvas id="camFaceCanvas"></canvas>
            <svg id="cameraGrid">
                <line x1="33.33%" y1="0" x2="33.33%" y2="100%" stroke="white" stroke-width="0.8"/>
                <line x1="66.66%" y1="0" x2="66.66%" y2="100%" stroke="white" stroke-width="0.8"/>
                <line x1="0" y1="33.33%" x2="100%" y2="33.33%" stroke="white" stroke-width="0.8"/>
                <line x1="0" y1="66.66%" x2="100%" y2="66.66%" stroke="white" stroke-width="0.8"/>
            </svg>
            <div id="cameraFlash" class="kf-camera-flash"></div>
            <div id="camTimerCountdown"></div>
            <div id="camTextLayer" style="position:absolute;top:0;left:0;width:100%;height:100%;z-index:12;pointer-events:none;"></div>

            <!-- Right-side tool buttons -->
            <div class="kf-cam-right-tools">
                <button class="kf-cam-tool-btn" id="camTimerBtn" onclick="toggleCameraTimer()" title="Timer">
                    <i class="fas fa-clock"></i>
                    <span id="camTimerLabel">OFF</span>
                </button>
                <button class="kf-cam-tool-btn" id="camGridBtn" onclick="toggleCameraGrid()" title="Grid">
                    <i class="fas fa-th"></i>
                    <span>GRID</span>
                </button>
                <button class="kf-cam-tool-btn" id="camBeautyBtn" onclick="toggleCameraBeauty()" title="Beauty">
                    <i class="fas fa-star"></i>
                    <span>GLOW</span>
                </button>
                <button class="kf-cam-tool-btn" id="camMirrorBtn" onclick="toggleCameraMirror()" title="Mirror">
                    <i class="fas fa-arrows-alt-h"></i>
                    <span>FLIP</span>
                </button>
            </div>

            <!-- Captured image preview -->
            <div id="capturedImageContainer" class="kf-captured-image hidden">
                <img id="capturedImage" src="" alt="Captured">
                <div class="kf-captured-actions">
                    <button class="kf-captured-action-btn retake" onclick="retakePhoto()">
                        <i class="fas fa-redo"></i> Retake
                    </button>
                    <button class="kf-captured-action-btn save-device" onclick="savePhotoToDevice()">
                        <i class="fas fa-download"></i> Save
                    </button>
                    <button class="kf-captured-action-btn keep" onclick="keepPhoto()">
                        <i class="fas fa-check"></i> Use
                    </button>
                </div>
            </div>
        </div>

        <!-- Bottom panel -->
        <div class="kf-cam-bottom-panel" style="position:relative;z-index:20;background:rgba(0,0,0,0.92);">

            <!-- FILTERS panel -->
            <div id="camPanelFilters" class="kf-cam-sub-panel show">
                <div class="kf-cam-filter-row" id="cameraFiltersRow"></div>
            </div>

            <!-- ADJUST panel -->
            <div id="camPanelAdjust" class="kf-cam-sub-panel">
                <div class="kf-cam-adjustments-panel">
                    <div class="kf-cam-slider-row"><span class="kf-cam-slider-label">Bright</span><input type="range" class="kf-cam-slider" id="camBrightness" min="0" max="200" value="100" oninput="updateCameraFilter()"><span class="kf-cam-slider-value" id="camBrightnessVal">0</span></div>
                    <div class="kf-cam-slider-row"><span class="kf-cam-slider-label">Contrast</span><input type="range" class="kf-cam-slider" id="camContrast" min="0" max="200" value="100" oninput="updateCameraFilter()"><span class="kf-cam-slider-value" id="camContrastVal">0</span></div>
                    <div class="kf-cam-slider-row"><span class="kf-cam-slider-label">Saturate</span><input type="range" class="kf-cam-slider" id="camSaturation" min="0" max="300" value="100" oninput="updateCameraFilter()"><span class="kf-cam-slider-value" id="camSaturationVal">0</span></div>
                    <div class="kf-cam-slider-row"><span class="kf-cam-slider-label">Warmth</span><input type="range" class="kf-cam-slider" id="camWarmth" min="-50" max="50" value="0" oninput="updateCameraFilter()"><span class="kf-cam-slider-value" id="camWarmthVal">0</span></div>
                    <div class="kf-cam-slider-row"><span class="kf-cam-slider-label">Fade</span><input type="range" class="kf-cam-slider" id="camFade" min="0" max="80" value="0" oninput="updateCameraFilter()"><span class="kf-cam-slider-value" id="camFadeVal">0</span></div>
                    <div class="kf-cam-slider-row"><span class="kf-cam-slider-label">Blur</span><input type="range" class="kf-cam-slider" id="camBlur" min="0" max="10" value="0" step="0.5" oninput="updateCameraFilter()"><span class="kf-cam-slider-value" id="camBlurVal">0</span></div>
                    <div class="kf-cam-slider-row"><span class="kf-cam-slider-label">Vignette</span><input type="range" class="kf-cam-slider" id="camVignette" min="0" max="100" value="0" oninput="updateCameraFilter()"><span class="kf-cam-slider-value" id="camVignetteVal">0</span></div>
                    <div class="kf-cam-slider-row"><span class="kf-cam-slider-label">Hue</span><input type="range" class="kf-cam-slider" id="camHue" min="0" max="360" value="0" oninput="updateCameraFilter()"><span class="kf-cam-slider-value" id="camHueVal">0</span></div>
                </div>
            </div>

            <!-- FACE panel -->
            <div id="camPanelFace" class="kf-cam-sub-panel">
                <div class="kf-cam-face-panel">
                    <div class="kf-cam-face-row" id="camFaceRow"></div>
                </div>
            </div>

            <!-- TEXT panel -->
            <div id="camPanelText" class="kf-cam-sub-panel">
                <div class="kf-cam-text-panel">
                    <div class="kf-cam-text-input-row">
                        <input type="text" id="camTextInput" class="kf-cam-text-input" placeholder="âœï¸ type something slay..." maxlength="60">
                        <button class="kf-cam-text-add-btn" onclick="addCameraText()">ADD âœ¨</button>
                    </div>
                    <div class="kf-cam-font-row" id="camFontRow"></div>
                    <div class="kf-cam-color-row" id="camColorRow"></div>
                    <div class="kf-cam-textsize-row">
                        <span class="kf-cam-textsize-label">SIZE</span>
                        <input type="range" class="kf-cam-slider" id="camTextSize" min="16" max="64" value="28" oninput="updateCamTextPreview()">
                        <span class="kf-cam-slider-value" id="camTextSizeVal">28px</span>
                    </div>
                </div>
            </div>

            <!-- STICKERS panel -->
            <div id="camPanelStickers" class="kf-cam-sub-panel">
                <div class="kf-cam-sticker-panel">
                    <div class="kf-cam-sticker-cats" id="camStickerCats"></div>
                    <div class="kf-cam-sticker-grid" id="camStickerGrid"></div>
                </div>
            </div>

            <!-- Mode tabs -->
            <div class="kf-cam-mode-bar" id="camModeBar">
                <div class="kf-cam-mode-tab active" data-panel="Filters" onclick="switchCamPanel('Filters', this)">ðŸŽ¨ Filters</div>
                <div class="kf-cam-mode-tab" data-panel="Adjust" onclick="switchCamPanel('Adjust', this)">âœ¨ Adjust</div>
                <div class="kf-cam-mode-tab" data-panel="Face" onclick="switchCamPanel('Face', this)">ðŸ˜œ Effects</div>
                <div class="kf-cam-mode-tab" data-panel="Text" onclick="switchCamPanel('Text', this)">Aa Text</div>
                <div class="kf-cam-mode-tab" data-panel="Stickers" onclick="switchCamPanel('Stickers', this)">ðŸ”¥ Stickers</div>
            </div>

            <!-- Capture controls row -->
            <div class="kf-cam-controls-row">
                <button class="kf-cam-side-btn" onclick="flipCamera()"><i class="fas fa-sync-alt"></i></button>
                <button class="kf-cam-capture-btn" id="cameraCaptureBtn" onclick="capturePhotoWithFilters()"></button>
                <button class="kf-cam-side-btn" onclick="document.getElementById('imageInput').click();closeCamera();"><i class="fas fa-images"></i></button>
            </div>
        </div>
    </div>
    <!-- TikTok-Style Media Editor Modal -->
    <div class="kf-media-editor-modal" id="mediaEditorModal">
        <!-- Header -->
        <div class="kf-editor-header">
            <button class="kf-editor-close" onclick="closeMediaEditor()">
                <i class="fas fa-times"></i>
            </button>
            <div class="kf-editor-title">âœ¦ Edit</div>
            <button class="kf-editor-apply-btn" onclick="saveEditedMedia()">
                <i class="fas fa-check"></i> Done
            </button>
        </div>

        <!-- Main Content: Canvas + Side Tools -->
        <div class="kf-editor-content">
            <div class="kf-editor-canvas-container" id="editorCanvasContainer" onclick="deselectOverlay()">
                <!-- Main drawing canvas -->
                <canvas id="editorCanvas" class="kf-editor-canvas"></canvas>
                <!-- Face filter overlay canvas -->
                <canvas id="faceFilterCanvas"></canvas>
                <!-- Video editor -->
                <video id="editorVideo" class="kf-editor-canvas hidden" controls style="max-width:100%;max-height:100%;"></video>
            </div>

            <!-- Right side quick-access tools (TikTok vertical bar) -->
            <div class="kf-editor-side-tools" id="editorSideTools">
                <button class="kf-side-tool-btn" onclick="activateEditorTab('text')" title="Text">
                    <i class="fas fa-font"></i>
                    <span>Text</span>
                </button>
                <button class="kf-side-tool-btn" onclick="activateEditorTab('stickers')" title="Stickers">
                    <i class="fas fa-smile"></i>
                    <span>Emoji</span>
                </button>
                <button class="kf-side-tool-btn" onclick="activateEditorTab('draw')" title="Draw" id="sideDrawBtn">
                    <i class="fas fa-pen-nib"></i>
                    <span>Draw</span>
                </button>
                <button class="kf-side-tool-btn" onclick="undoLastStroke()" title="Undo">
                    <i class="fas fa-undo"></i>
                    <span>Undo</span>
                </button>
                <button class="kf-side-tool-btn" onclick="activateEditorTab('sound')" title="Sound">
                    <i class="fas fa-music"></i>
                    <span>Sound</span>
                </button>
            </div>

            <!-- Floating text input -->
            <input type="text" class="kf-editor-text-input hidden" id="editorTextInput" placeholder="âœï¸ Type something..." maxlength="120">
        </div>

        <!-- Bottom Tab Bar -->
        <div class="kf-editor-tabs" id="editorTabs">
            <div class="kf-editor-tab active" onclick="activateEditorTab('filters')" data-tab="filters">
                <i class="fas fa-magic"></i> Filters
            </div>
            <div class="kf-editor-tab" onclick="activateEditorTab('adjust')" data-tab="adjust">
                <i class="fas fa-sliders-h"></i> Adjust
            </div>
            <div class="kf-editor-tab" onclick="activateEditorTab('facefilter')" data-tab="facefilter">
                <i class="fas fa-theater-masks"></i> Face
            </div>
            <div class="kf-editor-tab" onclick="activateEditorTab('text')" data-tab="text">
                <i class="fas fa-font"></i> Text
            </div>
            <div class="kf-editor-tab" onclick="activateEditorTab('stickers')" data-tab="stickers">
                <i class="fas fa-smile"></i> Emoji
            </div>
            <div class="kf-editor-tab" onclick="activateEditorTab('overlayimg')" data-tab="overlayimg">
                <i class="fas fa-image"></i> Overlay
            </div>
            <div class="kf-editor-tab" onclick="activateEditorTab('draw')" data-tab="draw">
                <i class="fas fa-pen-nib"></i> Draw
            </div>
            <div class="kf-editor-tab" onclick="activateEditorTab('sound')" data-tab="sound">
                <i class="fas fa-music"></i> Sound
            </div>
            <div class="kf-editor-tab" onclick="activateEditorTab('trim')" data-tab="trim" id="trimTabBtn">
                <i class="fas fa-cut"></i> Trim
            </div>
        </div>

        <!-- Panel Container -->
        <div class="kf-editor-panel-wrap">

            <!-- Filters Panel -->
            <div class="kf-editor-panel active" id="filtersPanel">
                <div class="kf-filter-scroll" id="filterScroll">
                    <!-- Dynamically built by JS with live canvas previews -->
                </div>
            </div>

            <!-- Adjust Panel -->
            <div class="kf-editor-panel" id="adjustPanel" style="flex-direction:column; gap:6px;">
                <div class="kf-adjust-row">
                    <span class="kf-adjust-label">Brightness</span>
                    <input type="range" class="kf-adjust-slider" id="slBrightness" min="-100" max="100" value="0" oninput="applyAdjustments()">
                    <span class="kf-adjust-val" id="valBrightness">0</span>
                </div>
                <div class="kf-adjust-row">
                    <span class="kf-adjust-label">Contrast</span>
                    <input type="range" class="kf-adjust-slider" id="slContrast" min="-100" max="100" value="0" oninput="applyAdjustments()">
                    <span class="kf-adjust-val" id="valContrast">0</span>
                </div>
                <div class="kf-adjust-row">
                    <span class="kf-adjust-label">Saturation</span>
                    <input type="range" class="kf-adjust-slider" id="slSaturation" min="-100" max="100" value="0" oninput="applyAdjustments()">
                    <span class="kf-adjust-val" id="valSaturation">0</span>
                </div>
                <div class="kf-adjust-row">
                    <span class="kf-adjust-label">Sharpness</span>
                    <input type="range" class="kf-adjust-slider" id="slSharpness" min="0" max="100" value="0" oninput="applyAdjustments()">
                    <span class="kf-adjust-val" id="valSharpness">0</span>
                </div>
                <div class="kf-adjust-row">
                    <span class="kf-adjust-label">Warmth</span>
                    <input type="range" class="kf-adjust-slider" id="slWarmth" min="-100" max="100" value="0" oninput="applyAdjustments()">
                    <span class="kf-adjust-val" id="valWarmth">0</span>
                </div>
                <div class="kf-adjust-row">
                    <span class="kf-adjust-label">Vignette</span>
                    <input type="range" class="kf-adjust-slider" id="slVignette" min="0" max="100" value="0" oninput="applyAdjustments()">
                    <span class="kf-adjust-val" id="valVignette">0</span>
                </div>
            </div>

            <!-- Face Filter Panel -->
            <div class="kf-editor-panel" id="facefilterPanel">
                <div class="kf-face-filter-scroll">
                    <div class="kf-face-filter-btn active" onclick="applyFaceFilter('none', this)">
                        <div class="kf-face-filter-preview">ðŸš«</div>
                        <span class="kf-face-filter-name">None</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('dog', this)">
                        <div class="kf-face-filter-preview">ðŸ¶</div>
                        <span class="kf-face-filter-name">Dog</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('cat', this)">
                        <div class="kf-face-filter-preview">ðŸ±</div>
                        <span class="kf-face-filter-name">Cat</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('bunny', this)">
                        <div class="kf-face-filter-preview">ðŸ°</div>
                        <span class="kf-face-filter-name">Bunny</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('alien', this)">
                        <div class="kf-face-filter-preview">ðŸ‘½</div>
                        <span class="kf-face-filter-name">Alien</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('crown', this)">
                        <div class="kf-face-filter-preview">ðŸ‘‘</div>
                        <span class="kf-face-filter-name">Crown</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('glasses', this)">
                        <div class="kf-face-filter-preview">ðŸ•¶ï¸</div>
                        <span class="kf-face-filter-name">Shades</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('fire', this)">
                        <div class="kf-face-filter-preview">ðŸ”¥</div>
                        <span class="kf-face-filter-name">Fire</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('rainbow', this)">
                        <div class="kf-face-filter-preview">ðŸŒˆ</div>
                        <span class="kf-face-filter-name">Rainbow</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('stars', this)">
                        <div class="kf-face-filter-preview">â­</div>
                        <span class="kf-face-filter-name">Stars</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('hearts', this)">
                        <div class="kf-face-filter-preview">ðŸ’•</div>
                        <span class="kf-face-filter-name">Hearts</span>
                    </div>
                    <div class="kf-face-filter-btn" onclick="applyFaceFilter('clown', this)">
                        <div class="kf-face-filter-preview">ðŸ¤¡</div>
                        <span class="kf-face-filter-name">Clown</span>
                    </div>
                </div>
            </div>

            <!-- Text Panel -->
            <div class="kf-editor-panel" id="textPanel" style="flex-direction:column; gap:8px;">
                <div class="kf-text-toolbar">
                    <!-- Font families -->
                    <div class="kf-text-row" style="gap:5px; overflow-x:auto; flex-wrap:nowrap; padding-bottom:2px;">
                        <button class="kf-font-chip active" style="font-family:'Arial'" onclick="setTextFont('Arial', this)">Aa</button>
                        <button class="kf-font-chip" style="font-family:'Pacifico'" onclick="setTextFont('Pacifico', this)">Pacifico</button>
                        <button class="kf-font-chip" style="font-family:'Permanent Marker'" onclick="setTextFont('Permanent Marker', this)">Marker</button>
                        <button class="kf-font-chip" style="font-family:'Bangers'" onclick="setTextFont('Bangers', this)">Bangers</button>
                        <button class="kf-font-chip" style="font-family:'Dancing Script'" onclick="setTextFont('Dancing Script', this)">Script</button>
                        <button class="kf-font-chip" style="font-family:'Righteous'" onclick="setTextFont('Righteous', this)">Righteous</button>
                        <button class="kf-font-chip" style="font-family:'Impact'" onclick="setTextFont('Impact', this)">Impact</button>
                        <button class="kf-font-chip" style="font-family:'Georgia'" onclick="setTextFont('Georgia', this)">Georgia</button>
                        <button class="kf-font-chip" style="font-family:'Courier New'" onclick="setTextFont('Courier New', this)">Mono</button>
                    </div>
                    <!-- Colors + styles -->
                    <div class="kf-text-row">
                        <div class="kf-color-dot active" style="background:#ffffff;" onclick="setTextColor('#ffffff', this)"></div>
                        <div class="kf-color-dot" style="background:#000000;" onclick="setTextColor('#000000', this)"></div>
                        <div class="kf-color-dot" style="background:#fe2c55;" onclick="setTextColor('#fe2c55', this)"></div>
                        <div class="kf-color-dot" style="background:#25f4ee;" onclick="setTextColor('#25f4ee', this)"></div>
                        <div class="kf-color-dot" style="background:#ffeb3b;" onclick="setTextColor('#ffeb3b', this)"></div>
                        <div class="kf-color-dot" style="background:#00e676;" onclick="setTextColor('#00e676', this)"></div>
                        <div class="kf-color-dot" style="background:#ff6b35;" onclick="setTextColor('#ff6b35', this)"></div>
                        <div class="kf-color-dot" style="background:#a78bfa;" onclick="setTextColor('#a78bfa', this)"></div>
                        <!-- Custom color picker -->
                        <div class="kf-color-input-wrap" title="Custom color">
                            <input type="color" id="textCustomColor" value="#ff1493" oninput="setTextColor(this.value, null)">
                        </div>
                        <span style="color:rgba(255,255,255,0.3);font-size:12px;margin:0 4px;">|</span>
                        <!-- Text background styles -->
                        <button class="kf-text-style-btn active" id="bgStyleNone" onclick="setTextBgStyle('none', this)">None</button>
                        <button class="kf-text-style-btn" id="bgStyleDark" onclick="setTextBgStyle('bg-dark', this)">Dark</button>
                        <button class="kf-text-style-btn" id="bgStyleLight" onclick="setTextBgStyle('bg-light', this)">Light</button>
                        <button class="kf-text-style-btn" id="bgStyleColor" onclick="setTextBgStyle('bg-color', this)">Color</button>
                    </div>
                    <!-- Add text button -->
                    <div class="kf-text-row">
                        <button onclick="addTextOverlay()" style="flex:1;padding:8px 0;border-radius:12px;background:linear-gradient(135deg,#fe2c55,#ff6b35);border:none;color:white;font-weight:700;font-size:13px;cursor:pointer;">
                            <i class="fas fa-plus"></i> Add Text
                        </button>
                        <button onclick="increaseTextSize()" style="padding:8px 14px;border-radius:12px;background:#222;border:1px solid #333;color:white;cursor:pointer;font-size:15px;">A+</button>
                        <button onclick="decreaseTextSize()" style="padding:8px 14px;border-radius:12px;background:#222;border:1px solid #333;color:white;cursor:pointer;font-size:13px;">Aâˆ’</button>
                    </div>
                </div>
            </div>

            <!-- Stickers / Emoji Panel -->
            <div class="kf-editor-panel" id="stickersPanel">
                <div class="kf-sticker-grid">
                    <!-- Mood/GenZ -->
                    <button class="kf-sticker-btn" onclick="addSticker('âœ¨')">âœ¨</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ’…')">ðŸ’…</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ”¥')">ðŸ”¥</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ’¯')">ðŸ’¯</button>
                    <button class="kf-sticker-btn" onclick="addSticker('â­')">â­</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸŽµ')">ðŸŽµ</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ’•')">ðŸ’•</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ˜‚')">ðŸ˜‚</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ¥¶')">ðŸ¥¶</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ¤©')">ðŸ¤©</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ˜')">ðŸ˜</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ™ˆ')">ðŸ™ˆ</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸš€')">ðŸš€</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸŒˆ')">ðŸŒˆ</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸŽ‰')">ðŸŽ‰</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ’€')">ðŸ’€</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ‘‘')">ðŸ‘‘</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸŽ¯')">ðŸŽ¯</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ¤‘')">ðŸ¤‘</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ˜¤')">ðŸ˜¤</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸŒ¸')">ðŸŒ¸</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ•')">ðŸ•</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸŽ®')">ðŸŽ®</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ’¸')">ðŸ’¸</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ†')">ðŸ†</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ“¸')">ðŸ“¸</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ’Ž')">ðŸ’Ž</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ«¶')">ðŸ«¶</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ¥º')">ðŸ¥º</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ˜­')">ðŸ˜­</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ¤Ÿ')">ðŸ¤Ÿ</button>
                    <button class="kf-sticker-btn" onclick="addSticker('âœŒï¸')">âœŒï¸</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ™')">ðŸ™</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ’ª')">ðŸ’ª</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ‘»')">ðŸ‘»</button>
                    <button class="kf-sticker-btn" onclick="addSticker('ðŸ¦‹')">ðŸ¦‹</button>
                </div>
            </div>

            <!-- Overlay Image Panel -->
            <div class="kf-editor-panel" id="overlayimgPanel">
                <div class="kf-overlay-img-grid">
                    <!-- Upload your own overlay -->
                    <label class="kf-overlay-img-btn kf-upload-overlay-btn" title="Upload image overlay">
                        <i class="fas fa-plus"></i>
                        <input type="file" accept="image/*" style="display:none" onchange="addImageOverlay(this)">
                    </label>
                    <!-- Preset decorative overlays (emoji rendered as images) -->
                    <div class="kf-overlay-img-btn" onclick="addStickerImage('ðŸŒŸ', 'star')">ðŸŒŸ</div>
                    <div class="kf-overlay-img-btn" onclick="addStickerImage('ðŸŒ¸', 'flower')">ðŸŒ¸</div>
                    <div class="kf-overlay-img-btn" onclick="addStickerImage('ðŸ’«', 'sparkle')">ðŸ’«</div>
                    <div class="kf-overlay-img-btn" onclick="addStickerImage('ðŸŽ€', 'bow')">ðŸŽ€</div>
                    <div class="kf-overlay-img-btn" onclick="addStickerImage('ðŸ€', 'clover')">ðŸ€</div>
                    <div class="kf-overlay-img-btn" onclick="addStickerImage('ðŸ¦„', 'unicorn')">ðŸ¦„</div>
                    <div class="kf-overlay-img-btn" onclick="addStickerImage('ðŸŒ™', 'moon')">ðŸŒ™</div>
                </div>
            </div>

            <!-- Draw Panel -->
            <div class="kf-editor-panel" id="drawPanel" style="flex-direction:column; gap:8px;">
                <div class="kf-draw-tools">
                    <!-- Brush types -->
                    <button class="kf-brush-btn active" id="brushPen" onclick="setBrushType('pen', this)"><i class="fas fa-pen"></i> Pen</button>
                    <button class="kf-brush-btn" id="brushHighlight" onclick="setBrushType('highlight', this)"><i class="fas fa-highlighter"></i> Highlighter</button>
                    <button class="kf-brush-btn" id="brushNeon" onclick="setBrushType('neon', this)">âœ¦ Neon</button>
                    <button class="kf-brush-btn" id="brushEraser" onclick="setBrushType('eraser', this)"><i class="fas fa-eraser"></i> Eraser</button>
                    <span style="color:rgba(255,255,255,0.3);font-size:11px;margin:0 2px;">Size</span>
                    <input type="range" class="kf-size-slider" id="drawSizeSlider" min="1" max="40" value="5" oninput="setDrawSize(this.value)">
                    <button class="kf-brush-btn" onclick="clearDraw()" style="margin-left:auto;">Clear All</button>
                </div>
                <div class="kf-draw-color-row">
                    <div class="kf-color-dot active" style="background:#ffffff;" onclick="setDrawColor('#ffffff', this)"></div>
                    <div class="kf-color-dot" style="background:#000000;" onclick="setDrawColor('#000000', this)"></div>
                    <div class="kf-color-dot" style="background:#fe2c55;" onclick="setDrawColor('#fe2c55', this)"></div>
                    <div class="kf-color-dot" style="background:#25f4ee;" onclick="setDrawColor('#25f4ee', this)"></div>
                    <div class="kf-color-dot" style="background:#ffeb3b;" onclick="setDrawColor('#ffeb3b', this)"></div>
                    <div class="kf-color-dot" style="background:#00e676;" onclick="setDrawColor('#00e676', this)"></div>
                    <div class="kf-color-dot" style="background:#ff6b35;" onclick="setDrawColor('#ff6b35', this)"></div>
                    <div class="kf-color-dot" style="background:#a78bfa;" onclick="setDrawColor('#a78bfa', this)"></div>
                    <div class="kf-color-dot" style="background:#f06292;" onclick="setDrawColor('#f06292', this)"></div>
                    <div class="kf-color-input-wrap" title="Custom draw color">
                        <input type="color" id="drawCustomColor" value="#ff1493" oninput="setDrawColor(this.value, null)">
                    </div>
                </div>
            </div>

            <!-- Sound Panel -->
            <div class="kf-editor-panel" id="soundPanel" style="flex-direction:column; gap:8px;">
                <div class="kf-sound-panel">
                    <div style="font-size:11px;color:rgba(255,255,255,0.4);margin-bottom:4px;">Add sound to your photo ðŸŽµ</div>
                    <!-- Upload custom audio -->
                    <label class="kf-sound-track" id="soundUploadTrack" style="cursor:pointer;">
                        <div class="kf-sound-track-icon">ðŸ“‚</div>
                        <div class="kf-sound-track-info">
                            <div class="kf-sound-track-name" id="soundUploadLabel">Upload audio file...</div>
                            <div class="kf-sound-track-dur">mp3, wav, ogg</div>
                        </div>
                        <input type="file" accept="audio/*" style="display:none" id="soundFileInput" onchange="loadEditorSound(this)">
                    </label>
                    <!-- Volume control -->
                    <div class="kf-sound-vol-row" id="soundVolRow" style="display:none;">
                        <span class="kf-sound-vol-label">ðŸ”Š Volume</span>
                        <input type="range" class="kf-adjust-slider" id="soundVolSlider" min="0" max="100" value="80" oninput="setSoundVolume(this.value)">
                        <span class="kf-adjust-val" id="soundVolVal">80</span>
                        <button onclick="playEditorSound()" id="soundPlayBtn" style="padding:5px 10px;border-radius:10px;background:#fe2c55;border:none;color:white;font-size:11px;cursor:pointer;font-weight:700;">â–¶ Play</button>
                        <button onclick="removeEditorSound()" style="padding:5px 10px;border-radius:10px;background:#333;border:none;color:white;font-size:11px;cursor:pointer;">âœ•</button>
                    </div>
                    <!-- Export as Video CTA â€” shown when sound is loaded -->
                    <div id="soundExportVideoRow" style="display:none;margin-top:10px;padding:12px;border-radius:14px;background:linear-gradient(135deg,rgba(254,44,85,0.15),rgba(37,244,238,0.1));border:1px solid rgba(254,44,85,0.3);">
                        <div style="font-size:12px;color:white;font-weight:700;margin-bottom:4px;">ðŸŽ¬ Save as Video</div>
                        <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:10px;">Bake this photo + sound into a shareable video file</div>
                        <button onclick="triggerImageToVideo()" style="width:100%;padding:11px;border-radius:12px;background:linear-gradient(135deg,#fe2c55,#ff6b35);border:none;color:white;font-size:13px;font-weight:700;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:8px;">
                            <i class="fas fa-film"></i> Export Photo + Sound as Video
                        </button>
                    </div>
                </div>
            </div>

            <!-- Trim Panel (video) -->
            <div class="kf-editor-panel" id="trimPanel" style="flex-direction:column; gap:8px; width:100%;">
                <div style="display:flex;justify-content:space-between;color:rgba(255,255,255,0.6);font-size:11px;">
                    <span>Start: <strong id="trimStart" style="color:white;">0:00</strong></span>
                    <span>End: <strong id="trimEnd" style="color:white;">0:00</strong></span>
                </div>
                <div class="kf-adjust-row">
                    <span class="kf-adjust-label" style="font-size:10px;">Start</span>
                    <input type="range" class="kf-adjust-slider" id="trimStartSlider" min="0" max="100" value="0" oninput="updateTrimStart()">
                </div>
                <div class="kf-adjust-row">
                    <span class="kf-adjust-label" style="font-size:10px;">End</span>
                    <input type="range" class="kf-adjust-slider" id="trimEndSlider" min="0" max="100" value="100" oninput="updateTrimEnd()">
                </div>
                <button onclick="previewTrim()" style="padding:7px;border-radius:10px;background:#fe2c55;border:none;color:white;font-size:12px;font-weight:700;cursor:pointer;">â–¶ Preview Trim</button>
            </div>
        </div><!-- end panel-wrap -->

        <!-- Footer with undo and reset -->
        <div class="kf-editor-footer">
            <button class="kf-editor-btn kf-editor-btn-secondary" onclick="resetEdits()">
                <i class="fas fa-undo"></i> Reset
            </button>
            <button class="kf-editor-btn kf-editor-btn-primary" onclick="saveEditedMedia()">
                <i class="fas fa-check"></i> Apply & Save
            </button>
        </div>
    </div>

    <!-- ===== IMAGE-TO-VIDEO EXPORT MODAL ===== -->
    <div class="kf-vid-export-modal" id="vidExportModal">
        <div class="kf-vid-export-card">
            <div class="kf-vid-export-title">ðŸŽ¬ Export as Video</div>
            <div class="kf-vid-export-sub">Baking your photo + sound into a shareable video...</div>
            <div id="vidExportProgressSection">
                <div class="kf-vid-export-progress-wrap">
                    <div class="kf-vid-export-progress-bar" id="vidExportProgressBar"></div>
                </div>
                <div class="kf-vid-export-status" id="vidExportStatus">Preparing frames...</div>
            </div>
            <div id="vidExportResult" style="display:none;">
                <div class="kf-vid-export-preview" id="vidExportPreview"></div>
                <div class="kf-vid-export-btns">
                    <button class="kf-vid-export-btn secondary" onclick="closeVidExportModal()"><i class="fas fa-times"></i> Close</button>
                    <button class="kf-vid-export-btn primary" id="vidExportDownloadBtn" onclick="downloadExportedVideo()"><i class="fas fa-download"></i> Save</button>
                    <button class="kf-vid-export-btn primary" id="vidExportUseBtn" onclick="useExportedVideo()" style="background:linear-gradient(135deg,#25f4ee,#0095f6);"><i class="fas fa-check"></i> Use in Post</button>
                </div>
            </div>
            <div class="kf-vid-export-btns" id="vidExportCancelRow">
                <button class="kf-vid-export-btn secondary" onclick="cancelVidExport()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- ===== SLIDESHOW / CAPCUT-STYLE VIDEO BUILDER ===== -->
    <div class="kf-slideshow-modal" id="slideshowModal">
        <div class="kf-ss-header">
            <button class="kf-ss-close-btn" onclick="closeSlideshowBuilder()"><i class="fas fa-times"></i></button>
            <div class="kf-ss-title"><i class="fas fa-film"></i> Video Maker</div>
            <button class="kf-ss-export-btn" id="ssExportBtn" onclick="exportSlideshowVideo()"><i class="fas fa-video"></i> Export</button>
        </div>
        <div class="kf-ss-preview-area">
            <canvas id="ssPreviewCanvas" width="540" height="960"></canvas>
            <div class="kf-ss-play-overlay">
                <button class="kf-ss-play-btn-big" id="ssPlayBtn" onclick="toggleSlideshowPreview()">
                    <i class="fas fa-play" id="ssPlayIcon"></i>
                </button>
            </div>
            <div class="kf-ss-exporting" id="ssExportingOverlay">
                <div class="kf-ss-exp-title">âœ¨ Exporting...</div>
                <div class="kf-ss-exp-pct" id="ssExpPct">0%</div>
                <div class="kf-ss-exp-bar-wrap"><div class="kf-ss-exp-bar" id="ssExpBar"></div></div>
                <div class="kf-ss-exp-sub" id="ssExpStatus">Rendering frames...</div>
            </div>
        </div>
        <div class="kf-ss-settings">
            <div style="font-size:10px;color:rgba(255,255,255,0.35);font-weight:700;letter-spacing:1px;text-transform:uppercase;margin-bottom:7px;">Transition Effect</div>
            <div class="kf-ss-settings-row" id="ssTransitionRow"></div>
            <div class="kf-ss-dur-row">
                <span class="kf-ss-dur-label">Slide Time</span>
                <input type="range" class="kf-ss-dur-slider" id="ssSlideDur" min="1" max="10" value="3" step="0.5" oninput="updateSsSlideDur()">
                <span class="kf-ss-dur-val" id="ssSlideDurVal">3s</span>
            </div>
            <div class="kf-ss-dur-row" style="margin-bottom:0;">
                <span class="kf-ss-dur-label">Fade Time</span>
                <input type="range" class="kf-ss-dur-slider" id="ssTransDur" min="0.2" max="1.5" value="0.6" step="0.1" oninput="updateSsTransDur()">
                <span class="kf-ss-dur-val" id="ssTransDurVal">0.6s</span>
            </div>
            <div class="kf-ss-sound-row">
                <label class="kf-ss-sound-btn" id="ssSoundBtn" style="cursor:pointer;">
                    <i class="fas fa-music"></i> Add Sound
                    <input type="file" accept="audio/*" id="ssSoundInput" onchange="loadSsSound(this)" style="display:none;">
                </label>
                <span class="kf-ss-sound-name" id="ssSoundName">No audio selected</span>
                <button id="ssSoundRemoveBtn" onclick="removeSsSound()" style="display:none;background:none;border:none;color:rgba(255,255,255,0.4);cursor:pointer;font-size:16px;">âœ•</button>
            </div>
        </div>
        <div class="kf-ss-timeline">
            <div class="kf-ss-timeline-label">Timeline Â· <span id="ssTotalDurLabel">0s</span></div>
            <div class="kf-ss-timeline-strip" id="ssTimelineStrip"></div>
        </div>
    </div>

    <main class="kf-main-container">
        <div class="kf-post-card">
            <div class="kf-post-header">
                <button class="kf-post-close" onclick="closePost()">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <div class="kf-post-title">
                    <i class="fas fa-pen"></i> create a vibe
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button type="button" class="kf-vibe-check" id="vibeCheckBtn">
                        âœ¨
                    </button>
                    <button type="submit" form="postForm" class="kf-share-btn-header" id="sharePostBtn" disabled>
                        <i class="fas fa-paper-plane"></i> post
                    </button>
                </div>
            </div>

            <form id="postForm" action="{% url 'post' %}" method="post" enctype="multipart/form-data" class="kf-post-content">
                {% csrf_token %}
                
                <!-- Mood Selector - Compact -->
                <div class="kf-mood-section">
                    <div class="kf-mood-label">
                        <i class="fas fa-smile-wink"></i> mood
                    </div>
                    
                    <div class="kf-mood-row">
                        <div class="kf-mood-dropdown-container">
                            <div class="kf-mood-selector-btn" id="moodSelectorBtn" onclick="toggleMoodDropdown()">
                                <div class="kf-selected-mood">
                                    <span class="kf-selected-mood-emoji" id="selectedMoodEmoji">âœ¨</span>
                                    <span class="kf-selected-mood-text" id="selectedMoodText">select</span>
                                </div>
                                <i class="fas fa-chevron-down"></i>
                            </div>
                            
                            <div class="kf-mood-dropdown" id="moodDropdown">
                                <div class="kf-mood-option" onclick="selectMood('slay', 'ðŸ’…', 'main character')">
                                    <span class="kf-mood-option-emoji">ðŸ’…</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">slay</div>
                                        <div class="kf-mood-option-vibe">main character</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('vibing', 'ðŸŽµ', 'chill')">
                                    <span class="kf-mood-option-emoji">ðŸŽµ</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">vibing</div>
                                        <div class="kf-mood-option-vibe">chill</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('sheesh', 'ðŸ¥¶', 'cold')">
                                    <span class="kf-mood-option-emoji">ðŸ¥¶</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">sheesh</div>
                                        <div class="kf-mood-option-vibe">cold</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('periodt', 'â¸ï¸', 'period')">
                                    <span class="kf-mood-option-emoji">â¸ï¸</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">periodt</div>
                                        <div class="kf-mood-option-vibe">period</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('no-cap', 'ðŸŽ¯', 'for real')">
                                    <span class="kf-mood-option-emoji">ðŸŽ¯</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">no cap</div>
                                        <div class="kf-mood-option-vibe">for real</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('bussin', 'ðŸ”¥', 'fire')">
                                    <span class="kf-mood-option-emoji">ðŸ”¥</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">bussin</div>
                                        <div class="kf-mood-option-vibe">fire</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('mid', 'ðŸ˜', 'average')">
                                    <span class="kf-mood-option-emoji">ðŸ˜</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">mid</div>
                                        <div class="kf-mood-option-vibe">average</div>
                                    </div>
                                </div>
                                <div class="kf-mood-option" onclick="selectMood('cringe', 'ðŸ˜¬', 'cheugy')">
                                    <span class="kf-mood-option-emoji">ðŸ˜¬</span>
                                    <div class="kf-mood-option-info">
                                        <div class="kf-mood-option-name">cringe</div>
                                        <div class="kf-mood-option-vibe">cheugy</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Custom Mood - Simple -->
                    <div class="kf-custom-mood-container">
                        <div class="kf-custom-mood-row">
                            <input type="text" 
                                   class="kf-custom-mood-input" 
                                   id="customMoodInput"
                                   placeholder="type your vibe..."
                                   maxlength="30">
                            <button type="button" class="kf-add-custom-btn" onclick="addCustomMood()">
                                <i class="fas fa-plus"></i> Add
                            </button>
                        </div>
                        
                        <div class="kf-custom-suggestions">
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('blessed âœ¨')">blessed âœ¨</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('ungovernable ðŸ”¥')">ungovernable ðŸ”¥</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('demure ðŸ’…')">demure ðŸ’…</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('delulu ðŸ¤ª')">delulu ðŸ¤ª</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('main character â­')">main character â­</span>
                            <span class="kf-custom-suggestion" onclick="setCustomMoodInput('unbothered ðŸ˜Œ')">unbothered ðŸ˜Œ</span>
                        </div>
                    </div>
                    
                    <!-- Hidden inputs -->
                    <input type="hidden" name="mood" id="moodInput">
                    <input type="hidden" name="custom_mood" id="customMoodInputHidden">
                    
                    <!-- Active mood display -->
                    <div id="activeMoodBadge" class="kf-active-mood hidden">
                        <span id="activeMoodEmoji">âœ¨</span>
                        <span id="activeMoodText">slay</span>
                    </div>
                </div>
                
                <div class="kf-textarea-container">
                    <textarea name="content" class="kf-textarea" placeholder="what's the tea? â˜•" rows="3" oninput="updatePreview()"></textarea>
                </div>
                
                <div class="kf-upload-section">
                    <div class="kf-upload-label">
                        <i class="fas fa-plus"></i> add media
                    </div>
                    
                    <!-- Media Options Grid - Camera instead of Photos -->
                    <div class="kf-media-grid">
                        <!-- Camera Option (New) -->
                        <div class="kf-media-option camera" onclick="openCamera()">
                            <div class="kf-media-card">
                                <i class="fas fa-camera"></i>
                                <span class="kf-media-label">camera</span>
                                <span class="kf-media-sub-label">take a snap</span>
                            </div>
                        </div>
                        
                        <div class="kf-media-option record" onclick="openVideoRecorder()">
                            <div class="kf-media-card">
                                <i class="fas fa-video"></i>
                                <span class="kf-media-label">record</span>
                                <span class="kf-media-sub-label">video</span>
                            </div>
                        </div>
                        
                        <label class="kf-media-option">
                            <input type="file" id="video_file_upload" accept="video/*" onchange="handleVideoSelect(this)" style="display: none;">
                            <div class="kf-media-card">
                                <i class="fas fa-cloud-upload-alt"></i>
                                <span class="kf-media-label">upload</span>
                                <span class="kf-media-sub-label">video</span>
                            </div>
                        </label>
                        
                        <div class="kf-media-option record" onclick="startAudioRecording()">
                            <div class="kf-media-card">
                                <i class="fas fa-microphone-alt"></i>
                                <span class="kf-media-label">record</span>
                                <span class="kf-media-sub-label">audio</span>
                            </div>
                        </div>
                        
                        <label class="kf-media-option">
                            <input type="file" id="audio_file_upload" accept="audio/*" onchange="handleAudioSelect(this)" style="display: none;">
                            <div class="kf-media-card">
                                <i class="fas fa-headphones"></i>
                                <span class="kf-media-label">upload</span>
                                <span class="kf-media-sub-label">audio</span>
                            </div>
                        </label>
                        
                        <label class="kf-media-option">
                            <input type="file" id="images" name="images" accept="image/*" multiple onchange="handleImageSelect(this)" style="display: none;">
                            <div class="kf-media-card">
                                <i class="fas fa-folder-open"></i>
                                <span class="kf-media-label">gallery</span>
                                <span class="kf-media-sub-label">choose</span>
                            </div>
                        </label>

                        <div class="kf-media-option" onclick="openSlideshowBuilder()" style="grid-column: span 3;">
                            <div class="kf-media-card" style="flex-direction:row;gap:10px;padding:14px 16px;background:linear-gradient(135deg,rgba(254,44,85,0.12),rgba(37,244,238,0.08));border-color:#fe2c55;">
                                <i class="fas fa-film" style="color:#fe2c55;font-size:22px;"></i>
                                <div>
                                    <span class="kf-media-label" style="color:#fe2c55;">Video Maker</span>
                                    <span class="kf-media-sub-label" style="display:block;">combine photos â†’ video âœ¨</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Hidden file inputs -->
                    <input type="file" name="video_file" id="video_file" accept="video/*" class="hidden">
                    <input type="file" name="audio_file" id="audio_file" accept="audio/*" class="hidden">
                    
                    <!-- Image Preview Grid -->
                    <div id="imagePreviewGrid" class="kf-image-preview-grid"></div>
                    
                    <!-- Video Recording Status -->
                    <div id="videoRecordingStatus" class="kf-recording-status hidden">
                        <div class="kf-recording-dot"></div>
                        <div class="kf-recording-text" id="videoRecordingText">dropping a video... ðŸŽ¥</div>
                        <div class="kf-recording-time" id="videoRecordingTime">00:00</div>
                        <button type="button" onclick="stopVideoRecording()" style="background:var(--ig-danger); color:white; border:none; padding:4px 12px; border-radius:20px; font-size:12px;">stop</button>
                    </div>
                    
                    <!-- Audio Recording Status -->
                    <div id="recordingStatus" class="kf-recording-status hidden">
                        <div class="kf-recording-dot"></div>
                        <div class="kf-recording-text" id="audioRecordingText">spitting facts... ðŸŽ¤</div>
                        <div class="kf-recording-time" id="recordingTime">00:00</div>
                        <button type="button" onclick="stopAudioRecording()" style="background:var(--ig-danger); color:white; border:none; padding:4px 12px; border-radius:20px; font-size:12px;">stop</button>
                    </div>
                    
                    <!-- Video Player -->
                    <div id="videoPlayer" class="kf-video-player">
                        <div class="kf-video-player-header">
                            <div class="kf-video-player-title">
                                <i class="fas fa-play-circle"></i> video preview
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button type="button" class="kf-video-player-close" onclick="editVideo()" style="color: var(--ig-primary);">
                                    <i class="fas fa-pen"></i>
                                </button>
                                <button type="button" class="kf-video-player-close" onclick="closeVideoPlayer()">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                        
                        <video class="kf-video-element" id="videoElement" controls></video>
                        
                        <div class="kf-video-actions">
                            <button type="button" onclick="keepVideo()" class="kf-video-action-btn kf-video-keep">keep</button>
                            <button type="button" onclick="discardVideo()" class="kf-video-action-btn">discard</button>
                        </div>
                    </div>
                    
                    <!-- Audio Player -->
                    <div id="audioPlayer" class="kf-audio-player">
                        <div class="kf-audio-player-header">
                            <div class="kf-audio-player-title">
                                <i class="fas fa-play-circle"></i> audio preview
                            </div>
                            <button type="button" class="kf-audio-player-close" onclick="closeAudioPlayer()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        
                        <div class="kf-custom-audio-player">
                            <div class="kf-audio-controls">
                                <button type="button" class="kf-audio-play-btn" id="playAudioBtn">
                                    <i class="fas fa-play"></i>
                                </button>
                                <div class="kf-audio-info">
                                    <div class="kf-audio-filename" id="audioFilename">audio recording</div>
                                    <div class="kf-audio-time">
                                        <span id="currentTime">0:00</span>
                                        <span id="durationTime">0:00</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="kf-audio-progress" id="audioProgress">
                                <div class="kf-audio-progress-filled" id="audioProgressFilled"></div>
                            </div>
                        </div>
                        
                        <div class="kf-audio-actions">
                            <button type="button" onclick="keepAudio()" class="kf-audio-action-btn kf-audio-keep">keep</button>
                            <button type="button" onclick="discardAudio()" class="kf-audio-action-btn">discard</button>
                        </div>
                    </div>
                    
                    <!-- Preview Box -->
                    <div class="kf-preview-container">
                        <div id="previewBox" class="kf-preview-box">
                            <div class="kf-preview-icon">
                                <i class="fas fa-eye"></i>
                            </div>
                            <div class="kf-preview-text">preview</div>
                            <div id="previewItem" class="kf-preview-item">nothing yet</div>
                            <div id="fileSizeInfo" class="kf-file-size-info"></div>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </main>

    <!-- Video Recorder Modal -->
    <div id="videoRecorderModal" class="kf-video-recorder-modal">
        <div class="kf-video-recorder-header">
            <button class="kf-video-recorder-close" onclick="closeVideoRecorder()">
                <i class="fas fa-times"></i>
            </button>
            <div class="kf-video-recorder-timer" id="recorderTimer">00:00</div>
            
            <label class="kf-sound-select-btn" id="selectSoundLabel">
                <i class="fas fa-music"></i>
                <span id="soundSelectionText">add sound</span>
                <input type="file" id="music_file_upload" accept="audio/*" class="hidden" onchange="handleMusicSelect(this)">
            </label>
        </div>
        
        <div class="kf-video-preview">
            <video id="videoLive" class="kf-video-live" autoplay muted playsinline></video>
            <div id="recordingIndicator" class="kf-video-recording-indicator hidden">
                <div class="kf-recording-dot-large"></div>
                <span>REC</span>
            </div>
            <div class="kf-video-watermark">
                <div class="kf-watermark-brand">
                    <i class="fas fa-star"></i> @Kishiface
                </div>
                <div class="kf-watermark-username">
                    <i class="fas fa-at"></i> {{request.user.username}}
                </div>
            </div>
        </div>
        
        <div class="kf-video-controls">
            <div class="kf-video-main-controls">
                <button class="kf-video-control-btn" onclick="flipVideoCamera()">
                    <i class="fas fa-sync-alt"></i>
                </button>
                
                <button class="kf-video-record-btn" id="videoRecordBtn" onclick="toggleVideoRecording()"></button>
                
                <button class="kf-video-control-btn" onclick="toggleMicrophone()" id="toggleMicBtn">
                    <i class="fas fa-microphone"></i>
                </button>
            </div>
            
            <div class="kf-video-secondary-controls">
                <button class="kf-video-control-btn" onclick="cancelVideoRecording()">
                    <i class="fas fa-ban"></i>
                </button>
                <button class="kf-video-control-btn" id="finishRecordingBtn" onclick="finishVideoRecording()" style="display: none;">
                    <i class="fas fa-check"></i>
                </button>
            </div>
        </div>
    </div>

    <script>
        // =================== Custom Alert Function ===================
        function showAlert(title, message, emoji = 'âœ¨', buttons = [{text: 'ok', type: 'primary'}]) {
            return new Promise((resolve) => {
                const modal = document.getElementById('alertModal');
                const emojiEl = document.getElementById('alertEmoji');
                const titleEl = document.getElementById('alertTitle');
                const messageEl = document.getElementById('alertMessage');
                const buttonsEl = document.getElementById('alertButtons');
                
                emojiEl.textContent = emoji;
                titleEl.textContent = title;
                messageEl.textContent = message;
                
                // Clear existing buttons
                buttonsEl.innerHTML = '';
                
                // Add new buttons
                buttons.forEach((btn, index) => {
                    const button = document.createElement('button');
                    button.className = `kf-alert-btn ${btn.type}`;
                    button.textContent = btn.text;
                    button.onclick = () => {
                        closeAlert();
                        resolve(btn.text);
                    };
                    buttonsEl.appendChild(button);
                });
                
                modal.classList.add('active');
            });
        }

        function closeAlert() {
            document.getElementById('alertModal').classList.remove('active');
        }

        // =================== State Variables ===================
        let selectedMood = null;
        let selectedCustomMood = null;
        let selectedImages = [];
        let currentVideoBlob = null;
        let currentAudioBlob = null;
        
        // Camera state
        let cameraStream = null;
        let isFrontCameraCamera = true;
        let capturedPhotoBlob = null;
        
        // Video recording state
        let videoStream = null;
        let videoMediaRecorder = null;
        let videoChunks = [];
        let isRecordingVideo = false;
        let videoRecordingStartTime = null;
        let videoRecordingTimer = null;
        let isFrontCameraVideo = true;
        let isMicOn = true;
        const MAX_RECORDING_TIME = 3 * 60 * 1000;
        
        // Audio recording state
        let audioMediaRecorder = null;
        let audioChunks = [];
        let isRecordingAudio = false;
        let audioRecordingStartTime = null;
        let audioRecordingTimer = null;
        let audioElement = new Audio();
        let isPlaying = false;
        
        // Audio context for music
        let audioContext = null;
        let musicBuffer = null;
        let musicSourceNode = null;
        let isMusicPlaying = false;
        let musicGainNode = null;
        let micGainNode = null;
        let destinationNode = null;
        let musicStartTime = 0;
        
        // Editor state
        let currentEditingFile = null;
        let currentEditingType = null;
        let originalImage = null;
        let canvasContext = null;
        let overlayElements = [];
        let activeOverlayElement = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        // Drawing state
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let drawColor = '#ff1493';
        let drawSize = 5;
        
        // Video editing state
        let videoEditorElement = document.getElementById('editorVideo');
        let videoTrimStart = 0;
        let videoTrimEnd = 100;
        let videoDuration = 0;
        
        // Video settings
        const VIDEO_SETTINGS = {
            quality: 0.7,
            bitrate: 1000000,
            width: 640,
            height: 360
        };
        
        // Maximum quality image settings â€” full original resolution, lossless PNG
        const IMAGE_QUALITY = {
            quality: 1.0,
            format: 'image/png',    // PNG = zero compression loss
            maxWidth: 8192,
            maxHeight: 8192
        };
        
        // Gen Z messages
        const genZLoadingMessages = [
            "slaying your post... âœ¨",
            "making it aesthetic... ðŸ’…",
            "vibes loading... ðŸŽµ",
            "no cap, this post is fire... ðŸ”¥",
            "serving looks... ðŸ’",
            "main character energy loading... ðŸŽ¬",
            "it's giving post... ðŸ’«"
        ];

        const genZLoadingSubtexts = [
            "adding the âœ¨sparkleâœ¨",
            "no thoughts just vibes",
            "for the algorithm",
            "tea incoming â˜•",
            "iktr (i know that's right)",
            "periodt pooh"
        ];

        const genZRecordingPhrases = {
            video: [
                'dropping a video... ðŸŽ¥',
                'capturing the vibe... âœ¨',
                'shooting your main character moment... ðŸŽ¬',
                'video loading... no cap'
            ],
            audio: [
                'spitting facts... ðŸŽ¤',
                'dropping bars... ðŸŽµ',
                'fire audio incoming... ðŸ”¥',
                'recording thoughts... ðŸ’­'
            ]
        };

        const moodEmojis = {
            'slay': 'ðŸ’…',
            'vibing': 'ðŸŽµ',
            'sheesh': 'ðŸ¥¶',
            'periodt': 'â¸ï¸',
            'no-cap': 'ðŸŽ¯',
            'bussin': 'ðŸ”¥',
            'mid': 'ðŸ˜',
            'cringe': 'ðŸ˜¬'
        };

        const moodColors = {
            'slay': '#ff1493',
            'vibing': '#9933ff',
            'sheesh': '#00cc66',
            'periodt': '#ff6b00',
            'no-cap': '#ff4444',
            'bussin': '#ffd700',
            'mid': '#808080',
            'cringe': '#8b4513'
        };

        // =================== DOM Elements ===================
        const moodSelectorBtn = document.getElementById('moodSelectorBtn');
        const moodDropdown = document.getElementById('moodDropdown');
        const selectedMoodEmoji = document.getElementById('selectedMoodEmoji');
        const selectedMoodText = document.getElementById('selectedMoodText');
        const moodInput = document.getElementById('moodInput');
        const customMoodInput = document.getElementById('customMoodInput');
        const customMoodInputHidden = document.getElementById('customMoodInputHidden');
        const activeMoodBadge = document.getElementById('activeMoodBadge');
        const activeMoodEmoji = document.getElementById('activeMoodEmoji');
        const activeMoodText = document.getElementById('activeMoodText');
        
        const imageInput = document.getElementById('images');
        const imagePreviewGrid = document.getElementById('imagePreviewGrid');
        const videoFileInput = document.getElementById('video_file');
        const videoUploadInput = document.getElementById('video_file_upload');
        const audioFileInput = document.getElementById('audio_file');
        const audioUploadInput = document.getElementById('audio_file_upload');
        
        const cameraModal = document.getElementById('cameraModal');
        const cameraLive = document.getElementById('cameraLive');
        const capturedImageContainer = document.getElementById('capturedImageContainer');
        const capturedImage = document.getElementById('capturedImage');
        
        const videoRecorderModal = document.getElementById('videoRecorderModal');
        const videoLive = document.getElementById('videoLive');
        const videoRecordBtn = document.getElementById('videoRecordBtn');
        const recorderTimer = document.getElementById('recorderTimer');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const toggleMicBtn = document.getElementById('toggleMicBtn');
        const finishRecordingBtn = document.getElementById('finishRecordingBtn');
        const soundSelectionText = document.getElementById('soundSelectionText');
        const musicFileUpload = document.getElementById('music_file_upload');
        
        const videoPlayer = document.getElementById('videoPlayer');
        const videoElement = document.getElementById('videoElement');
        
        const audioPlayer = document.getElementById('audioPlayer');
        const playAudioBtn = document.getElementById('playAudioBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        const videoRecordingStatus = document.getElementById('videoRecordingStatus');
        const recordingTimeEl = document.getElementById('recordingTime');
        const videoRecordingTimeEl = document.getElementById('videoRecordingTime');
        const audioFilename = document.getElementById('audioFilename');
        const currentTimeEl = document.getElementById('currentTime');
        const durationTimeEl = document.getElementById('durationTime');
        const audioProgress = document.getElementById('audioProgress');
        const audioProgressFilled = document.getElementById('audioProgressFilled');
        
        const previewBox = document.getElementById('previewBox');
        const previewItem = document.getElementById('previewItem');
        const textarea = document.querySelector('textarea[name="content"]');
        const sharePostBtn = document.getElementById('sharePostBtn');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const loadingSubtext = document.getElementById('loadingSubtext');
        const fileSizeInfo = document.getElementById('fileSizeInfo');
        const vibeCheckBtn = document.getElementById('vibeCheckBtn');
        
        const mediaEditorModal = document.getElementById('mediaEditorModal');
        const editorCanvas = document.getElementById('editorCanvas');
        const editorCanvasContainer = document.getElementById('editorCanvasContainer');
        const editorTextInput = document.getElementById('editorTextInput');

        // =================== Utility Functions ===================
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function createFloatingEmoji(emoji, x, y) {
            const el = document.createElement('div');
            el.textContent = emoji;
            el.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                font-size: 24px;
                pointer-events: none;
                z-index: 9999;
                animation: floatEmoji 1s ease-out forwards;
            `;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function vibeVibrate(pattern = 10) {
            if (window.navigator && window.navigator.vibrate) {
                window.navigator.vibrate(pattern);
            }
        }

        function updateFileSizeDisplay() {
            let totalSize = 0;
            selectedImages.forEach(file => totalSize += file.size);
            if (currentVideoBlob) totalSize += currentVideoBlob.size;
            if (currentAudioBlob) totalSize += currentAudioBlob.size;
            
            if (totalSize > 0) {
                fileSizeInfo.textContent = `size: ${formatFileSize(totalSize)}`;
                if (totalSize > 50 * 1024 * 1024) {
                    fileSizeInfo.style.color = 'var(--ig-danger)';
                } else {
                    fileSizeInfo.style.color = 'var(--ig-text-light)';
                }
            } else {
                fileSizeInfo.textContent = '';
            }
        }

        function updatePreview() {
            const hasImages = selectedImages.length > 0;
            const hasVideo = currentVideoBlob !== null;
            const hasAudio = currentAudioBlob !== null;
            const hasText = textarea.value.trim().length > 0;
            const hasMood = selectedMood || selectedCustomMood;

            if (hasImages || hasVideo || hasAudio || hasText || hasMood) {
                previewBox.classList.add('has-content');
                
                if (hasImages) {
                    previewItem.textContent = `${selectedImages.length} photo${selectedImages.length > 1 ? 's' : ''} ðŸ“¸`;
                } else if (hasVideo) {
                    previewItem.textContent = `video ready ðŸŽ¥`;
                } else if (hasAudio) {
                    previewItem.textContent = `audio ready ðŸŽµ`;
                } else if (hasText) {
                    previewItem.textContent = `caption ready ðŸ’­`;
                } else if (hasMood) {
                    previewItem.textContent = `mood: ${selectedMood || selectedCustomMood} âœ¨`;
                }
            } else {
                previewBox.classList.remove('has-content');
                previewItem.textContent = 'nothing yet';
            }
            
            updateShareButtonState();
            updateFileSizeDisplay();
        }

        function updateShareButtonState() {
            const hasContent = textarea.value.trim().length > 0 || selectedImages.length > 0 || currentVideoBlob || currentAudioBlob;
            sharePostBtn.disabled = !hasContent;
        }

        // =================== Mood Functions ===================
        function toggleMoodDropdown() {
            moodDropdown.classList.toggle('show');
            moodSelectorBtn.classList.toggle('active');
        }

        function selectMood(mood, emoji, vibe) {
            selectedMood = mood;
            selectedCustomMood = null;
            
            selectedMoodEmoji.textContent = emoji;
            selectedMoodText.textContent = mood;
            moodInput.value = mood;
            customMoodInputHidden.value = '';
            
            activeMoodBadge.classList.remove('hidden');
            activeMoodEmoji.textContent = emoji;
            activeMoodText.textContent = mood;
            
            const color = moodColors[mood] || 'var(--ig-primary)';
            activeMoodBadge.style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
            
            moodDropdown.classList.remove('show');
            moodSelectorBtn.classList.remove('active');
            
            createFloatingEmoji(emoji, window.innerWidth/2, 100);
            vibeVibrate(20);
            
            updatePreview();
        }

        function setCustomMoodInput(value) {
            customMoodInput.value = value;
        }

        function addCustomMood() {
            const customMood = customMoodInput.value.trim();
            if (customMood) {
                selectedCustomMood = customMood;
                selectedMood = null;
                
                const emojiMatch = customMood.match(/([\u{1F300}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])$/u);
                const moodText = emojiMatch ? customMood.slice(0, -emojiMatch[0].length).trim() : customMood;
                const moodEmoji = emojiMatch ? emojiMatch[0] : 'âœ¨';
                
                selectedMoodEmoji.textContent = moodEmoji;
                selectedMoodText.textContent = moodText;
                moodInput.value = '';
                customMoodInputHidden.value = customMood;
                
                activeMoodBadge.classList.remove('hidden');
                activeMoodEmoji.textContent = moodEmoji;
                activeMoodText.textContent = moodText;
                activeMoodBadge.style.background = `linear-gradient(135deg, #0095f6, #00b8ff)`;
                
                customMoodInput.value = '';
                createFloatingEmoji(moodEmoji, window.innerWidth/2, 100);
                vibeVibrate(20);
                
                updatePreview();
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.kf-mood-dropdown-container')) {
                moodDropdown.classList.remove('show');
                moodSelectorBtn.classList.remove('active');
            }
        });

        // =================== CAMERA REAL-TIME EDITOR â€” Full Upgrade ===================

        // ---- State ----
        let cameraFilterLoop = null;
        let cameraActiveFilter = 'none';
        let cameraBeautyOn = false;
        let cameraTimer = 0;
        let cameraGridOn = false;
        let cameraMirrorForce = false;  // extra mirror toggle beyond front/back
        let camActiveFaceEffect = 'none';
        let camTextColor = '#ffffff';
        let camTextFont = 'system-ui';
        let camTextSize = 28;
        let camSelectedTextEl = null;

        // ---- Filter presets ----
        const CAM_FILTERS = [
            { id: 'none',     name: 'Normal',  css: '',                                                         swatch: 'linear-gradient(135deg,#f5f7fa,#c3cfe2)' },
            { id: 'vivid',    name: 'Vivid',   css: 'saturate(1.8) contrast(1.1)',                              swatch: 'linear-gradient(135deg,#f093fb,#f5576c)' },
            { id: 'cool',     name: 'Cool',    css: 'saturate(1.2) hue-rotate(20deg) brightness(1.05)',         swatch: 'linear-gradient(135deg,#4facfe,#00f2fe)' },
            { id: 'warm',     name: 'Warm',    css: 'saturate(1.3) hue-rotate(-15deg) brightness(1.05)',        swatch: 'linear-gradient(135deg,#f6d365,#fda085)' },
            { id: 'mono',     name: 'Mono',    css: 'grayscale(1)',                                             swatch: 'linear-gradient(135deg,#bdc3c7,#2c3e50)' },
            { id: 'fade',     name: 'Fade',    css: 'brightness(1.1) saturate(0.7) contrast(0.85)',             swatch: 'linear-gradient(135deg,#e0e0e0,#a8b8d8)' },
            { id: 'drama',    name: 'Drama',   css: 'contrast(1.4) saturate(1.2) brightness(0.9)',              swatch: 'linear-gradient(135deg,#2c3e50,#4ca1af)' },
            { id: 'golden',   name: 'Golden',  css: 'sepia(0.6) saturate(1.4) brightness(1.05)',                swatch: 'linear-gradient(135deg,#f7971e,#ffd200)' },
            { id: 'neon',     name: 'Neon',    css: 'saturate(2.5) contrast(1.3) hue-rotate(30deg)',            swatch: 'linear-gradient(135deg,#f72585,#4361ee)' },
            { id: 'retro',    name: 'Retro',   css: 'sepia(0.4) contrast(1.1) saturate(1.3) hue-rotate(-10deg)',swatch: 'linear-gradient(135deg,#c79081,#dfa579)' },
            { id: 'film',     name: 'Film',    css: 'contrast(1.2) saturate(0.9) brightness(0.95)',             swatch: 'linear-gradient(135deg,#434343,#000000)' },
            { id: 'pastel',   name: 'Pastel',  css: 'saturate(0.6) brightness(1.15) contrast(0.9)',             swatch: 'linear-gradient(135deg,#fbc2eb,#a6c1ee)' },
            { id: 'cyber',    name: 'Cyber',   css: 'hue-rotate(180deg) saturate(2) contrast(1.2)',             swatch: 'linear-gradient(135deg,#00d2ff,#3a7bd5)' },
            { id: 'summer',   name: 'Summer',  css: 'brightness(1.1) saturate(1.5) hue-rotate(-20deg)',         swatch: 'linear-gradient(135deg,#f9d423,#ff4e50)' },
            { id: 'noir',     name: 'Noir',    css: 'grayscale(1) contrast(1.5) brightness(0.85)',              swatch: 'linear-gradient(135deg,#000000,#434343)' },
            { id: 'glitch',   name: 'Glitch',  css: 'hue-rotate(90deg) saturate(3) contrast(1.5)',              swatch: 'linear-gradient(135deg,#00f260,#0575e6)' },
            { id: 'lofi',     name: 'Lo-fi',   css: 'sepia(0.8) contrast(0.9) saturate(0.6) brightness(0.95)', swatch: 'linear-gradient(135deg,#8360c3,#2ebf91)' },
            { id: 'vhs',      name: 'VHS',     css: 'contrast(1.1) saturate(1.4) hue-rotate(-5deg)',            swatch: 'linear-gradient(135deg,#fc5c7d,#6a3093)' },
        ];

        // ---- Face effects definitions ----
        const CAM_FACE_EFFECTS = [
            { id: 'none',       name: 'None',       emoji: 'ðŸš«', overlay: null },
            { id: 'dog',        name: 'Dog',        emoji: 'ðŸ¶', overlay: { ears: 'ðŸ¾', nose: 'ðŸ½', tongue: 'ðŸ‘…' } },
            { id: 'cat',        name: 'Cat',        emoji: 'ðŸ±', overlay: { ears: 'ðŸ±', nose: 'ðŸ‘ƒ', whiskers: true } },
            { id: 'bunny',      name: 'Bunny',      emoji: 'ðŸ°', overlay: { ears: 'ðŸ°' } },
            { id: 'hearts',     name: 'Hearts',     emoji: 'ðŸ’•', overlay: { eyes: 'ðŸ’•' } },
            { id: 'sunglasses', name: 'Drip',       emoji: 'ðŸ˜Ž', overlay: { glasses: 'ðŸ˜Ž' } },
            { id: 'crown',      name: 'Crown',      emoji: 'ðŸ‘‘', overlay: { top: 'ðŸ‘‘' } },
            { id: 'flowers',    name: 'Bloom',      emoji: 'ðŸŒ¸', overlay: { top: 'ðŸŒ¸', sides: 'ðŸŒ¼' } },
            { id: 'fire',       name: 'Fire',       emoji: 'ðŸ”¥', overlay: { effect: 'fire' } },
            { id: 'sparkle',    name: 'Sparkle',    emoji: 'âœ¨', overlay: { effect: 'sparkle' } },
            { id: 'rainbow',    name: 'Rainbow',    emoji: 'ðŸŒˆ', overlay: { top: 'ðŸŒˆ' } },
            { id: 'alien',      name: 'Alien',      emoji: 'ðŸ‘½', overlay: { effect: 'alien' } },
            { id: 'ghost',      name: 'Ghost',      emoji: 'ðŸ‘»', overlay: { eyes: 'ðŸ‘»' } },
            { id: 'star',       name: 'Star',       emoji: 'â­', overlay: { eyes: 'â­' } },
        ];

        // ---- Font options ----
        const CAM_FONTS = [
            { name: 'Default',   font: 'system-ui, sans-serif' },
            { name: 'Pacifico',  font: 'Pacifico, cursive' },
            { name: 'Bangers',   font: 'Bangers, cursive' },
            { name: 'Press',     font: "'Press Start 2P', monospace" },
            { name: 'Dance',     font: "'Dancing Script', cursive" },
            { name: 'Righteous', font: 'Righteous, sans-serif' },
            { name: 'Mono',      font: 'monospace' },
            { name: 'Serif',     font: 'Georgia, serif' },
        ];

        // ---- Color palette ----
        const CAM_COLORS = ['#ffffff','#000000','#fe2c55','#25f4ee','#ffd700','#00ff88','#ff6b35','#a855f7','#3b82f6','#f97316','#ec4899','#84cc16'];

        // ---- Sticker categories ----
        const CAM_STICKERS = {
            'ðŸ”¥ Hot': ['ðŸ”¥','ðŸ’¯','âœ¨','âš¡','ðŸ’¥','ðŸŽ¯','ðŸ‘‘','ðŸ¥µ','ðŸ˜¤','ðŸ’ª','ðŸ¤™','ðŸ«¶'],
            'ðŸ˜‚ Vibes': ['ðŸ˜‚','ðŸ¤£','ðŸ’€','ðŸ˜­','ðŸ¥´','ðŸ˜©','ðŸ¤¦','ðŸ« ','ðŸ˜Ž','ðŸ¤¯','ðŸ¤©','ðŸ¥³'],
            'ðŸ’• Love': ['ðŸ’•','ðŸ’–','â¤ï¸â€ðŸ”¥','ðŸ’˜','ðŸ«€','ðŸ’','ðŸ©·','ðŸ©µ','ðŸ’œ','ðŸ–¤','ðŸ¤','ðŸ¤Ž'],
            'ðŸŒˆ Fun': ['ðŸŒˆ','ðŸŽ‰','ðŸŽŠ','ðŸŽˆ','ðŸ¿','ðŸŽ®','ðŸ•¹ï¸','ðŸ¦„','ðŸŒŸ','ðŸ’«','ðŸª©','ðŸŽ­'],
            'ðŸŒ¿ Nature': ['ðŸŒ¸','ðŸŒº','ðŸŒ»','ðŸŒ¹','ðŸ€','ðŸŒ¿','ðŸ¦‹','ðŸ','ðŸŒŠ','â›…','ðŸŒ™','â­'],
            'âœï¸ Symbols': ['ðŸ’¯','ðŸŽ¯','âœ…','âŒ','ðŸ”‘','ðŸ’¡','ðŸš€','âš ï¸','ðŸ”®','ðŸ§¿','â˜¯ï¸','âœŒï¸'],
        };

        // ==============================
        // Build UI elements
        // ==============================
        function buildCameraFilterThumbs() {
            const row = document.getElementById('cameraFiltersRow');
            if (!row) return;
            row.innerHTML = '';
            CAM_FILTERS.forEach(f => {
                const item = document.createElement('div');
                item.className = 'kf-cam-filter-item' + (f.id === cameraActiveFilter ? ' active' : '');
                item.id = 'camFI_' + f.id;
                item.onclick = () => selectCameraFilter(f.id);
                item.innerHTML = `
                    <div class="kf-cam-filter-thumb">
                        <div class="kf-cam-filter-thumb-bg" style="background:${f.swatch};filter:${f.css||'none'};"></div>
                    </div>
                    <span class="kf-cam-filter-label">${f.name}</span>`;
                row.appendChild(item);
            });
        }

        function buildCameraFacePanel() {
            const row = document.getElementById('camFaceRow');
            if (!row) return;
            row.innerHTML = '';
            CAM_FACE_EFFECTS.forEach(e => {
                const item = document.createElement('div');
                item.className = 'kf-cam-face-item' + (e.id === camActiveFaceEffect ? ' active' : '');
                item.id = 'camFE_' + e.id;
                item.onclick = () => selectFaceEffect(e.id);
                item.innerHTML = `<div class="kf-cam-face-icon">${e.emoji}</div><span class="kf-cam-face-label">${e.name}</span>`;
                row.appendChild(item);
            });
        }

        function buildCameraTextPanel() {
            // Fonts
            const fontRow = document.getElementById('camFontRow');
            if (fontRow) {
                fontRow.innerHTML = '';
                CAM_FONTS.forEach(f => {
                    const btn = document.createElement('button');
                    btn.className = 'kf-cam-font-btn' + (camTextFont === f.font ? ' active' : '');
                    btn.style.fontFamily = f.font;
                    btn.textContent = f.name;
                    btn.id = 'camFont_' + f.name;
                    btn.onclick = () => { camTextFont = f.font; document.querySelectorAll('.kf-cam-font-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); };
                    fontRow.appendChild(btn);
                });
            }
            // Colors
            const colorRow = document.getElementById('camColorRow');
            if (colorRow) {
                colorRow.innerHTML = '';
                CAM_COLORS.forEach(c => {
                    const dot = document.createElement('div');
                    dot.className = 'kf-cam-color-dot' + (camTextColor === c ? ' active' : '');
                    dot.style.background = c;
                    if (c === '#ffffff') dot.style.boxShadow = '0 0 0 1px rgba(255,255,255,0.3)';
                    dot.onclick = () => { camTextColor = c; document.querySelectorAll('.kf-cam-color-dot').forEach(d=>d.classList.remove('active')); dot.classList.add('active'); };
                    colorRow.appendChild(dot);
                });
                // Custom color picker
                const picker = document.createElement('input');
                picker.type = 'color'; picker.value = camTextColor;
                picker.style.cssText = 'width:28px;height:28px;border-radius:50%;border:2px solid rgba(255,255,255,0.4);cursor:pointer;padding:0;background:none;flex-shrink:0;';
                picker.oninput = e => { camTextColor = e.target.value; document.querySelectorAll('.kf-cam-color-dot').forEach(d=>d.classList.remove('active')); };
                colorRow.appendChild(picker);
            }
        }

        function buildCameraStickers() {
            const catsEl = document.getElementById('camStickerCats');
            const gridEl = document.getElementById('camStickerGrid');
            if (!catsEl || !gridEl) return;
            const cats = Object.keys(CAM_STICKERS);
            catsEl.innerHTML = '';
            cats.forEach((cat, i) => {
                const btn = document.createElement('div');
                btn.className = 'kf-cam-sticker-cat' + (i === 0 ? ' active' : '');
                btn.textContent = cat;
                btn.onclick = () => {
                    document.querySelectorAll('.kf-cam-sticker-cat').forEach(b=>b.classList.remove('active'));
                    btn.classList.add('active');
                    renderStickerGrid(cat);
                };
                catsEl.appendChild(btn);
            });
            renderStickerGrid(cats[0]);
        }

        function renderStickerGrid(cat) {
            const grid = document.getElementById('camStickerGrid');
            if (!grid) return;
            grid.innerHTML = '';
            (CAM_STICKERS[cat]||[]).forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = 'kf-cam-sticker-btn';
                btn.textContent = emoji;
                btn.onclick = () => addCameraSticker(emoji);
                grid.appendChild(btn);
            });
        }

        // ==============================
        // Panel switching
        // ==============================
        function switchCamPanel(panelName, tabEl) {
            document.querySelectorAll('.kf-cam-sub-panel').forEach(p => p.classList.remove('show'));
            document.querySelectorAll('.kf-cam-mode-tab').forEach(t => t.classList.remove('active'));
            const panel = document.getElementById('camPanel' + panelName);
            if (panel) panel.classList.add('show');
            if (tabEl) tabEl.classList.add('active');
        }

        // ==============================
        // Filter logic
        // ==============================
        function selectCameraFilter(filterId) {
            cameraActiveFilter = filterId;
            document.querySelectorAll('.kf-cam-filter-item').forEach(el => el.classList.remove('active'));
            const el = document.getElementById('camFI_' + filterId);
            if (el) el.classList.add('active');
        }

        function getFullCameraFilter() {
            const preset = CAM_FILTERS.find(f => f.id === cameraActiveFilter) || CAM_FILTERS[0];
            const b = parseFloat(document.getElementById('camBrightness')?.value || 100);
            const c = parseFloat(document.getElementById('camContrast')?.value || 100);
            const s = parseFloat(document.getElementById('camSaturation')?.value || 100);
            const blur = parseFloat(document.getElementById('camBlur')?.value || 0);
            const hue = parseFloat(document.getElementById('camHue')?.value || 0);
            let parts = [];
            if (b !== 100) parts.push(`brightness(${b/100})`);
            if (c !== 100) parts.push(`contrast(${c/100})`);
            if (s !== 100) parts.push(`saturate(${s/100})`);
            if (blur > 0)  parts.push(`blur(${blur}px)`);
            if (hue > 0)   parts.push(`hue-rotate(${hue}deg)`);
            if (preset.css) parts.push(preset.css);
            if (cameraBeautyOn) parts.push('brightness(1.08) contrast(0.92) saturate(1.15)');
            return parts.join(' ') || 'none';
        }

        function updateCameraFilter() {
            const map = [
                ['camBrightness','camBrightnessVal', v=>Math.round(v-100)],
                ['camContrast',  'camContrastVal',   v=>Math.round(v-100)],
                ['camSaturation','camSaturationVal', v=>Math.round(v-100)],
                ['camWarmth',    'camWarmthVal',      v=>Math.round(v)],
                ['camFade',      'camFadeVal',        v=>Math.round(v)],
                ['camBlur',      'camBlurVal',        v=>v],
                ['camVignette',  'camVignetteVal',    v=>Math.round(v)],
                ['camHue',       'camHueVal',         v=>Math.round(v)+'Â°'],
            ];
            map.forEach(([sid,vid,fn])=>{
                const s=document.getElementById(sid), v=document.getElementById(vid);
                if(s&&v) v.textContent=fn(parseFloat(s.value));
            });
        }

        // ==============================
        // Real-time filter render loop
        // ==============================
        function startCameraFilterLoop() {
            stopCameraFilterLoop();
            const canvas = document.getElementById('cameraFilterCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            function renderFrame() {
                if (!cameraLive || !cameraStream) return;
                const vw = cameraLive.videoWidth, vh = cameraLive.videoHeight;
                if (!vw || !vh) { cameraFilterLoop = requestAnimationFrame(renderFrame); return; }

                const container = document.getElementById('camPreviewArea');
                const cw = container.offsetWidth, ch = container.offsetHeight;
                canvas.width = cw; canvas.height = ch;

                ctx.clearRect(0, 0, cw, ch);
                ctx.filter = getFullCameraFilter();

                // Cover-fit the video
                const vAspect = vw/vh, cAspect = cw/ch;
                let dw, dh, dx, dy;
                if (vAspect > cAspect) { dh=ch; dw=ch*vAspect; } else { dw=cw; dh=cw/vAspect; }
                dx=(cw-dw)/2; dy=(ch-dh)/2;

                const shouldMirror = isFrontCameraCamera !== cameraMirrorForce; // XOR
                if (shouldMirror) {
                    ctx.save(); ctx.translate(cw,0); ctx.scale(-1,1);
                    ctx.drawImage(cameraLive, cw-dx-dw, dy, dw, dh);
                    ctx.restore();
                } else {
                    ctx.drawImage(cameraLive, dx, dy, dw, dh);
                }
                ctx.filter = 'none';

                // Vignette
                const vig = parseFloat(document.getElementById('camVignette')?.value||0);
                if (vig>0) {
                    const g = ctx.createRadialGradient(cw/2,ch/2,ch*0.28,cw/2,ch/2,ch*0.85);
                    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,`rgba(0,0,0,${vig/100})`);
                    ctx.fillStyle=g; ctx.fillRect(0,0,cw,ch);
                }
                // Warmth tint
                const warm = parseFloat(document.getElementById('camWarmth')?.value||0);
                if (warm>0) { ctx.fillStyle=`rgba(255,140,0,${warm/300})`; ctx.fillRect(0,0,cw,ch); }
                else if (warm<0) { ctx.fillStyle=`rgba(0,100,255,${Math.abs(warm)/300})`; ctx.fillRect(0,0,cw,ch); }
                // Fade
                const fade = parseFloat(document.getElementById('camFade')?.value||0);
                if (fade>0) { ctx.fillStyle=`rgba(255,255,255,${fade/200})`; ctx.fillRect(0,0,cw,ch); }

                // Face effect emoji overlay
                drawFaceEffectOnCanvas(ctx, cw, ch);

                cameraFilterLoop = requestAnimationFrame(renderFrame);
            }
            requestAnimationFrame(renderFrame);
        }

        function stopCameraFilterLoop() {
            if (cameraFilterLoop) { cancelAnimationFrame(cameraFilterLoop); cameraFilterLoop = null; }
        }

        // ==============================
        // Face effects (emoji overlay on canvas)
        // ==============================
        function selectFaceEffect(id) {
            camActiveFaceEffect = id;
            document.querySelectorAll('.kf-cam-face-item').forEach(e=>e.classList.remove('active'));
            const el=document.getElementById('camFE_'+id);
            if(el) el.classList.add('active');
        }

        // Face effect drawing â€” animated emoji overlays
        let faceEffectTick = 0;
        function drawFaceEffectOnCanvas(ctx, cw, ch) {
            if (camActiveFaceEffect === 'none') return;
            faceEffectTick++;
            const e = CAM_FACE_EFFECTS.find(x=>x.id===camActiveFaceEffect);
            if (!e || !e.overlay) return;

            ctx.save();
            // Center face estimation (simple: center-upper region)
            const fx = cw/2, fy = ch * 0.3, fs = Math.min(cw,ch)*0.18;

            const drawEmoji = (emoji, x, y, size, rot=0) => {
                ctx.save();
                ctx.translate(x, y);
                if(rot) ctx.rotate(rot);
                ctx.font = `${size}px serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(emoji, 0, 0);
                ctx.restore();
            };

            const ov = e.overlay;

            if(ov.top)   drawEmoji(ov.top, fx, fy - fs*1.6, fs*1.4);
            if(ov.sides) {
                drawEmoji(ov.sides, fx - fs*1.5, fy - fs*0.4, fs*0.9, -0.2);
                drawEmoji(ov.sides, fx + fs*1.5, fy - fs*0.4, fs*0.9, 0.2);
            }
            if(ov.eyes) {
                drawEmoji(ov.eyes, fx - fs*0.55, fy - fs*0.1, fs*0.7);
                drawEmoji(ov.eyes, fx + fs*0.55, fy - fs*0.1, fs*0.7);
            }
            if(ov.nose)  drawEmoji(ov.nose, fx, fy + fs*0.25, fs*0.6);
            if(ov.tongue) drawEmoji(ov.tongue, fx, fy + fs*0.85, fs*0.65);
            if(ov.ears) {
                drawEmoji(ov.ears, fx - fs*0.7, fy - fs*1.5, fs*1.1, -0.15);
                drawEmoji(ov.ears, fx + fs*0.7, fy - fs*1.5, fs*1.1, 0.15);
            }
            if(ov.whiskers) {
                ctx.save(); ctx.globalAlpha=0.8; ctx.strokeStyle='rgba(255,255,255,0.8)'; ctx.lineWidth=1.5;
                for(let s of [-1,1]) {
                    for(let r of [-0.15,0,0.15]) {
                        ctx.beginPath(); ctx.moveTo(fx+s*fs*0.15, fy+fs*0.3);
                        ctx.lineTo(fx+s*fs*1.3, fy+fs*0.3+r*fs*0.4); ctx.stroke();
                    }
                }
                ctx.restore();
            }
            if(ov.glasses) drawEmoji('ðŸ•¶ï¸', fx, fy, fs*1.4);

            if(ov.effect === 'sparkle') {
                const sparkles=['âœ¨','â­','ðŸ’«'];
                for(let i=0;i<5;i++){
                    const angle = (faceEffectTick*0.05 + i*Math.PI*2/5);
                    const r = fs*2.2 + Math.sin(faceEffectTick*0.08+i)*fs*0.3;
                    drawEmoji(sparkles[i%sparkles.length], fx+Math.cos(angle)*r, fy+Math.sin(angle)*r*0.6, fs*0.7);
                }
            }
            if(ov.effect === 'fire') {
                const fires=['ðŸ”¥','ðŸŒ‹','ðŸ’¥'];
                for(let i=0;i<4;i++){
                    const ox = (i-1.5)*fs*0.9;
                    const oy = -fs*1.6 - Math.abs(Math.sin(faceEffectTick*0.1+i))*fs*0.5;
                    drawEmoji(fires[i%fires.length], fx+ox, fy+oy, fs*0.95);
                }
            }
            if(ov.effect === 'alien') {
                ctx.save(); ctx.globalAlpha=0.35+0.15*Math.sin(faceEffectTick*0.06);
                ctx.fillStyle='rgba(0,255,80,0.5)'; ctx.fillRect(0,0,cw,ch); ctx.restore();
                drawEmoji('ðŸ‘½', fx, fy, fs*1.3);
            }
            ctx.restore();
        }

        // ==============================
        // Text overlay management
        // ==============================
        function addCameraText() {
            const input = document.getElementById('camTextInput');
            const text = input?.value?.trim();
            if (!text) { input?.focus(); return; }

            const layer = document.getElementById('camTextLayer');
            if (!layer) return;

            const el = document.createElement('div');
            el.className = 'cam-overlay-text';
            el.style.cssText = `
                position:absolute; color:${camTextColor}; font-family:${camTextFont};
                font-size:${camTextSize}px; font-weight:bold;
                text-shadow:1px 1px 4px rgba(0,0,0,0.85);
                left:50%; top:40%; transform:translate(-50%,-50%);
                cursor:move; user-select:none; touch-action:none;
                padding:6px 10px; border:1.5px dashed rgba(255,255,255,0.5);
                border-radius:6px; white-space:nowrap; pointer-events:auto; z-index:15;
            `;
            el.textContent = text;

            // Delete button
            const del = document.createElement('div');
            del.className = 'cam-text-del';
            del.innerHTML = 'âœ•';
            del.style.cssText = 'position:absolute;top:-12px;right:-12px;width:22px;height:22px;background:#fe2c55;border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:10px;cursor:pointer;z-index:20;border:2px solid white;opacity:0;transition:opacity 0.15s;';
            del.onclick = (ev) => { ev.stopPropagation(); el.remove(); };
            el.appendChild(del);

            // Make draggable
            makeDraggable(el, layer);

            // Select on tap
            el.addEventListener('pointerdown', (ev) => {
                if(ev.target === del) return;
                selectTextEl(el);
            });

            layer.style.pointerEvents = 'auto';
            layer.appendChild(el);
            selectTextEl(el);

            if (input) { input.value = ''; }
            createFloatingEmoji('âœ¨', window.innerWidth/2, window.innerHeight/2);
        }

        function selectTextEl(el) {
            if (camSelectedTextEl) {
                camSelectedTextEl.classList.remove('selected');
                const d = camSelectedTextEl.querySelector('.cam-text-del');
                if(d) d.style.opacity='0';
            }
            camSelectedTextEl = el;
            el.classList.add('selected');
            const d = el.querySelector('.cam-text-del');
            if(d) d.style.opacity='1';
        }

        function deselectCameraText() {
            if (camSelectedTextEl) {
                camSelectedTextEl.classList.remove('selected');
                const d = camSelectedTextEl.querySelector('.cam-text-del');
                if(d) d.style.opacity='0';
                camSelectedTextEl = null;
            }
        }

        function updateCamTextPreview() {
            const sz = document.getElementById('camTextSize');
            const val = document.getElementById('camTextSizeVal');
            if(sz && val) { camTextSize = parseInt(sz.value); val.textContent = camTextSize + 'px'; }
            if(camSelectedTextEl) camSelectedTextEl.style.fontSize = camTextSize + 'px';
        }

        function makeDraggable(el, container) {
            let startX, startY, elX, elY, isDragging=false;
            const getXY = e => e.touches ? {x:e.touches[0].clientX,y:e.touches[0].clientY} : {x:e.clientX,y:e.clientY};

            el.addEventListener('pointerdown', e => {
                if(e.target.classList.contains('cam-text-del')) return;
                isDragging = true;
                const {x,y} = getXY(e);
                const rect = el.getBoundingClientRect();
                startX = x - rect.left + el.offsetWidth/2;
                startY = y - rect.top + el.offsetHeight/2;
                el.style.transition = 'none';
                el.setPointerCapture(e.pointerId);
            });
            el.addEventListener('pointermove', e => {
                if (!isDragging) return;
                const {x,y} = getXY(e);
                const cr = container.getBoundingClientRect();
                let nx = x - cr.left;
                let ny = y - cr.top;
                el.style.left = nx + 'px';
                el.style.top = ny + 'px';
                el.style.transform = 'translate(-50%,-50%)';
            });
            el.addEventListener('pointerup', () => { isDragging = false; });
        }

        // ==============================
        // Stickers on canvas
        // ==============================
        function addCameraSticker(emoji) {
            const layer = document.getElementById('camTextLayer');
            if (!layer) return;
            const el = document.createElement('div');
            el.className = 'cam-overlay-text';
            el.style.cssText = `
                position:absolute; font-size:48px; font-family:serif;
                left:50%; top:45%; transform:translate(-50%,-50%);
                cursor:move; user-select:none; touch-action:none;
                padding:4px; border:1.5px dashed rgba(255,255,255,0.4);
                border-radius:6px; white-space:nowrap; pointer-events:auto; z-index:15;
            `;
            el.textContent = emoji;
            const del = document.createElement('div');
            del.innerHTML='âœ•';
            del.style.cssText='position:absolute;top:-12px;right:-12px;width:22px;height:22px;background:#fe2c55;border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:10px;cursor:pointer;z-index:20;border:2px solid white;opacity:0;transition:opacity 0.15s;';
            del.onclick = ev => { ev.stopPropagation(); el.remove(); };
            el.appendChild(del);
            makeDraggable(el, layer);
            el.addEventListener('pointerdown', ev => { if(ev.target===del)return; selectTextEl(el); });
            layer.style.pointerEvents = 'auto';
            layer.appendChild(el);
            selectTextEl(el);
            createFloatingEmoji(emoji, window.innerWidth/2, window.innerHeight/2);
        }

        // ==============================
        // Toggle buttons
        // ==============================
        function toggleCameraBeauty() {
            cameraBeautyOn = !cameraBeautyOn;
            const btn = document.getElementById('camBeautyBtn');
            if(btn) btn.classList.toggle('active', cameraBeautyOn);
        }

        function toggleCameraGrid() {
            cameraGridOn = !cameraGridOn;
            const g = document.getElementById('cameraGrid');
            const btn = document.getElementById('camGridBtn');
            if(g) g.style.display = cameraGridOn ? 'block' : 'none';
            if(btn) btn.classList.toggle('active', cameraGridOn);
        }

        function toggleCameraMirror() {
            cameraMirrorForce = !cameraMirrorForce;
            const btn = document.getElementById('camMirrorBtn');
            if(btn) btn.classList.toggle('active', cameraMirrorForce);
        }

        const TIMER_OPTIONS = [0,3,5,10];
        function toggleCameraTimer() {
            const idx = TIMER_OPTIONS.indexOf(cameraTimer);
            cameraTimer = TIMER_OPTIONS[(idx+1) % TIMER_OPTIONS.length];
            const label = document.getElementById('camTimerLabel');
            const btn   = document.getElementById('camTimerBtn');
            if(label) label.textContent = cameraTimer===0 ? 'OFF' : `${cameraTimer}s`;
            if(btn) btn.classList.toggle('active', cameraTimer>0);
        }

        function resetCameraEdits() {
            cameraActiveFilter = 'none';
            cameraBeautyOn = false;
            cameraMirrorForce = false;
            camActiveFaceEffect = 'none';
            ['camBrightness','camContrast','camSaturation'].forEach(id => { const el=document.getElementById(id); if(el) el.value=100; });
            ['camWarmth','camFade','camVignette','camHue'].forEach(id => { const el=document.getElementById(id); if(el) el.value=0; });
            const bl=document.getElementById('camBlur'); if(bl) bl.value=0;
            updateCameraFilter();
            buildCameraFilterThumbs();
            buildCameraFacePanel();
            // Clear text layer
            const layer = document.getElementById('camTextLayer');
            if(layer) layer.innerHTML='';
            camSelectedTextEl = null;
        }

        // ==============================
        // Save to device
        // ==============================
        function savePhotoToDevice() {
            const src = document.getElementById('capturedImage')?.src;
            if (!src) return;
            const a = document.createElement('a');
            a.href = src;
            a.download = `kishiface_snap_${Date.now()}.jpg`;
            a.click();
            createFloatingEmoji('ðŸ’¾', window.innerWidth/2, 100);
            vibeVibrate(30);
        }

        // ==============================
        // Camera core functions
        // ==============================
        async function openCamera() {
            cameraModal.classList.add('active');
            capturedImageContainer.classList.add('hidden');
            // Deselect any text overlay
            camSelectedTextEl = null;
            const layer = document.getElementById('camTextLayer');
            if(layer) layer.innerHTML='';
            // Build all panels
            buildCameraFilterThumbs();
            buildCameraFacePanel();
            buildCameraTextPanel();
            buildCameraStickers();
            updateCameraFilter();
            await startCameraPreview();
        }

        function closeCamera() {
            stopCameraFilterLoop();
            cameraModal.classList.remove('active');
            if (cameraStream) { cameraStream.getTracks().forEach(t=>t.stop()); cameraStream=null; }
        }

        async function startCameraPreview() {
            try {
                const btn = document.getElementById('cameraCaptureBtn');
                if(btn) { btn.disabled=true; btn.style.opacity='0.4'; }

                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: isFrontCameraCamera ? 'user' : 'environment', width:{ideal:4096}, height:{ideal:4096} }
                });
                cameraLive.srcObject = cameraStream;
                await new Promise(res => {
                    if(cameraLive.readyState>=1) cameraLive.play().then(res).catch(res);
                    else cameraLive.onloadedmetadata = () => cameraLive.play().then(res).catch(res);
                });
                if(btn) { btn.disabled=false; btn.style.opacity='1'; }
                startCameraFilterLoop();
            } catch(err) {
                console.error('Camera error:', err);
                showAlert('camera access','Camera access is required to take photos.','ðŸ“·',[{text:'got it',type:'primary'}]);
                closeCamera();
            }
        }

        async function flipCamera() {
            isFrontCameraCamera = !isFrontCameraCamera;
            if (cameraStream) {
                stopCameraFilterLoop();
                cameraStream.getTracks().forEach(t=>t.stop());
                await startCameraPreview();
            }
        }

        async function capturePhotoWithFilters() {
            // Timer
            if (cameraTimer > 0) {
                const cd = document.getElementById('camTimerCountdown');
                if(cd) {
                    cd.style.display='block';
                    let t = cameraTimer;
                    cd.textContent = t;
                    vibeVibrate(40);
                    await new Promise(res => {
                        const iv = setInterval(()=>{
                            t--;
                            if(t<=0){clearInterval(iv); res();}
                            else { cd.textContent=t; vibeVibrate(25); }
                        },1000);
                    });
                    cd.style.display='none';
                }
            }

            // Flash
            const flash = document.getElementById('cameraFlash');
            if(flash){flash.classList.add('flash'); setTimeout(()=>flash.classList.remove('flash'),180);}

            // Render to offscreen canvas at native resolution
            const W = cameraLive.videoWidth, H = cameraLive.videoHeight;
            const off = document.createElement('canvas'); off.width=W; off.height=H;
            const ctx = off.getContext('2d');

            ctx.filter = getFullCameraFilter();
            const shouldMirror = isFrontCameraCamera !== cameraMirrorForce;
            if(shouldMirror){ctx.translate(W,0);ctx.scale(-1,1);}
            ctx.drawImage(cameraLive,0,0,W,H);
            ctx.filter='none'; if(shouldMirror){ctx.setTransform(1,0,0,1,0,0);}

            // Vignette
            const vig=parseFloat(document.getElementById('camVignette')?.value||0);
            if(vig>0){const g=ctx.createRadialGradient(W/2,H/2,H*0.28,W/2,H/2,H*0.85);g.addColorStop(0,'rgba(0,0,0,0)');g.addColorStop(1,`rgba(0,0,0,${vig/100})`);ctx.fillStyle=g;ctx.fillRect(0,0,W,H);}
            // Warmth
            const warm=parseFloat(document.getElementById('camWarmth')?.value||0);
            if(warm>0){ctx.fillStyle=`rgba(255,140,0,${warm/300})`;ctx.fillRect(0,0,W,H);}
            else if(warm<0){ctx.fillStyle=`rgba(0,100,255,${Math.abs(warm)/300})`;ctx.fillRect(0,0,W,H);}
            // Fade
            const fade=parseFloat(document.getElementById('camFade')?.value||0);
            if(fade>0){ctx.fillStyle=`rgba(255,255,255,${fade/200})`;ctx.fillRect(0,0,W,H);}

            // Bake text/sticker overlays
            const camPreview = document.getElementById('camPreviewArea');
            const previewRect = camPreview.getBoundingClientRect();
            const scaleX = W / previewRect.width;
            const scaleY = H / previewRect.height;
            const layer = document.getElementById('camTextLayer');
            if(layer) {
                Array.from(layer.children).forEach(el => {
                    const r = el.getBoundingClientRect();
                    const ex = (r.left + r.width/2 - previewRect.left) * scaleX;
                    const ey = (r.top + r.height/2 - previewRect.top) * scaleY;
                    const txt = el.childNodes[0]?.textContent?.trim() || '';
                    if(!txt) return;
                    const style = window.getComputedStyle(el);
                    const fs = parseFloat(style.fontSize) * scaleX;
                    ctx.font = `bold ${fs}px ${style.fontFamily}`;
                    ctx.fillStyle = style.color;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = fs*0.08;
                    ctx.fillText(txt, ex, ey);
                    ctx.shadowBlur=0;
                });
            }

            off.toBlob(blob => {
                capturedPhotoBlob = blob;
                const url = URL.createObjectURL(blob);
                capturedImage.src = url;
                capturedImageContainer.classList.remove('hidden');
                stopCameraFilterLoop();
                if(cameraStream){cameraStream.getTracks().forEach(t=>t.stop());cameraStream=null;}
                createFloatingEmoji('ðŸ“¸', window.innerWidth/2, 100);
                vibeVibrate(60);
            }, IMAGE_QUALITY.format, IMAGE_QUALITY.quality);
        }

        function capturePhoto() { capturePhotoWithFilters(); }

        function retakePhoto() {
            capturedImageContainer.classList.add('hidden');
            capturedPhotoBlob = null;
            startCameraPreview();
        }

        function keepPhoto() {
            if(capturedPhotoBlob) {
                const file = new File([capturedPhotoBlob], `kishiface_snap_${Date.now()}.jpg`, {type: IMAGE_QUALITY.format});
                selectedImages = [...selectedImages, file];
                const dt = new DataTransfer();
                selectedImages.forEach(f=>dt.items.add(f));
                imageInput.files = dt.files;
                renderImagePreviews();
                updatePreview();
                updateFileSizeDisplay();
                closeCamera();
                createFloatingEmoji('ðŸ’¾', window.innerWidth/2, 100);
                vibeVibrate(25);
            }
        }

        // =================== Image Functions ===================
        function handleImageSelect(input) {
            const files = Array.from(input.files);
            selectedImages = [...selectedImages, ...files];
            renderImagePreviews();
            updatePreview();
            updateFileSizeDisplay();
            
            createFloatingEmoji('ðŸ“¸', window.innerWidth/2, 100);
            vibeVibrate(20);
        }

        function renderImagePreviews() {
            imagePreviewGrid.innerHTML = '';
            selectedImages.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const div = document.createElement('div');
                    div.className = 'kf-image-preview-item';
                    div.innerHTML = `
                        <img src="${e.target.result}">
                        <div class="kf-image-preview-overlay" onclick="editImage(${index})"><i class="fas fa-pen"></i></div>
                        <div class="kf-image-preview-remove" onclick="removeImage(${index})"><i class="fas fa-times"></i></div>
                    `;
                    imagePreviewGrid.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
        }

        function editImage(index) {
            currentEditingFile = selectedImages[index];
            currentEditingType = 'image';
            openMediaEditor();
        }

        function removeImage(index) {
            selectedImages.splice(index, 1);
            const dt = new DataTransfer();
            selectedImages.forEach(f => dt.items.add(f));
            imageInput.files = dt.files;
            renderImagePreviews();
            updatePreview();
            updateFileSizeDisplay();
            
            createFloatingEmoji('ðŸ—‘ï¸', window.innerWidth/2, 100);
        }

        // =================== VIDEO RECORDING FUNCTIONS ===================
        function openVideoRecorder() {
            videoRecorderModal.classList.add('active');
            startVideoPreview();
        }

        function closeVideoRecorder() {
            videoRecorderModal.classList.remove('active');
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            stopBackgroundMusic();
        }

        async function startVideoPreview() {
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: isFrontCameraVideo ? 'user' : 'environment',
                        width: { ideal: VIDEO_SETTINGS.width },
                        height: { ideal: VIDEO_SETTINGS.height }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                videoLive.srcObject = videoStream;
                await videoLive.play();
                
                videoStream.getAudioTracks().forEach(track => {
                    track.enabled = isMicOn;
                });
                
                toggleMicBtn.innerHTML = isMicOn ? 
                    '<i class="fas fa-microphone"></i>' : 
                    '<i class="fas fa-microphone-slash"></i>';
                    
            } catch (err) {
                console.error('Camera error:', err);
                showAlert('camera access', 'Camera access is required to record video.', 'ðŸ“·', [
                    {text: 'got it', type: 'primary'}
                ]);
                closeVideoRecorder();
            }
        }

        function toggleVideoRecording() {
            if (!isRecordingVideo) {
                startVideoRecording();
            } else {
                stopVideoRecording();
            }
        }

        async function startVideoRecording() {
            try {
                // Ensure audio context is ready
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state !== 'running') {
                    await audioContext.resume();
                }
                
                // Create destination node for mixing
                destinationNode = audioContext.createMediaStreamDestination();
                
                // Handle microphone audio
                const micAudioTrack = videoStream.getAudioTracks()[0];
                if (micAudioTrack) {
                    const micStream = new MediaStream([micAudioTrack]);
                    const micSource = audioContext.createMediaStreamSource(micStream);
                    
                    micGainNode = audioContext.createGain();
                    micGainNode.gain.value = isMicOn ? 1.0 : 0.0;
                    
                    micSource.connect(micGainNode).connect(destinationNode);
                }
                
                // Handle background music if selected
                if (musicBuffer) {
                    musicSourceNode = audioContext.createBufferSource();
                    musicSourceNode.buffer = musicBuffer;
                    musicSourceNode.loop = true;
                    
                    musicGainNode = audioContext.createGain();
                    musicGainNode.gain.value = 0.5;
                    
                    musicSourceNode.connect(musicGainNode).connect(destinationNode);
                    musicSourceNode.connect(musicGainNode).connect(audioContext.destination);
                    
                    musicStartTime = audioContext.currentTime;
                    musicSourceNode.start(0);
                    isMusicPlaying = true;
                }
                
                // Create mixed stream
                const videoTrack = videoStream.getVideoTracks()[0];
                const mixedAudioTrack = destinationNode.stream.getAudioTracks()[0];
                
                let mixedStream;
                if (mixedAudioTrack) {
                    mixedStream = new MediaStream([videoTrack, mixedAudioTrack]);
                } else {
                    mixedStream = new MediaStream([videoTrack]);
                }
                
                // Configure MediaRecorder
                const options = {
                    mimeType: 'video/webm;codecs=vp9,opus',
                    videoBitsPerSecond: VIDEO_SETTINGS.bitrate
                };
                
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm;codecs=vp8,opus';
                    options.videoBitsPerSecond = VIDEO_SETTINGS.bitrate * 1.2;
                }
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm';
                }
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = '';
                }
                
                videoMediaRecorder = new MediaRecorder(mixedStream, options);
                videoChunks = [];
                
                videoMediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        videoChunks.push(event.data);
                    }
                };
                
                videoMediaRecorder.onstop = () => {
                    // Stop music
                    if (musicSourceNode) {
                        try {
                            musicSourceNode.stop();
                        } catch(e) {}
                        musicSourceNode.disconnect();
                        musicSourceNode = null;
                        isMusicPlaying = false;
                    }
                    
                    const videoBlob = new Blob(videoChunks, { type: 'video/webm' });
                    currentVideoBlob = videoBlob;
                    
                    const videoUrl = URL.createObjectURL(videoBlob);
                    videoElement.src = videoUrl;
                    videoElement.load();
                    
                    videoPlayer.classList.add('active');
                    videoRecorderModal.classList.remove('active');
                    
                    if (videoStream) {
                        videoStream.getTracks().forEach(track => track.stop());
                        videoStream = null;
                    }
                    
                    videoRecordBtn.classList.remove('recording');
                    recordingIndicator.classList.add('hidden');
                    finishRecordingBtn.style.display = 'none';
                    recorderTimer.textContent = '00:00';
                    
                    // Update UI
                    const videoStatusText = document.getElementById('videoRecordingText');
                    if (videoStatusText) {
                        videoStatusText.textContent = genZRecordingPhrases.video[Math.floor(Math.random() * genZRecordingPhrases.video.length)];
                    }
                    videoRecordingStatus.classList.add('hidden');
                    
                    // Save to file input
                    const file = new File([videoBlob], 'recorded_video.webm', { type: 'video/webm' });
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    videoFileInput.files = dt.files;
                    
                    updatePreview();
                    updateShareButtonState();
                    
                    createFloatingEmoji('ðŸŽ¥', window.innerWidth/2, 100);
                    vibeVibrate(50);
                };
                
                videoMediaRecorder.start(1000);
                isRecordingVideo = true;
                videoRecordingStartTime = Date.now();
                
                updateVideoRecordingTimer();
                videoRecordingTimer = setInterval(updateVideoRecordingTimer, 1000);
                
                videoRecordBtn.classList.add('recording');
                recordingIndicator.classList.remove('hidden');
                finishRecordingBtn.style.display = 'block';
                
                const videoStatusText = document.getElementById('videoRecordingText');
                if (videoStatusText) {
                    videoStatusText.textContent = genZRecordingPhrases.video[Math.floor(Math.random() * genZRecordingPhrases.video.length)];
                }
                videoRecordingStatus.classList.remove('hidden');
                
            } catch (err) {
                console.error('Video recording error:', err);
                showAlert('recording error', 'Error starting recording. please try again.', 'ðŸ˜¢', [
                    {text: 'ok', type: 'primary'}
                ]);
            }
        }

        function stopVideoRecording() {
            if (videoMediaRecorder && isRecordingVideo) {
                videoMediaRecorder.stop();
                isRecordingVideo = false;
                
                clearInterval(videoRecordingTimer);
                
                videoRecordBtn.classList.remove('recording');
                recordingIndicator.classList.add('hidden');
                videoRecordingStatus.classList.add('hidden');
                
                stopBackgroundMusic();
                
                vibeVibrate([30, 50, 30]);
            }
        }

        function updateVideoRecordingTimer() {
            if (!isRecordingVideo) return;
            
            const elapsedTime = Date.now() - videoRecordingStartTime;
            const elapsedSeconds = Math.floor(elapsedTime / 1000);
            
            recorderTimer.textContent = formatTime(elapsedSeconds);
            videoRecordingTimeEl.textContent = formatTime(elapsedSeconds);
            
            if (elapsedTime >= MAX_RECORDING_TIME) {
                stopVideoRecording();
                finishVideoRecording();
            }
        }

        function finishVideoRecording() {
            if (isRecordingVideo) {
                stopVideoRecording();
            }
        }

        function cancelVideoRecording() {
            if (isRecordingVideo) {
                stopVideoRecording();
            }
            videoChunks = [];
            currentVideoBlob = null;
            videoRecorderModal.classList.remove('active');
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            stopBackgroundMusic();
        }

        async function flipVideoCamera() {
            isFrontCameraVideo = !isFrontCameraVideo;
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                await startVideoPreview();
            }
        }

        function toggleMicrophone() {
            isMicOn = !isMicOn;
            if (videoStream) {
                videoStream.getAudioTracks().forEach(track => {
                    track.enabled = isMicOn;
                });
            }
            if (micGainNode) {
                micGainNode.gain.value = isMicOn ? 1.0 : 0.0;
            }
            toggleMicBtn.innerHTML = isMicOn ? 
                '<i class="fas fa-microphone"></i>' : 
                '<i class="fas fa-microphone-slash"></i>';
        }

        function handleMusicSelect(input) {
            if (input.files.length > 0) {
                const file = input.files[0];
                
                if (!file.type.startsWith('audio/')) {
                    showAlert('invalid file', 'Please select a valid audio file.', 'ðŸŽµ', [
                        {text: 'ok', type: 'primary'}
                    ]);
                    input.value = '';
                    musicBuffer = null;
                    soundSelectionText.textContent = 'add sound';
                    return;
                }

                const fileName = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
                soundSelectionText.textContent = fileName + ' âœ“';
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        if (!audioContext) {
                            audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        }
                        if (audioContext.state !== 'running') {
                            await audioContext.resume();
                        }
                        musicBuffer = await audioContext.decodeAudioData(e.target.result);
                        
                        // If recording is already in progress, start playing
                        if (isRecordingVideo) {
                            playBackgroundMusic();
                        }
                    } catch (error) {
                        console.error('Error decoding audio:', error);
                        musicBuffer = null;
                        soundSelectionText.textContent = 'add sound';
                        showAlert('audio error', 'Could not process the audio file.', 'ðŸ˜¢', [
                            {text: 'ok', type: 'primary'}
                        ]);
                    }
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function playBackgroundMusic() {
            if (!musicBuffer || !audioContext) return;
            
            if (musicSourceNode) {
                try {
                    musicSourceNode.stop();
                } catch(e) {}
                musicSourceNode.disconnect();
            }
            
            musicSourceNode = audioContext.createBufferSource();
            musicSourceNode.buffer = musicBuffer;
            musicSourceNode.loop = true;
            
            musicGainNode = audioContext.createGain();
            musicGainNode.gain.value = 0.3;
            
            musicSourceNode.connect(musicGainNode);
            musicGainNode.connect(audioContext.destination);
            
            musicSourceNode.start(0);
            isMusicPlaying = true;
        }

        function stopBackgroundMusic() {
            if (musicSourceNode) {
                try {
                    musicSourceNode.stop();
                } catch(e) {}
                musicSourceNode.disconnect();
                musicSourceNode = null;
            }
            isMusicPlaying = false;
        }

        function handleVideoSelect(input) {
            if (input.files.length > 0) {
                const file = input.files[0];
                
                if (!file.type.startsWith('video/')) {
                    showAlert('invalid file', 'Please select a video file.', 'ðŸŽ¥', [
                        {text: 'ok', type: 'primary'}
                    ]);
                    input.value = '';
                    return;
                }
                
                if (file.size > 100 * 1024 * 1024) {
                    showAlert('file too large', 'Video file must be less than 100MB.', 'ðŸ“', [
                        {text: 'ok', type: 'primary'}
                    ]);
                    input.value = '';
                    return;
                }
                
                currentVideoBlob = file;
                const videoUrl = URL.createObjectURL(file);
                videoElement.src = videoUrl;
                videoElement.load();
                
                const dt = new DataTransfer();
                dt.items.add(file);
                videoFileInput.files = dt.files;
                
                videoPlayer.classList.add('active');
                
                updatePreview();
                updateFileSizeDisplay();
                
                createFloatingEmoji('ðŸ“¹', window.innerWidth/2, 100);
                vibeVibrate(20);
            }
            updateShareButtonState();
        }

        function keepVideo() {
            if (currentVideoBlob) {
                const file = new File([currentVideoBlob], 'recorded_video.webm', { type: 'video/webm' });
                const dt = new DataTransfer();
                dt.items.add(file);
                videoFileInput.files = dt.files;
                
                updatePreview();
                createFloatingEmoji('ðŸ’¾', window.innerWidth/2, 100);
            }
        }

        function discardVideo() {
            videoPlayer.classList.remove('active');
            videoElement.pause();
            videoElement.src = '';
            currentVideoBlob = null;
            
            videoFileInput.value = '';
            videoUploadInput.value = '';
            
            updatePreview();
            updateShareButtonState();
            
            createFloatingEmoji('ðŸ—‘ï¸', window.innerWidth/2, 100);
        }

        function closeVideoPlayer() {
            videoPlayer.classList.remove('active');
        }

        function editVideo() {
            if (currentVideoBlob) {
                currentEditingFile = currentVideoBlob;
                currentEditingType = 'video';
                openMediaEditor();
            }
        }

        // =================== Audio Recording Functions ===================
        async function startAudioRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        channelCount: 1
                    } 
                });
                
                audioMediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 64000
                });
                
                audioChunks = [];
                
                audioMediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                audioMediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    currentAudioBlob = audioBlob;
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    audioElement.src = audioUrl;
                    audioElement.load();
                    
                    audioFilename.textContent = 'recording';
                    
                    audioPlayer.classList.add('active');
                    
                    stream.getTracks().forEach(track => track.stop());
                    
                    const file = new File([audioBlob], 'recorded_audio.webm', { type: 'audio/webm' });
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    audioFileInput.files = dt.files;
                    
                    updatePreview();
                    updateFileSizeDisplay();
                    updateShareButtonState();
                    
                    const audioStatusText = document.querySelector('#recordingStatus .kf-recording-text');
                    if (audioStatusText) {
                        audioStatusText.textContent = genZRecordingPhrases.audio[Math.floor(Math.random() * genZRecordingPhrases.audio.length)];
                    }
                    
                    createFloatingEmoji('ðŸŽ¤', window.innerWidth/2, 100);
                };
                
                audioMediaRecorder.start(100);
                isRecordingAudio = true;
                audioRecordingStartTime = Date.now();
                
                audioRecordingTimer = setInterval(updateAudioRecordingTimer, 1000);
                
                recordingStatus.classList.remove('hidden');
                vibeVibrate(30);
                
            } catch(err) {
                showAlert('microphone access', 'Microphone access is required to record audio.', 'ðŸŽ¤', [
                    {text: 'got it', type: 'primary'}
                ]);
                console.error('Recording error:', err);
            }
        }

        function updateAudioRecordingTimer() {
            if (!isRecordingAudio) return;
            const elapsedSeconds = Math.floor((Date.now() - audioRecordingStartTime) / 1000);
            recordingTimeEl.textContent = formatTime(elapsedSeconds);
        }

        function stopAudioRecording() {
            if (audioMediaRecorder && isRecordingAudio) {
                audioMediaRecorder.stop();
                isRecordingAudio = false;
                
                clearInterval(audioRecordingTimer);
                
                recordingStatus.classList.add('hidden');
                
                createFloatingEmoji('â¹ï¸', window.innerWidth/2, 100);
                vibeVibrate([30, 50, 30]);
            }
        }

        function handleAudioSelect(input) {
            if (input.files.length > 0) {
                const file = input.files[0];
                
                if (!file.type.startsWith('audio/')) {
                    showAlert('invalid file', 'Please select an audio file.', 'ðŸŽµ', [
                        {text: 'ok', type: 'primary'}
                    ]);
                    input.value = '';
                    return;
                }
                
                currentAudioBlob = file;
                const audioUrl = URL.createObjectURL(file);
                audioElement.src = audioUrl;
                audioElement.load();
                
                const dt = new DataTransfer();
                dt.items.add(file);
                audioFileInput.files = dt.files;
                
                audioFilename.textContent = file.name.length > 30 ? file.name.substring(0, 27) + '...' : file.name;
                
                audioPlayer.classList.add('active');
                
                updatePreview();
                updateFileSizeDisplay();
                
                createFloatingEmoji('ðŸ“»', window.innerWidth/2, 100);
                vibeVibrate(20);
            }
            updateShareButtonState();
        }

        function keepAudio() {
            if (currentAudioBlob) {
                const file = new File([currentAudioBlob], 'recorded_audio.webm', { type: 'audio/webm' });
                const dt = new DataTransfer();
                dt.items.add(file);
                audioFileInput.files = dt.files;
                
                updatePreview();
                createFloatingEmoji('ðŸ’¾', window.innerWidth/2, 100);
            }
        }

        function discardAudio() {
            audioPlayer.classList.remove('active');
            audioElement.pause();
            audioElement.src = '';
            currentAudioBlob = null;
            isPlaying = false;
            
            audioFileInput.value = '';
            audioUploadInput.value = '';
            
            updatePreview();
            updateShareButtonState();
            
            createFloatingEmoji('ðŸ—‘ï¸', window.innerWidth/2, 100);
        }

        function closeAudioPlayer() {
            audioPlayer.classList.remove('active');
        }

        // Audio player controls
        audioElement.volume = 0.8;

        playAudioBtn.addEventListener('click', function() {
            if (!audioElement.src) return;
            
            if (isPlaying) {
                audioElement.pause();
                playAudioBtn.innerHTML = '<i class="fas fa-play"></i>';
                playAudioBtn.classList.remove('playing');
            } else {
                audioElement.play().then(() => {
                    playAudioBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    playAudioBtn.classList.add('playing');
                }).catch(err => console.error('Playback error:', err));
            }
            isPlaying = !isPlaying;
        });

        audioElement.addEventListener('timeupdate', function() {
            if (audioElement.duration) {
                const progress = (audioElement.currentTime / audioElement.duration) * 100;
                audioProgressFilled.style.width = `${progress}%`;
                currentTimeEl.textContent = formatTime(audioElement.currentTime);
                durationTimeEl.textContent = formatTime(audioElement.duration);
            }
        });

        audioElement.addEventListener('ended', function() {
            playAudioBtn.innerHTML = '<i class="fas fa-play"></i>';
            playAudioBtn.classList.remove('playing');
            isPlaying = false;
            audioProgressFilled.style.width = '0%';
            currentTimeEl.textContent = '0:00';
        });

        audioProgress.addEventListener('click', function(e) {
            if (!audioElement.duration) return;
            const rect = audioProgress.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            audioElement.currentTime = pos * audioElement.duration;
        });

        // =================== TIKTOK EDITOR - Full Implementation ===================

        // ---- Editor state ----
        let editorCurrentFilter = 'normal';
        let editorAdjustments = { brightness: 0, contrast: 0, saturation: 0, sharpness: 0, warmth: 0, vignette: 0 };
        let currentTextColor = '#ffffff';
        let currentTextFont = 'Arial';
        let currentTextBgStyle = 'none';
        let currentFaceFilter = 'none';
        let editorSoundAudio = null;
        let editorSoundBlob = null;
        let editorDrawingStrokes = []; // for undo
        let currentBrushType = 'pen';
        let isDrawModeActive = false;
        let filterPreviews = {}; // cache of filter canvases

        // Filters definition
        const EDITOR_FILTERS = [
            { id: 'normal',    name: 'Normal',    fn: null },
            { id: 'vivid',     name: 'Vivid',     fn: d => pixelOp(d, (r,g,b) => [clamp(r*1.25), clamp(g*1.2), clamp(b*1.1)]) },
            { id: 'warm',      name: 'Warm',      fn: d => pixelOp(d, (r,g,b) => [clamp(r*1.2), clamp(g*1.0), clamp(b*0.8)]) },
            { id: 'cool',      name: 'Cool',      fn: d => pixelOp(d, (r,g,b) => [clamp(r*0.8), clamp(g*0.9), clamp(b*1.25)]) },
            { id: 'bw',        name: 'B&W',       fn: d => pixelOp(d, (r,g,b) => { const v = r*0.299+g*0.587+b*0.114; return [v,v,v]; }) },
            { id: 'vintage',   name: 'Vintage',   fn: d => pixelOp(d, (r,g,b) => [clamp(r*0.9+30), clamp(g*0.75+20), clamp(b*0.5+10)]) },
            { id: 'fade',      name: 'Fade',      fn: d => pixelOp(d, (r,g,b) => [clamp(r*0.7+60), clamp(g*0.7+60), clamp(b*0.7+60)]) },
            { id: 'drama',     name: 'Drama',     fn: d => pixelOp(d, (r,g,b) => { const v = r*0.299+g*0.587+b*0.114; return [clamp(v*0.4+r*0.6), clamp(v*0.4+g*0.6-10), clamp(v*0.4+b*0.6-20)]; }) },
            { id: 'lomo',      name: 'Lomo',      fn: d => pixelOp(d, (r,g,b) => [clamp(r*1.15), clamp(g*0.9), clamp(b*0.75)]) },
            { id: 'sepia',     name: 'Sepia',     fn: d => pixelOp(d, (r,g,b) => [clamp(r*0.393+g*0.769+b*0.189), clamp(r*0.349+g*0.686+b*0.168), clamp(r*0.272+g*0.534+b*0.131)]) },
            { id: 'neon',      name: 'Neon',      fn: d => pixelOp(d, (r,g,b) => [clamp((r>128?255:0)), clamp((g>128?255:0)), clamp(b*1.5)]) },
            { id: 'pastel',    name: 'Pastel',    fn: d => pixelOp(d, (r,g,b) => [clamp((r+255)/2), clamp((g+255)/2), clamp((b+255)/2)]) },
            { id: 'punch',     name: 'Punch',     fn: d => pixelOp(d, (r,g,b) => [clamp(r*1.4-30), clamp(g*1.2-20), clamp(b*0.85)]) },
            { id: 'moon',      name: 'Moon',      fn: d => pixelOp(d, (r,g,b) => { const v = (r+g+b)/3; return [clamp(v*1.1), clamp(v*1.05), clamp(v*1.2)]; }) },
        ];

        function clamp(v) { return Math.max(0, Math.min(255, Math.round(v))); }

        function pixelOp(imageData, fn) {
            const d = imageData.data;
            for (let i = 0; i < d.length; i += 4) {
                const [nr, ng, nb] = fn(d[i], d[i+1], d[i+2]);
                d[i] = nr; d[i+1] = ng; d[i+2] = nb;
            }
        }

        function openMediaEditor() {
            mediaEditorModal.classList.add('active');
            // Reset adjustments sliders
            ['Brightness','Contrast','Saturation','Sharpness','Warmth','Vignette'].forEach(k => {
                const sl = document.getElementById('sl' + k);
                const val = document.getElementById('val' + k);
                if (sl) sl.value = 0;
                if (val) val.textContent = '0';
            });
            editorAdjustments = { brightness: 0, contrast: 0, saturation: 0, sharpness: 0, warmth: 0, vignette: 0 };
            editorCurrentFilter = 'normal';
            currentFaceFilter = 'none';
            isDrawModeActive = false;
            editorDrawingStrokes = [];

            setTimeout(() => {
                if (currentEditingType === 'image') {
                    editorCanvas.classList.remove('hidden');
                    videoEditorElement.classList.add('hidden');
                    document.getElementById('trimTabBtn').style.display = 'none';
                    const url = URL.createObjectURL(currentEditingFile);
                    loadImageIntoEditor(url, () => {
                        buildFilterPreviews();
                    });
                } else if (currentEditingType === 'video') {
                    editorCanvas.classList.add('hidden');
                    videoEditorElement.classList.remove('hidden');
                    document.getElementById('trimTabBtn').style.display = 'flex';
                    const url = URL.createObjectURL(currentEditingFile);
                    videoEditorElement.src = url;
                    videoEditorElement.load();
                    videoEditorElement.addEventListener('loadedmetadata', () => {
                        videoDuration = videoEditorElement.duration;
                        document.getElementById('trimStart').textContent = formatTime(0);
                        document.getElementById('trimEnd').textContent = formatTime(videoDuration);
                        document.getElementById('trimStartSlider').value = 0;
                        document.getElementById('trimEndSlider').value = 100;
                    }, { once: true });
                }
                activateEditorTab('filters');
            }, 100);
        }

        function closeMediaEditor() {
            mediaEditorModal.classList.remove('active');
            overlayElements.forEach(el => el.remove());
            overlayElements = [];
            if (videoEditorElement) { videoEditorElement.pause(); videoEditorElement.src = ''; }
            if (editorSoundAudio) { editorSoundAudio.pause(); editorSoundAudio = null; }
            editorCanvas.classList.remove('draw-mode');
            isDrawModeActive = false;
            clearFaceFilter();
        }

        // ---- Dual-canvas architecture ----
        // hiResCanvas  : hidden, full original resolution â€” all pixel ops happen here
        // editorCanvas : display canvas, CSS-scaled to fit screen â€” only used for visual preview + draw capture
        let hiResCanvas = document.createElement('canvas');
        let hiResCtx = null;

        function loadImageIntoEditor(url, callback) {
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            img.onload = function() {
                originalImage = img;

                // --- Hi-res (hidden) canvas â€” full original size ---
                hiResCanvas.width  = img.naturalWidth;
                hiResCanvas.height = img.naturalHeight;
                hiResCtx = hiResCanvas.getContext('2d');
                hiResCtx.imageSmoothingEnabled = true;
                hiResCtx.imageSmoothingQuality = 'high';
                hiResCtx.drawImage(img, 0, 0);

                // --- Display canvas â€” fits on screen via CSS only ---
                // We keep the canvas internal pixel dimensions at 2Ã— CSS size
                // for crisp rendering on retina screens, but never shrink the source.
                const container = editorCanvasContainer;
                const maxW = container.clientWidth;
                const maxH = container.clientHeight;
                // devicePixelRatio for retina sharpness (capped at 3 to avoid RAM issues)
                const dpr = Math.min(window.devicePixelRatio || 1, 3);
                // Scale to fit screen at 1Ã—, then multiply by dpr for sharpness
                const displayRatio = Math.min(maxW / img.naturalWidth, maxH / img.naturalHeight, 1);
                const cssW = Math.round(img.naturalWidth  * displayRatio);
                const cssH = Math.round(img.naturalHeight * displayRatio);

                // Internal pixel size = CSS size Ã— dpr (sharp on retina)
                editorCanvas.width  = Math.round(cssW * dpr);
                editorCanvas.height = Math.round(cssH * dpr);
                // Make it appear at CSS size via style
                editorCanvas.style.width  = cssW + 'px';
                editorCanvas.style.height = cssH + 'px';

                canvasContext = editorCanvas.getContext('2d');
                canvasContext.imageSmoothingEnabled = true;
                canvasContext.imageSmoothingQuality = 'high';
                canvasContext.scale(dpr, dpr); // so all drawing uses CSS coordinates
                // Blit hi-res â†’ display canvas
                canvasContext.drawImage(hiResCanvas, 0, 0, cssW, cssH);

                if (callback) callback();
            };
            img.src = url;
        }

        // Build filter preview thumbnails with actual filtered image
        function buildFilterPreviews() {
            const scroll = document.getElementById('filterScroll');
            scroll.innerHTML = '';
            if (!originalImage) return;

            // Create a small thumbnail canvas
            const THUMB = 58;
            EDITOR_FILTERS.forEach(filter => {
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = THUMB; thumbCanvas.height = THUMB;
                const tc = thumbCanvas.getContext('2d');
                const ratio = Math.min(THUMB / originalImage.width, THUMB / originalImage.height);
                const dw = originalImage.width * ratio, dh = originalImage.height * ratio;
                const dx = (THUMB - dw) / 2, dy = (THUMB - dh) / 2;
                tc.drawImage(originalImage, dx, dy, dw, dh);

                if (filter.fn) {
                    const id = tc.getImageData(0, 0, THUMB, THUMB);
                    filter.fn(id);
                    tc.putImageData(id, 0, 0);
                }

                const opt = document.createElement('div');
                opt.className = 'kf-filter-option' + (filter.id === 'normal' ? ' active' : '');
                opt.onclick = () => applyFilter(filter.id, opt);

                const prev = document.createElement('div');
                prev.className = 'kf-filter-preview';
                prev.appendChild(thumbCanvas);
                thumbCanvas.style.cssText = 'width:100%;height:100%;object-fit:cover;border-radius:8px;';

                const name = document.createElement('span');
                name.className = 'kf-filter-name';
                name.textContent = filter.name;

                opt.appendChild(prev);
                opt.appendChild(name);
                scroll.appendChild(opt);
            });
        }

        function activateEditorTab(tabName) {
            // Update tab highlight
            document.querySelectorAll('.kf-editor-tab').forEach(t => t.classList.remove('active'));
            const tab = document.querySelector(`[data-tab="${tabName}"]`);
            if (tab) tab.classList.add('active');

            // Show correct panel
            document.querySelectorAll('.kf-editor-panel').forEach(p => p.classList.remove('active'));
            const panel = document.getElementById(tabName + 'Panel');
            if (panel) panel.classList.add('active');

            // Handle draw mode
            if (tabName === 'draw') {
                isDrawModeActive = true;
                editorCanvas.classList.add('draw-mode');
                document.getElementById('sideDrawBtn').classList.add('active-tool');
            } else {
                isDrawModeActive = false;
                editorCanvas.classList.remove('draw-mode');
                document.getElementById('sideDrawBtn').classList.remove('active-tool');
            }
        }

        // Sync hi-res canvas â†’ display canvas (called after every pixel operation)
        function syncHiResToDisplay() {
            if (!canvasContext || !hiResCtx) return;
            const cssW = parseInt(editorCanvas.style.width)  || editorCanvas.width;
            const cssH = parseInt(editorCanvas.style.height) || editorCanvas.height;
            canvasContext.clearRect(0, 0, cssW, cssH);
            canvasContext.drawImage(hiResCanvas, 0, 0, cssW, cssH);
        }

        // =================== FILTER APPLICATION ===================
        function applyFilter(filterId, el) {
            if (!hiResCtx || !originalImage) return;
            editorCurrentFilter = filterId;

            // Reset hi-res canvas to original image
            hiResCtx.drawImage(originalImage, 0, 0, hiResCanvas.width, hiResCanvas.height);

            // Apply filter on hi-res canvas
            const filter = EDITOR_FILTERS.find(f => f.id === filterId);
            if (filter && filter.fn) {
                const id = hiResCtx.getImageData(0, 0, hiResCanvas.width, hiResCanvas.height);
                filter.fn(id);
                hiResCtx.putImageData(id, 0, 0);
            }

            // Re-apply adjustments on top (no base redraw since we just did it)
            applyAdjustments(false);

            // Sync to display canvas
            syncHiResToDisplay();

            // Update active state
            document.querySelectorAll('.kf-filter-option').forEach(o => o.classList.remove('active'));
            if (el) el.classList.add('active');
        }

        // =================== ADJUSTMENTS ===================
        function applyAdjustments(redrawBase = true) {
            if (!hiResCtx || !originalImage) return;

            // Update display values
            ['Brightness','Contrast','Saturation','Sharpness','Warmth','Vignette'].forEach(k => {
                const sl = document.getElementById('sl' + k);
                const val = document.getElementById('val' + k);
                if (sl && val) {
                    val.textContent = sl.value;
                    editorAdjustments[k.toLowerCase()] = parseInt(sl.value);
                }
            });

            if (redrawBase) {
                // Redraw hi-res canvas with current filter
                hiResCtx.drawImage(originalImage, 0, 0, hiResCanvas.width, hiResCanvas.height);
                const filter = EDITOR_FILTERS.find(f => f.id === editorCurrentFilter);
                if (filter && filter.fn) {
                    const id = hiResCtx.getImageData(0, 0, hiResCanvas.width, hiResCanvas.height);
                    filter.fn(id);
                    hiResCtx.putImageData(id, 0, 0);
                }
            }

            const { brightness, contrast, saturation, warmth, vignette } = editorAdjustments;

            // Pixel operations on full-res canvas
            const id = hiResCtx.getImageData(0, 0, hiResCanvas.width, hiResCanvas.height);
            const d = id.data;
            const cf = (259 * (contrast + 255)) / (255 * (259 - contrast));

            for (let i = 0; i < d.length; i += 4) {
                let r = d[i], g = d[i+1], b = d[i+2];
                r = clamp(r + brightness * 2.55);
                g = clamp(g + brightness * 2.55);
                b = clamp(b + brightness * 2.55);
                r = clamp(cf * (r - 128) + 128);
                g = clamp(cf * (g - 128) + 128);
                b = clamp(cf * (b - 128) + 128);
                const lum = 0.299*r + 0.587*g + 0.114*b;
                const sf = 1 + saturation / 100;
                r = clamp(lum + (r - lum) * sf);
                g = clamp(lum + (g - lum) * sf);
                b = clamp(lum + (b - lum) * sf);
                r = clamp(r + warmth * 1.5);
                b = clamp(b - warmth * 1.5);
                d[i] = r; d[i+1] = g; d[i+2] = b;
            }
            hiResCtx.putImageData(id, 0, 0);

            // Vignette on hi-res canvas
            if (vignette > 0) {
                const w = hiResCanvas.width, h = hiResCanvas.height;
                const grad = hiResCtx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.3, w/2, h/2, Math.max(w,h)*0.75);
                grad.addColorStop(0, 'rgba(0,0,0,0)');
                grad.addColorStop(1, `rgba(0,0,0,${vignette/100 * 0.85})`);
                hiResCtx.fillStyle = grad;
                hiResCtx.fillRect(0, 0, w, h);
            }

            // Push to display canvas
            syncHiResToDisplay();
        }

        // =================== FACE FILTERS (emoji-based overlay) ===================
        function applyFaceFilter(name, el) {
            currentFaceFilter = name;
            document.querySelectorAll('.kf-face-filter-btn').forEach(b => b.classList.remove('active'));
            if (el) el.classList.add('active');

            clearFaceFilter();
            if (name === 'none') return;

            // Place face filter overlay as a draggable emoji element
            const faceEmojis = {
                dog: 'ðŸ¶', cat: 'ðŸ±', bunny: 'ðŸ°', alien: 'ðŸ‘½',
                crown: 'ðŸ‘‘', glasses: 'ðŸ•¶ï¸', fire: 'ðŸ”¥', rainbow: 'ðŸŒˆ',
                stars: 'â­', hearts: 'ðŸ’•', clown: 'ðŸ¤¡'
            };
            const emoji = faceEmojis[name] || 'ðŸ˜€';

            // Create as draggable overlay centered at top of image
            const div = document.createElement('div');
            div.className = 'kf-editor-overlay-text';
            div.dataset.faceFilter = name;
            div.textContent = emoji;
            div.style.fontSize = '64px';
            div.style.background = 'transparent';
            div.style.border = '2px dashed rgba(255,255,255,0.4)';
            div.style.padding = '6px';
            div.style.left = '50%';
            div.style.top = '25%';

            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'kf-overlay-delete';
            deleteBtn.innerHTML = 'âœ•';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                div.remove();
                overlayElements = overlayElements.filter(el => el !== div);
                currentFaceFilter = 'none';
                document.querySelectorAll('.kf-face-filter-btn').forEach(b => b.classList.remove('active'));
                document.querySelector('.kf-face-filter-btn').classList.add('active');
            };
            div.appendChild(deleteBtn);

            makeDraggable(div);
            div.addEventListener('click', (e) => { e.stopPropagation(); selectOverlay(div); });
            editorCanvasContainer.appendChild(div);
            overlayElements.push(div);
            selectOverlay(div);
            createFloatingEmoji(emoji, window.innerWidth/2, 100);
        }

        function clearFaceFilter() {
            overlayElements.filter(el => el.dataset.faceFilter)
                           .forEach(el => { el.remove(); });
            overlayElements = overlayElements.filter(el => !el.dataset.faceFilter);
        }

        // =================== TEXT OVERLAY ===================
        function addTextOverlay() {
            const input = document.getElementById('editorTextInput');
            input.classList.remove('hidden');
            input.focus();
            input.value = '';

            const done = () => {
                const text = input.value.trim();
                if (text) {
                    createDraggableElement(text, 'text');
                }
                input.classList.add('hidden');
                input.removeEventListener('change', done);
                input.removeEventListener('keydown', keyDone);
            };
            const keyDone = (e) => { if (e.key === 'Enter') done(); };
            input.addEventListener('change', done, { once: true });
            input.addEventListener('keydown', keyDone);
        }

        function setTextColor(color, dot) {
            currentTextColor = color;
            if (dot) {
                document.querySelectorAll('.kf-text-row .kf-color-dot').forEach(d => d.classList.remove('active'));
                dot.classList.add('active');
            }
            if (activeOverlayElement) activeOverlayElement.style.color = color;
        }

        function setTextFont(font, btn) {
            currentTextFont = font;
            if (btn) {
                document.querySelectorAll('.kf-font-chip').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            }
            if (activeOverlayElement) activeOverlayElement.style.fontFamily = font;
        }

        function setTextBgStyle(style, btn) {
            currentTextBgStyle = style;
            ['bgStyleNone','bgStyleDark','bgStyleLight','bgStyleColor'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.remove('active');
            });
            if (btn) btn.classList.add('active');
            if (activeOverlayElement) {
                activeOverlayElement.classList.remove('no-bg','bg-dark','bg-light','bg-color');
                if (style !== 'none') activeOverlayElement.classList.add(style);
                if (style === 'bg-color') {
                    activeOverlayElement.style.backgroundColor = currentTextColor + '99';
                } else {
                    activeOverlayElement.style.backgroundColor = '';
                }
            }
        }

        function increaseTextSize() {
            if (!activeOverlayElement) return;
            const cur = parseInt(activeOverlayElement.style.fontSize) || 28;
            activeOverlayElement.style.fontSize = (cur + 4) + 'px';
        }
        function decreaseTextSize() {
            if (!activeOverlayElement) return;
            const cur = parseInt(activeOverlayElement.style.fontSize) || 28;
            if (cur > 10) activeOverlayElement.style.fontSize = (cur - 4) + 'px';
        }

        // =================== STICKER / EMOJI OVERLAY ===================
        function addSticker(emoji) {
            createDraggableElement(emoji, 'sticker');
            createFloatingEmoji(emoji, window.innerWidth/2, 120);
            vibeVibrate(20);
        }

        function addStickerImage(emoji, name) {
            createDraggableElement(emoji, 'sticker');
        }

        // =================== IMAGE OVERLAY ===================
        function addImageOverlay(input) {
            if (!input.files || !input.files[0]) return;
            const file = input.files[0];
            const url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
                const div = document.createElement('div');
                div.className = 'kf-editor-overlay-text';
                div.style.background = 'transparent';
                div.style.border = '2px dashed rgba(255,255,255,0.4)';
                div.style.padding = '4px';
                div.style.left = '50%';
                div.style.top = '50%';
                div.style.lineHeight = '0';
                div.dataset.overlayType = 'image';

                const imgEl = document.createElement('img');
                imgEl.src = url;
                imgEl.style.cssText = 'width:80px;height:80px;object-fit:contain;display:block;border-radius:4px;';
                div.appendChild(imgEl);

                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'kf-overlay-delete';
                deleteBtn.innerHTML = 'âœ•';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    div.remove();
                    overlayElements = overlayElements.filter(el => el !== div);
                };
                div.appendChild(deleteBtn);

                // Resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'kf-overlay-resize';
                resizeHandle.innerHTML = 'â†”';
                resizeHandle.addEventListener('mousedown', startResizeOverlay);
                resizeHandle.addEventListener('touchstart', startResizeOverlay, { passive: false });
                div.appendChild(resizeHandle);

                makeDraggable(div);
                div.addEventListener('click', (e) => { e.stopPropagation(); selectOverlay(div); });
                editorCanvasContainer.appendChild(div);
                overlayElements.push(div);
                selectOverlay(div);
            };
            img.src = url;
            input.value = '';
        }

        // Resize overlay
        let isResizing = false, resizeEl = null, resizeStartX = 0, resizeStartSize = 0;
        function startResizeOverlay(e) {
            e.preventDefault(); e.stopPropagation();
            isResizing = true;
            resizeEl = e.currentTarget.closest('.kf-editor-overlay-text');
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            resizeStartX = clientX;
            const img = resizeEl.querySelector('img');
            resizeStartSize = img ? parseInt(img.style.width) || 80 : 80;
            document.addEventListener('mousemove', doResize);
            document.addEventListener('touchmove', doResize, { passive: false });
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchend', stopResize);
        }
        function doResize(e) {
            if (!isResizing || !resizeEl) return;
            e.preventDefault();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const delta = clientX - resizeStartX;
            const newSize = Math.max(40, Math.min(300, resizeStartSize + delta));
            const img = resizeEl.querySelector('img');
            if (img) { img.style.width = newSize + 'px'; img.style.height = newSize + 'px'; }
        }
        function stopResize() {
            isResizing = false; resizeEl = null;
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('touchmove', doResize);
            document.removeEventListener('mouseup', stopResize);
            document.removeEventListener('touchend', stopResize);
        }

        // =================== CREATE DRAGGABLE ELEMENT ===================
        function createDraggableElement(content, type) {
            const div = document.createElement('div');
            div.className = 'kf-editor-overlay-text';
            div.dataset.overlayType = type;

            if (type === 'sticker') {
                div.textContent = content;
                div.style.fontSize = '48px';
                div.style.background = 'transparent';
                div.style.border = '2px dashed rgba(255,255,255,0.4)';
                div.style.padding = '4px';
            } else {
                // text
                div.textContent = content;
                div.style.fontSize = '28px';
                div.style.fontFamily = currentTextFont;
                div.style.color = currentTextColor;
                // Apply current bg style
                if (currentTextBgStyle !== 'none') {
                    div.classList.add(currentTextBgStyle);
                    if (currentTextBgStyle === 'bg-color') {
                        div.style.backgroundColor = currentTextColor + '99';
                    }
                }
            }

            div.style.left = '50%';
            div.style.top = '50%';

            // Delete button
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'kf-overlay-delete';
            deleteBtn.innerHTML = 'âœ•';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                div.remove();
                overlayElements = overlayElements.filter(el => el !== div);
                if (activeOverlayElement === div) activeOverlayElement = null;
            };
            div.appendChild(deleteBtn);

            // Resize handle for text/stickers
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'kf-overlay-resize';
            resizeHandle.innerHTML = 'â†”';
            resizeHandle.addEventListener('mousedown', (e) => { e.stopPropagation(); startTextResize(e, div); });
            resizeHandle.addEventListener('touchstart', (e) => { e.stopPropagation(); startTextResize(e, div); }, { passive: false });
            div.appendChild(resizeHandle);

            makeDraggable(div);
            div.addEventListener('click', (e) => { e.stopPropagation(); selectOverlay(div); });
            editorCanvasContainer.appendChild(div);
            overlayElements.push(div);
            selectOverlay(div);
        }

        // Text/sticker resize
        let textResizeEl = null, textResizeStartX = 0, textResizeStartSize = 0;
        function startTextResize(e, el) {
            e.preventDefault();
            textResizeEl = el;
            textResizeStartX = e.clientX || (e.touches && e.touches[0].clientX);
            textResizeStartSize = parseInt(el.style.fontSize) || 28;
            document.addEventListener('mousemove', doTextResize);
            document.addEventListener('touchmove', doTextResize, { passive: false });
            document.addEventListener('mouseup', stopTextResize);
            document.addEventListener('touchend', stopTextResize);
        }
        function doTextResize(e) {
            if (!textResizeEl) return;
            e.preventDefault();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const delta = clientX - textResizeStartX;
            const newSize = Math.max(12, Math.min(120, textResizeStartSize + delta / 2));
            textResizeEl.style.fontSize = newSize + 'px';
        }
        function stopTextResize() {
            textResizeEl = null;
            document.removeEventListener('mousemove', doTextResize);
            document.removeEventListener('touchmove', doTextResize);
            document.removeEventListener('mouseup', stopTextResize);
            document.removeEventListener('touchend', stopTextResize);
        }

        // =================== DRAGGABLE OVERLAYS ===================
        function makeDraggable(element) {
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('touchstart', startDrag, { passive: false });
        }

        function selectOverlay(element) {
            overlayElements.forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            activeOverlayElement = element;
        }

        function deselectOverlay() {
            overlayElements.forEach(el => el.classList.remove('selected'));
            activeOverlayElement = null;
        }

        function startDrag(e) {
            if (e.target.classList.contains('kf-overlay-delete') || e.target.classList.contains('kf-overlay-resize')) return;
            e.preventDefault();
            const element = e.currentTarget;
            isDragging = true;
            selectOverlay(element);
            element.classList.add('dragging');
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const rect = element.getBoundingClientRect();
            dragOffset.x = clientX - rect.left;
            dragOffset.y = clientY - rect.top;
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function onDrag(e) {
            if (!isDragging || !activeOverlayElement) return;
            e.preventDefault();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const containerRect = editorCanvasContainer.getBoundingClientRect();
            const elRect = activeOverlayElement.getBoundingClientRect();
            let x = clientX - containerRect.left - dragOffset.x;
            let y = clientY - containerRect.top - dragOffset.y;
            x = Math.max(0, Math.min(x, containerRect.width - elRect.width));
            y = Math.max(0, Math.min(y, containerRect.height - elRect.height));
            activeOverlayElement.style.left = x + 'px';
            activeOverlayElement.style.top = y + 'px';
            activeOverlayElement.style.transform = 'none';
        }

        function stopDrag() {
            isDragging = false;
            if (activeOverlayElement) activeOverlayElement.classList.remove('dragging');
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('touchmove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }

        // =================== DRAWING ===================
        editorCanvas.addEventListener('mousedown', startDrawing);
        editorCanvas.addEventListener('mousemove', draw);
        editorCanvas.addEventListener('mouseup', stopDrawing);
        editorCanvas.addEventListener('mouseleave', stopDrawing);
        editorCanvas.addEventListener('touchstart', startDrawingTouch, { passive: false });
        editorCanvas.addEventListener('touchmove', drawTouch, { passive: false });
        editorCanvas.addEventListener('touchend', stopDrawing);

        function getCanvasPos(e) {
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            return {
                x: ((e.clientX || e.touches[0].clientX) - rect.left) * scaleX,
                y: ((e.clientY || e.touches[0].clientY) - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            if (!isDrawModeActive || !canvasContext) return;
            e.preventDefault();
            isDrawing = true;
            const pos = getCanvasPos(e);
            lastX = pos.x; lastY = pos.y;
            // Save hi-res snapshot for undo (ImageData is full resolution)
            editorDrawingStrokes.push(hiResCtx.getImageData(0, 0, hiResCanvas.width, hiResCanvas.height));
        }
        function startDrawingTouch(e) { startDrawing(e); }

        function applyBrushStyle() {
            if (!canvasContext) return;
            if (currentBrushType === 'pen') {
                canvasContext.globalAlpha = 1;
                canvasContext.globalCompositeOperation = 'source-over';
                canvasContext.shadowBlur = 0;
            } else if (currentBrushType === 'highlight') {
                canvasContext.globalAlpha = 0.35;
                canvasContext.globalCompositeOperation = 'source-over';
                canvasContext.shadowBlur = 0;
            } else if (currentBrushType === 'neon') {
                canvasContext.globalAlpha = 0.85;
                canvasContext.globalCompositeOperation = 'source-over';
                canvasContext.shadowBlur = 16;
                canvasContext.shadowColor = drawColor;
            } else if (currentBrushType === 'eraser') {
                canvasContext.globalAlpha = 1;
                canvasContext.globalCompositeOperation = 'destination-out';
                canvasContext.shadowBlur = 0;
            }
        }

        function applyBrushStyleCtx(ctx, shadowBlurPx) {
            if (currentBrushType === 'pen') {
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                ctx.shadowBlur = 0;
            } else if (currentBrushType === 'highlight') {
                ctx.globalAlpha = 0.35;
                ctx.globalCompositeOperation = 'source-over';
                ctx.shadowBlur = 0;
            } else if (currentBrushType === 'neon') {
                ctx.globalAlpha = 0.85;
                ctx.globalCompositeOperation = 'source-over';
                ctx.shadowBlur = shadowBlurPx;
                ctx.shadowColor = drawColor;
            } else if (currentBrushType === 'eraser') {
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'destination-out';
                ctx.shadowBlur = 0;
            }
        }

        function draw(e) {
            if (!isDrawing || !isDrawModeActive || !canvasContext) return;
            e.preventDefault();
            const pos = getCanvasPos(e);

            // --- Draw on the DISPLAY canvas (CSS coordinate space) ---
            canvasContext.beginPath();
            applyBrushStyle();
            canvasContext.strokeStyle = currentBrushType === 'eraser' ? 'rgba(0,0,0,1)' : drawColor;
            canvasContext.lineWidth = drawSize;
            canvasContext.lineCap = 'round';
            canvasContext.lineJoin = 'round';
            canvasContext.moveTo(lastX, lastY);
            canvasContext.lineTo(pos.x, pos.y);
            canvasContext.stroke();
            canvasContext.shadowBlur = 0;
            canvasContext.globalAlpha = 1;
            canvasContext.globalCompositeOperation = 'source-over';

            // --- Mirror stroke on HI-RES canvas at full original scale ---
            if (hiResCtx) {
                const cssW = parseInt(editorCanvas.style.width)  || editorCanvas.width;
                const cssH = parseInt(editorCanvas.style.height) || editorCanvas.height;
                const scaleX = hiResCanvas.width  / cssW;
                const scaleY = hiResCanvas.height / cssH;
                hiResCtx.beginPath();
                const neonBlur = Math.round(drawSize * scaleX * 3);
                applyBrushStyleCtx(hiResCtx, neonBlur);
                hiResCtx.strokeStyle = currentBrushType === 'eraser' ? 'rgba(0,0,0,1)' : drawColor;
                hiResCtx.lineWidth = drawSize * ((scaleX + scaleY) / 2);
                hiResCtx.lineCap = 'round';
                hiResCtx.lineJoin = 'round';
                hiResCtx.moveTo(lastX * scaleX, lastY * scaleY);
                hiResCtx.lineTo(pos.x * scaleX, pos.y * scaleY);
                hiResCtx.stroke();
                hiResCtx.shadowBlur = 0;
                hiResCtx.globalAlpha = 1;
                hiResCtx.globalCompositeOperation = 'source-over';
            }

            lastX = pos.x; lastY = pos.y;
        }
        function drawTouch(e) { draw(e); }

        function stopDrawing() { isDrawing = false; }

        function setDrawColor(color, dot) {
            drawColor = color;
            if (dot) {
                document.querySelectorAll('.kf-draw-color-row .kf-color-dot').forEach(d => d.classList.remove('active'));
                dot.classList.add('active');
            }
        }
        function setDrawSize(size) { drawSize = parseInt(size); }

        function setBrushType(type, btn) {
            currentBrushType = type;
            document.querySelectorAll('.kf-brush-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
        }

        function clearDraw() {
            if (!hiResCtx || !originalImage) return;
            // Reset hi-res canvas
            hiResCtx.drawImage(originalImage, 0, 0, hiResCanvas.width, hiResCanvas.height);
            const filter = EDITOR_FILTERS.find(f => f.id === editorCurrentFilter);
            if (filter && filter.fn) {
                const id = hiResCtx.getImageData(0, 0, hiResCanvas.width, hiResCanvas.height);
                filter.fn(id); hiResCtx.putImageData(id, 0, 0);
            }
            applyAdjustments(false);
            syncHiResToDisplay();
            editorDrawingStrokes = [];
        }

        function undoLastStroke() {
            if (editorDrawingStrokes.length === 0) return;
            const prev = editorDrawingStrokes.pop();
            // Restore hi-res canvas
            hiResCtx.putImageData(prev, 0, 0);
            // Sync to display
            syncHiResToDisplay();
            createFloatingEmoji('â†©', window.innerWidth/2, 100);
        }

        // =================== SOUND ===================
        function loadEditorSound(input) {
            if (!input.files || !input.files[0]) return;
            const file = input.files[0];
            editorSoundBlob = file;
            if (editorSoundAudio) { editorSoundAudio.pause(); editorSoundAudio = null; }
            editorSoundAudio = new Audio(URL.createObjectURL(file));
            editorSoundAudio.volume = 0.8;
            document.getElementById('soundUploadLabel').textContent = file.name.length > 28 ? file.name.slice(0,25)+'...' : file.name;
            document.getElementById('soundUploadTrack').classList.add('active');
            document.getElementById('soundVolRow').style.display = 'flex';
            // Show video export CTA when sound is loaded on an image
            if (currentEditingType === 'image') {
                const exportRow = document.getElementById('soundExportVideoRow');
                if (exportRow) exportRow.style.display = 'block';
            }
            createFloatingEmoji('ðŸŽµ', window.innerWidth/2, 100);
        }

        function setSoundVolume(v) {
            document.getElementById('soundVolVal').textContent = v;
            if (editorSoundAudio) editorSoundAudio.volume = v / 100;
        }

        function playEditorSound() {
            if (!editorSoundAudio) return;
            const btn = document.getElementById('soundPlayBtn');
            if (!editorSoundAudio.paused) {
                editorSoundAudio.pause();
                btn.textContent = 'â–¶ Play';
            } else {
                editorSoundAudio.currentTime = 0;
                editorSoundAudio.play();
                btn.textContent = 'â¸ Pause';
                editorSoundAudio.onended = () => { btn.textContent = 'â–¶ Play'; };
            }
        }

        function removeEditorSound() {
            if (editorSoundAudio) { editorSoundAudio.pause(); editorSoundAudio = null; }
            editorSoundBlob = null;
            document.getElementById('soundUploadLabel').textContent = 'Upload audio file...';
            document.getElementById('soundUploadTrack').classList.remove('active');
            document.getElementById('soundVolRow').style.display = 'none';
            document.getElementById('soundPlayBtn').textContent = 'â–¶ Play';
            document.getElementById('soundFileInput').value = '';
            const exportRow = document.getElementById('soundExportVideoRow');
            if (exportRow) exportRow.style.display = 'none';
        }

        // =================== RESET ===================
        function resetEdits() {
            if (currentEditingType === 'image' && originalImage && hiResCtx) {
                hiResCtx.drawImage(originalImage, 0, 0, hiResCanvas.width, hiResCanvas.height);
                syncHiResToDisplay();
                editorCurrentFilter = 'normal';
                editorAdjustments = { brightness: 0, contrast: 0, saturation: 0, sharpness: 0, warmth: 0, vignette: 0 };
                ['Brightness','Contrast','Saturation','Sharpness','Warmth','Vignette'].forEach(k => {
                    const sl = document.getElementById('sl'+k); const val = document.getElementById('val'+k);
                    if (sl) sl.value = 0; if (val) val.textContent = '0';
                });
                document.querySelectorAll('.kf-filter-option').forEach(o => o.classList.remove('active'));
                const first = document.querySelector('.kf-filter-option');
                if (first) first.classList.add('active');
                editorDrawingStrokes = [];
            } else if (currentEditingType === 'video') {
                videoEditorElement.currentTime = 0;
                videoTrimStart = 0; videoTrimEnd = 100;
                document.getElementById('trimStartSlider').value = 0;
                document.getElementById('trimEndSlider').value = 100;
                if (videoDuration) {
                    document.getElementById('trimStart').textContent = formatTime(0);
                    document.getElementById('trimEnd').textContent = formatTime(videoDuration);
                }
            }
            overlayElements.forEach(el => el.remove());
            overlayElements = [];
            currentFaceFilter = 'none';
            removeEditorSound();
            createFloatingEmoji('ðŸ”„', window.innerWidth/2, 100);
        }

        // =================== VIDEO TRIM FUNCTIONS ===================
        function updateTrimStart() {
            const slider = document.getElementById('trimStartSlider');
            const startTime = (slider.value / 100) * videoDuration;
            document.getElementById('trimStart').textContent = formatTime(startTime);
            videoTrimStart = parseFloat(slider.value);
        }
        function updateTrimEnd() {
            const slider = document.getElementById('trimEndSlider');
            const endTime = (slider.value / 100) * videoDuration;
            document.getElementById('trimEnd').textContent = formatTime(endTime);
            videoTrimEnd = parseFloat(slider.value);
        }
        function previewTrim() {
            const startTime = (videoTrimStart / 100) * videoDuration;
            const endTime = (videoTrimEnd / 100) * videoDuration;
            videoEditorElement.currentTime = startTime;
            videoEditorElement.play();
            setTimeout(() => { videoEditorElement.pause(); videoEditorElement.currentTime = startTime; }, (endTime - startTime) * 1000);
        }

        // =================== SAVE EDITED MEDIA â€” Full Original Resolution ===================
        function saveEditedMedia() {
            if (currentEditingType === 'image') {
                // The hi-res canvas already has filters + adjustments + drawings at full resolution.
                // We just need to composite the overlay elements (text, stickers, images) on top.

                const W = hiResCanvas.width;
                const H = hiResCanvas.height;

                // Final export canvas = same size as original image
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width  = W;
                exportCanvas.height = H;
                const ec = exportCanvas.getContext('2d');
                ec.imageSmoothingEnabled = true;
                ec.imageSmoothingQuality = 'high';

                // 1. Blit hi-res canvas (has all pixel edits + drawings)
                ec.drawImage(hiResCanvas, 0, 0);

                // 2. Composite overlay elements at full resolution
                const canvasRect = editorCanvas.getBoundingClientRect();
                const cssW = parseInt(editorCanvas.style.width)  || canvasRect.width;
                const cssH = parseInt(editorCanvas.style.height) || canvasRect.height;
                const scaleX = W / cssW;
                const scaleY = H / cssH;

                overlayElements.forEach(el => {
                    const elRect = el.getBoundingClientRect();
                    // Skip if fully outside the canvas viewport
                    if (elRect.right < canvasRect.left || elRect.left > canvasRect.right ||
                        elRect.bottom < canvasRect.top || elRect.top > canvasRect.bottom) return;

                    const x = (elRect.left - canvasRect.left) * scaleX;
                    const y = (elRect.top  - canvasRect.top)  * scaleY;

                    // Image overlays
                    const imgEl = el.querySelector('img');
                    if (imgEl) {
                        const iw = imgEl.offsetWidth  * scaleX;
                        const ih = imgEl.offsetHeight * scaleY;
                        ec.drawImage(imgEl, x, y, iw, ih);
                        return;
                    }

                    // Text / sticker overlays
                    const rawText = el.childNodes[0]?.textContent?.trim() || '';
                    if (!rawText) return;

                    const style = window.getComputedStyle(el);
                    const fontSize = parseFloat(style.fontSize) * scaleX;
                    ec.font = `bold ${fontSize}px ${style.fontFamily}`;
                    ec.textBaseline = 'top';

                    // Draw background if set
                    if (el.classList.contains('bg-dark') || el.classList.contains('bg-light') || el.classList.contains('bg-color')) {
                        const metrics = ec.measureText(rawText);
                        const pad = fontSize * 0.2;
                        const bgH = fontSize * 1.3;
                        ec.fillStyle = el.classList.contains('bg-light')  ? 'rgba(255,255,255,0.85)' :
                                       el.classList.contains('bg-dark')   ? 'rgba(0,0,0,0.65)'       :
                                                                             style.color.replace('rgb(','rgba(').replace(')',',0.6)');
                        ec.fillRect(x - pad, y - pad, metrics.width + pad*2, bgH + pad*2);
                    }

                    // Draw the text/emoji with shadow
                    ec.fillStyle = style.color;
                    ec.shadowColor = 'rgba(0,0,0,0.65)';
                    ec.shadowBlur  = fontSize * 0.08;
                    ec.shadowOffsetX = fontSize * 0.03;
                    ec.shadowOffsetY = fontSize * 0.03;
                    ec.fillText(rawText, x, y);
                    ec.shadowBlur = 0; ec.shadowOffsetX = 0; ec.shadowOffsetY = 0;
                });

                // 3. Export as PNG (lossless) at full original resolution
                exportCanvas.toBlob(blob => {
                    const ext  = IMAGE_QUALITY.format === 'image/png' ? 'png' : 'jpg';
                    const file = new File([blob], `edited_${Date.now()}.${ext}`, { type: IMAGE_QUALITY.format });

                    const idx = selectedImages.findIndex(f => f === currentEditingFile);
                    if (idx !== -1) {
                        selectedImages[idx] = file;
                        const dt = new DataTransfer();
                        selectedImages.forEach(f => dt.items.add(f));
                        imageInput.files = dt.files;
                        renderImagePreviews();
                    }

                    // Attach sound to post if provided
                    if (editorSoundBlob) {
                        const dt2 = new DataTransfer();
                        dt2.items.add(editorSoundBlob);
                        audioFileInput.files = dt2.files;
                        currentAudioBlob = editorSoundBlob;
                        audioPlayer.classList.add('active');
                    }

                    closeMediaEditor();
                    updatePreview();
                    updateFileSizeDisplay();
                    createFloatingEmoji('âœ¨', window.innerWidth/2, 100);
                    vibeVibrate(30);
                }, IMAGE_QUALITY.format, IMAGE_QUALITY.quality);

            } else if (currentEditingType === 'video') {
                if (videoTrimStart > 0 || videoTrimEnd < 100) {
                    showAlert('trim preview', 'Video trimming requires backend processing. The original video will be used.', 'ðŸŽ¬', [
                        { text: 'got it', type: 'primary' }
                    ]);
                }
                closeMediaEditor();
                createFloatingEmoji('ðŸŽ¬', window.innerWidth/2, 100);
            }
        }

        // =================== Other Functions ===================
        function closePost() {
            if (textarea.value.trim() || selectedImages.length > 0 || currentVideoBlob || currentAudioBlob || selectedMood || selectedCustomMood) {
                showAlert('discard vibe?', 'discard this vibe? ðŸ’”', 'ðŸ’”', [
                    {text: 'cancel', type: 'secondary'},
                    {text: 'discard', type: 'danger'}
                ]).then(result => {
                    if (result === 'discard') {
                        window.location.href = '/';
                    }
                });
            } else {
                window.location.href = '/';
            }
        }

        // Vibe Check Button
        vibeCheckBtn.addEventListener('click', function() {
            const text = textarea.value.trim();
            
            if (text) {
                const reactions = ['âœ¨ vibes immaculate', 'ðŸ”¥ no cap', 'ðŸ’… serving', 'â­ main character', 'ðŸŽµ it\'s giving', 'ðŸ’¯ hits different', 'ðŸ¥¶ sheesh', 'â¸ï¸ periodt'];
                const reaction = reactions[Math.floor(Math.random() * reactions.length)];
                
                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    color: white;
                    padding: 15px 25px;
                    border-radius: 30px;
                    font-size: 20px;
                    z-index: 10000;
                    animation: floatEmoji 2s ease-out forwards;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                popup.textContent = reaction;
                document.body.appendChild(popup);
                setTimeout(() => popup.remove(), 2000);
                
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const emojis = ['âœ¨', 'ðŸ”¥', 'ðŸ’…', 'â­', 'ðŸŽµ'];
                        createFloatingEmoji(emojis[Math.floor(Math.random() * emojis.length)], 
                            window.innerWidth/2, window.innerHeight/2);
                    }, i * 100);
                }
                
                vibeVibrate([50, 100, 50]);
            } else {
                showAlert('no text', 'add some text first bestie âœ¨', 'ðŸ’…', [
                    {text: 'ok', type: 'primary'}
                ]);
                textarea.focus();
            }
        });

        // Form submission
        document.getElementById('postForm').addEventListener('submit', function(e) {
            const hasContent = textarea.value.trim().length > 0 || selectedImages.length > 0 || currentVideoBlob || currentAudioBlob;
            
            if (!hasContent) {
                e.preventDefault();
                showAlert('empty post', 'add something bestie âœ¨', 'ðŸ’…', [
                    {text: 'ok', type: 'primary'}
                ]);
                return;
            }
            
            const randomMessage = genZLoadingMessages[Math.floor(Math.random() * genZLoadingMessages.length)];
            const randomSubtext = genZLoadingSubtexts[Math.floor(Math.random() * genZLoadingSubtexts.length)];
            loadingText.textContent = randomMessage;
            loadingSubtext.textContent = randomSubtext;
            
            loadingOverlay.classList.add('active');
            sharePostBtn.disabled = true;
            sharePostBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> posting...';
            
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const emojis = ['âœ¨', 'ðŸ”¥', 'ðŸ’…', 'â­', 'ðŸŽµ', 'ðŸš€'];
                    createFloatingEmoji(emojis[Math.floor(Math.random() * emojis.length)], 
                        window.innerWidth/2, window.innerHeight/2);
                }, i * 200);
            }
        });

        // Initialize
        updatePreview();

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            stopBackgroundMusic();
        });

        // =====================================================================
        // IMAGE â†’ VIDEO EXPORT  (Photo + Sound â†’ MP4-ish WebM)
        // =====================================================================
        let vidExportBlob = null;
        let vidExportRecorder = null;
        let vidExportCancelled = false;

        // Called from the "Export Photo + Sound as Video" button inside the editor
        function triggerImageToVideo() {
            if (!hiResCanvas || !editorSoundBlob) {
                showAlert('Missing stuff', 'Make sure you have an image + sound loaded.', 'ðŸŽµ', [{text:'Got it', type:'primary'}]);
                return;
            }
            // First bake the edited image to a final canvas
            const W = hiResCanvas.width, H = hiResCanvas.height;
            const baked = document.createElement('canvas');
            baked.width = W; baked.height = H;
            const bctx = baked.getContext('2d');
            bctx.imageSmoothingEnabled = true;
            bctx.imageSmoothingQuality = 'high';
            bctx.drawImage(hiResCanvas, 0, 0);

            // Bake text/sticker overlays
            const canvasRect = editorCanvas.getBoundingClientRect();
            const cssW = parseInt(editorCanvas.style.width) || canvasRect.width;
            const cssH = parseInt(editorCanvas.style.height) || canvasRect.height;
            const scaleX = W / cssW, scaleY = H / cssH;
            overlayElements.forEach(el => {
                const elRect = el.getBoundingClientRect();
                if (elRect.right < canvasRect.left || elRect.left > canvasRect.right ||
                    elRect.bottom < canvasRect.top  || elRect.top  > canvasRect.bottom) return;
                const x = (elRect.left - canvasRect.left) * scaleX;
                const y = (elRect.top  - canvasRect.top)  * scaleY;
                const rawText = el.childNodes[0]?.textContent?.trim() || '';
                if (!rawText) return;
                const style = window.getComputedStyle(el);
                const fontSize = parseFloat(style.fontSize) * scaleX;
                bctx.font = `bold ${fontSize}px ${style.fontFamily}`;
                bctx.textBaseline = 'top';
                bctx.fillStyle = style.color;
                bctx.shadowColor = 'rgba(0,0,0,0.65)';
                bctx.shadowBlur = fontSize * 0.08;
                bctx.fillText(rawText, x, y);
                bctx.shadowBlur = 0;
            });

            // Open export modal and start export
            openVidExportModal();
            exportImageSoundToVideo(baked, editorSoundBlob);
        }

        function openVidExportModal() {
            vidExportBlob = null;
            vidExportCancelled = false;
            document.getElementById('vidExportProgressBar').style.width = '0%';
            document.getElementById('vidExportStatus').textContent = 'Preparing...';
            document.getElementById('vidExportProgressSection').style.display = 'block';
            document.getElementById('vidExportResult').style.display = 'none';
            document.getElementById('vidExportCancelRow').style.display = 'flex';
            document.getElementById('vidExportModal').classList.add('active');
        }

        function closeVidExportModal() {
            cancelVidExport();
            document.getElementById('vidExportModal').classList.remove('active');
        }

        function cancelVidExport() {
            vidExportCancelled = true;
            if (vidExportRecorder && vidExportRecorder.state !== 'inactive') {
                try { vidExportRecorder.stop(); } catch(e) {}
            }
        }

        function setVidExportProgress(pct, status) {
            document.getElementById('vidExportProgressBar').style.width = pct + '%';
            document.getElementById('vidExportStatus').textContent = status;
        }

        async function exportImageSoundToVideo(imageCanvas, soundFile) {
            try {
                // Determine output dimensions (max 1080p, keep aspect)
                let outW = imageCanvas.width, outH = imageCanvas.height;
                const maxDim = 1080;
                if (outW > maxDim || outH > maxDim) {
                    if (outW > outH) { outH = Math.round(outH * maxDim / outW); outW = maxDim; }
                    else { outW = Math.round(outW * maxDim / outH); outH = maxDim; }
                }
                // Must be even
                outW = outW % 2 === 0 ? outW : outW - 1;
                outH = outH % 2 === 0 ? outH : outH - 1;

                setVidExportProgress(10, 'Decoding audio...');

                // Load audio duration
                const audioUrl = URL.createObjectURL(soundFile);
                const audioDur = await new Promise(res => {
                    const a = new Audio(audioUrl);
                    a.onloadedmetadata = () => res(a.duration);
                    a.onerror = () => res(10); // fallback 10s
                });
                const duration = Math.min(audioDur, 60); // cap at 60s

                setVidExportProgress(20, 'Setting up canvas...');

                // Render canvas (resized)
                const renderCanvas = document.createElement('canvas');
                renderCanvas.width = outW; renderCanvas.height = outH;
                const rctx = renderCanvas.getContext('2d');

                // Draw image with Ken Burns zoom effect over time
                const FPS = 24;
                const totalFrames = Math.ceil(duration * FPS);
                let frameIdx = 0;

                // Audio setup
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await fetch(audioUrl).then(r => r.arrayBuffer()).then(b => audioCtx.decodeAudioData(b));
                const destination = audioCtx.createMediaStreamDestination();
                const gainNode = audioCtx.createGain();
                const vol = parseFloat(document.getElementById('soundVolSlider')?.value || 80) / 100;
                gainNode.gain.value = vol;
                gainNode.connect(destination);

                // Canvas stream
                const canvasStream = renderCanvas.captureStream(FPS);
                const audioTrack = destination.stream.getAudioTracks()[0];
                const combinedStream = new MediaStream([canvasStream.getVideoTracks()[0], audioTrack]);

                // MediaRecorder
                const mimeType = ['video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm'].find(m => MediaRecorder.isTypeSupported(m)) || '';
                vidExportRecorder = new MediaRecorder(combinedStream, { mimeType, videoBitsPerSecond: 4_000_000 });
                const chunks = [];
                vidExportRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };

                vidExportRecorder.onstop = () => {
                    audioCtx.close();
                    if (vidExportCancelled) return;
                    vidExportBlob = new Blob(chunks, { type: 'video/webm' });
                    showVidExportResult(vidExportBlob);
                };

                // Start audio source right as recording starts
                const audioSource = audioCtx.createBufferSource();
                audioSource.buffer = audioBuffer;
                audioSource.connect(gainNode);

                vidExportRecorder.start(100);
                audioSource.start();

                setVidExportProgress(30, 'Recording frames...');

                // Render frame loop
                const renderFrame = () => {
                    if (vidExportCancelled) { vidExportRecorder.stop(); return; }
                    const progress = frameIdx / totalFrames; // 0..1

                    // Ken Burns: subtle zoom + pan
                    const zoom = 1 + progress * 0.08; // 1 â†’ 1.08
                    const panX = progress * outW * 0.03;
                    const panY = progress * outH * 0.02;

                    rctx.save();
                    rctx.clearRect(0, 0, outW, outH);
                    rctx.translate(outW/2 + panX, outH/2 + panY);
                    rctx.scale(zoom, zoom);
                    rctx.drawImage(imageCanvas, -outW/2, -outH/2, outW, outH);
                    rctx.restore();

                    frameIdx++;
                    const pct = 30 + Math.round((frameIdx / totalFrames) * 60);
                    if (frameIdx % 30 === 0) setVidExportProgress(pct, `Rendering frame ${frameIdx}/${totalFrames}...`);

                    if (frameIdx < totalFrames && !vidExportCancelled) {
                        setTimeout(renderFrame, 1000 / FPS);
                    } else {
                        setVidExportProgress(95, 'Finalising video...');
                        setTimeout(() => { vidExportRecorder.stop(); audioSource.stop(); }, 300);
                    }
                };
                renderFrame();

            } catch (err) {
                console.error('Video export error:', err);
                setVidExportProgress(0, 'âŒ Export failed: ' + err.message);
            }
        }

        function showVidExportResult(blob) {
            setVidExportProgress(100, 'Done! âœ¨');
            document.getElementById('vidExportProgressSection').style.display = 'none';
            document.getElementById('vidExportCancelRow').style.display = 'none';
            document.getElementById('vidExportResult').style.display = 'block';

            // Show preview video
            const url = URL.createObjectURL(blob);
            const preview = document.getElementById('vidExportPreview');
            preview.innerHTML = '';
            const vid = document.createElement('video');
            vid.src = url; vid.controls = true; vid.autoplay = false;
            vid.style.cssText = 'width:100%;border-radius:12px;margin-top:14px;background:#000;max-height:200px;';
            preview.appendChild(vid);

            createFloatingEmoji('ðŸŽ¬', window.innerWidth/2, 100);
            vibeVibrate(60);
        }

        function downloadExportedVideo() {
            if (!vidExportBlob) return;
            const a = document.createElement('a');
            a.href = URL.createObjectURL(vidExportBlob);
            a.download = `kishiface_vid_${Date.now()}.webm`;
            a.click();
            createFloatingEmoji('ðŸ’¾', window.innerWidth/2, 100);
        }

        function useExportedVideo() {
            if (!vidExportBlob) return;
            // Replace the current video in the post
            const file = new File([vidExportBlob], `photo_video_${Date.now()}.webm`, { type: 'video/webm' });
            currentVideoBlob = vidExportBlob;
            const videoUrl = URL.createObjectURL(vidExportBlob);
            document.getElementById('videoElement').src = videoUrl;
            document.getElementById('videoPlayer').classList.add('active');
            const dt = new DataTransfer();
            dt.items.add(file);
            document.getElementById('video_file').files = dt.files;
            closeVidExportModal();
            closeMediaEditor();
            updatePreview();
            updateShareButtonState();
            createFloatingEmoji('ðŸŽ¬', window.innerWidth/2, 100);
        }


        // =====================================================================
        // SLIDESHOW / VIDEO MAKER  (CapCut-style)
        // =====================================================================
        let ssClips = [];          // Array of { img: Image, file: File, dur: number }
        let ssActiveClipIdx = 0;
        let ssSoundBlob = null;
        let ssSoundAudio = null;
        let ssTransition = 'fade'; // current transition name
        let ssSlideDur = 3;        // seconds per slide
        let ssTransDur = 0.6;      // transition duration
        let ssPlaying = false;
        let ssPlayRAF = null;
        let ssPlayStartTime = null;
        let ssPreviewCtx = null;
        let ssExportCancelled = false;

        const SS_TRANSITIONS = [
            { id: 'fade',     name: 'âœ¨ Fade',     emoji: 'âœ¨' },
            { id: 'slide',    name: 'âž¡ï¸ Slide',    emoji: 'âž¡ï¸' },
            { id: 'zoom',     name: 'ðŸ” Zoom',     emoji: 'ðŸ”' },
            { id: 'wipe',     name: 'ðŸª£ Wipe',     emoji: 'ðŸª£' },
            { id: 'rotate',   name: 'ðŸŒ€ Spin',     emoji: 'ðŸŒ€' },
            { id: 'blur',     name: 'ðŸ’¨ Blur',     emoji: 'ðŸ’¨' },
            { id: 'flash',    name: 'âš¡ Flash',    emoji: 'âš¡' },
            { id: 'glitch',   name: 'ðŸŽ® Glitch',   emoji: 'ðŸŽ®' },
        ];

        function openSlideshowBuilder() {
            const modal = document.getElementById('slideshowModal');
            modal.classList.add('active');
            const canvas = document.getElementById('ssPreviewCanvas');
            ssPreviewCtx = canvas.getContext('2d');

            // Pre-load existing selected images as clips
            if (ssClips.length === 0 && selectedImages.length > 0) {
                Promise.all(selectedImages.map(f => new Promise(res => {
                    const img = new Image();
                    const url = URL.createObjectURL(f);
                    img.onload = () => { URL.revokeObjectURL(url); res({ img, file: f, dur: ssSlideDur }); };
                    img.src = url;
                }))).then(clips => { ssClips = clips; renderSsTimeline(); renderSsPreviewFrame(0, 0); });
            } else {
                renderSsTimeline();
                if (ssClips.length > 0) renderSsPreviewFrame(0, 0);
            }

            buildSsTransitionBtns();
            updateSsTotalDur();
        }

        function closeSlideshowBuilder() {
            stopSlideshowPreview();
            document.getElementById('slideshowModal').classList.remove('active');
        }

        function buildSsTransitionBtns() {
            const row = document.getElementById('ssTransitionRow');
            if (!row) return;
            row.innerHTML = '';
            SS_TRANSITIONS.forEach(t => {
                const btn = document.createElement('button');
                btn.className = 'kf-ss-transition-btn' + (t.id === ssTransition ? ' active' : '');
                btn.innerHTML = t.name;
                btn.onclick = () => {
                    ssTransition = t.id;
                    document.querySelectorAll('.kf-ss-transition-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                };
                row.appendChild(btn);
            });
        }

        function updateSsSlideDur() {
            ssSlideDur = parseFloat(document.getElementById('ssSlideDur').value);
            document.getElementById('ssSlideDurVal').textContent = ssSlideDur + 's';
            ssClips.forEach(c => c.dur = ssSlideDur);
            updateSsTotalDur();
            renderSsTimeline();
        }
        function updateSsTransDur() {
            ssTransDur = parseFloat(document.getElementById('ssTransDur').value);
            document.getElementById('ssTransDurVal').textContent = ssTransDur + 's';
        }
        function updateSsTotalDur() {
            const total = ssClips.reduce((s, c) => s + c.dur, 0) + ssTransDur * Math.max(0, ssClips.length - 1);
            document.getElementById('ssTotalDurLabel').textContent = Math.round(total * 10) / 10 + 's';
        }

        function loadSsSound(input) {
            if (!input.files || !input.files[0]) return;
            ssSoundBlob = input.files[0];
            if (ssSoundAudio) ssSoundAudio.pause();
            ssSoundAudio = new Audio(URL.createObjectURL(ssSoundBlob));
            const btn = document.getElementById('ssSoundBtn');
            if (btn) btn.classList.add('has-sound');
            document.getElementById('ssSoundName').textContent = ssSoundBlob.name.length > 30 ? ssSoundBlob.name.slice(0,27)+'...' : ssSoundBlob.name;
            document.getElementById('ssSoundRemoveBtn').style.display = 'block';
            createFloatingEmoji('ðŸŽµ', window.innerWidth/2, 100);
        }
        function removeSsSound() {
            if (ssSoundAudio) { ssSoundAudio.pause(); ssSoundAudio = null; }
            ssSoundBlob = null;
            const btn = document.getElementById('ssSoundBtn');
            if (btn) btn.classList.remove('has-sound');
            document.getElementById('ssSoundName').textContent = 'No audio selected';
            document.getElementById('ssSoundRemoveBtn').style.display = 'none';
            document.getElementById('ssSoundInput').value = '';
        }

        // ---- Timeline ----
        function renderSsTimeline() {
            const strip = document.getElementById('ssTimelineStrip');
            if (!strip) return;
            strip.innerHTML = '';

            ssClips.forEach((clip, i) => {
                // Transition connector (before each clip except first)
                if (i > 0) {
                    const conn = document.createElement('div');
                    conn.className = 'kf-ss-transition-connector';
                    const tName = SS_TRANSITIONS.find(t => t.id === ssTransition)?.emoji || 'âœ¨';
                    conn.innerHTML = `<div class="kf-ss-tc-icon" title="Change transition" onclick="cycleTransition()">${tName}</div><span class="kf-ss-tc-label">${ssTransDur}s</span>`;
                    strip.appendChild(conn);
                }

                const clipEl = document.createElement('div');
                clipEl.className = 'kf-ss-clip' + (i === ssActiveClipIdx ? ' active' : '');
                clipEl.innerHTML = `
                    <img src="${clip.img.src}" loading="lazy">
                    <span class="kf-ss-clip-idx">${i+1}</span>
                    <span class="kf-ss-clip-dur">${clip.dur}s</span>
                    <span class="kf-ss-clip-del" onclick="removeSsClip(${i})">âœ•</span>
                `;
                clipEl.onclick = (e) => { if(e.target.classList.contains('kf-ss-clip-del')) return; selectSsClip(i); };
                strip.appendChild(clipEl);
            });

            // Add clip button
            const addBtn = document.createElement('label');
            addBtn.className = 'kf-ss-add-clip';
            addBtn.title = 'Add photos';
            addBtn.innerHTML = `<i class="fas fa-plus"></i><input type="file" accept="image/*" multiple style="display:none;" onchange="addSsClipsFromFiles(this)">`;
            strip.appendChild(addBtn);

            updateSsTotalDur();
        }

        function selectSsClip(i) {
            ssActiveClipIdx = i;
            renderSsTimeline();
            renderSsPreviewFrame(0, 0);
        }

        function removeSsClip(i) {
            ssClips.splice(i, 1);
            ssActiveClipIdx = Math.min(ssActiveClipIdx, Math.max(0, ssClips.length - 1));
            renderSsTimeline();
            if (ssClips.length > 0) renderSsPreviewFrame(0, 0);
            else { ssPreviewCtx && ssPreviewCtx.clearRect(0, 0, 540, 960); }
        }

        function addSsClipsFromFiles(input) {
            const files = Array.from(input.files);
            Promise.all(files.map(f => new Promise(res => {
                const img = new Image();
                const url = URL.createObjectURL(f);
                img.onload = () => { URL.revokeObjectURL(url); res({ img, file: f, dur: ssSlideDur }); };
                img.src = url;
            }))).then(clips => {
                ssClips = [...ssClips, ...clips];
                renderSsTimeline();
                if (ssClips.length === clips.length) renderSsPreviewFrame(0, 0); // first add
            });
        }

        function cycleTransition() {
            const idx = SS_TRANSITIONS.findIndex(t => t.id === ssTransition);
            ssTransition = SS_TRANSITIONS[(idx+1) % SS_TRANSITIONS.length].id;
            buildSsTransitionBtns();
            renderSsTimeline();
        }

        // ---- Preview rendering ----
        // progress: 0..1 (within a single clip), transProgress: 0..1 (transition to next)
        function renderSsPreviewFrame(clipProgress, transProgress) {
            if (!ssPreviewCtx || ssClips.length === 0) return;
            const canvas = document.getElementById('ssPreviewCanvas');
            const W = canvas.width, H = canvas.height;
            const ctx = ssPreviewCtx;
            const clip = ssClips[ssActiveClipIdx];
            const nextClip = ssClips[ssActiveClipIdx + 1];

            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, W, H);

            const drawCoverFit = (img, alpha, transform) => {
                ctx.save();
                ctx.globalAlpha = alpha;
                if (transform) transform();
                const iw = img.naturalWidth || img.width, ih = img.naturalHeight || img.height;
                const iAsp = iw/ih, cAsp = W/H;
                let dw, dh, dx, dy;
                if (iAsp > cAsp) { dh=H; dw=H*iAsp; } else { dw=W; dh=W/iAsp; }
                dx=(W-dw)/2; dy=(H-dh)/2;
                // Ken Burns: subtle zoom
                const zoom = 1 + clipProgress * 0.06;
                ctx.translate(W/2, H/2);
                ctx.scale(zoom, zoom);
                ctx.drawImage(img, dx-W/2, dy-H/2, dw, dh);
                ctx.restore();
            };

            if (transProgress > 0 && nextClip) {
                const t = transProgress;
                applyTransition(ctx, clip.img, nextClip.img, t, W, H, clipProgress, drawCoverFit);
            } else {
                drawCoverFit(clip.img, 1, null);
            }
        }

        function applyTransition(ctx, imgA, imgB, t, W, H, clipProg, drawCoverFit) {
            const drawImg = (img, alpha, customFn) => {
                ctx.save(); ctx.globalAlpha = alpha;
                const iw = img.naturalWidth||img.width, ih = img.naturalHeight||img.height;
                const iAsp = iw/ih, cAsp = W/H;
                let dw,dh,dx,dy;
                if(iAsp>cAsp){dh=H;dw=H*iAsp;}else{dw=W;dh=W/iAsp;}
                dx=(W-dw)/2; dy=(H-dh)/2;
                if(customFn) customFn(img,dx,dy,dw,dh);
                else ctx.drawImage(img,dx,dy,dw,dh);
                ctx.restore();
            };

            ctx.clearRect(0,0,W,H);
            ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

            switch(ssTransition) {
                case 'fade':
                    drawImg(imgA, 1-t); drawImg(imgB, t); break;
                case 'slide':
                    drawImg(imgA, 1, (img,dx,dy,dw,dh)=>{ ctx.drawImage(img,dx-W*t,dy,dw,dh); });
                    drawImg(imgB, 1, (img,dx,dy,dw,dh)=>{ ctx.drawImage(img,dx+W*(1-t),dy,dw,dh); }); break;
                case 'zoom':
                    drawImg(imgA, 1-t, (img,dx,dy,dw,dh)=>{ const z=1+t*0.4; ctx.save();ctx.translate(W/2,H/2);ctx.scale(z,z);ctx.drawImage(img,dx-W/2,dy-H/2,dw,dh);ctx.restore(); });
                    drawImg(imgB, t); break;
                case 'wipe': {
                    const clip_x = W * t;
                    drawImg(imgA, 1);
                    ctx.save(); ctx.beginPath(); ctx.rect(0,0,clip_x,H); ctx.clip();
                    drawImg(imgB, 1); ctx.restore(); break;
                }
                case 'rotate': {
                    const angle = t * Math.PI * 0.3;
                    ctx.save(); ctx.translate(W/2,H/2); ctx.rotate(angle); ctx.translate(-W/2,-H/2);
                    drawImg(imgA, 1-t); ctx.restore();
                    ctx.save(); ctx.translate(W/2,H/2); ctx.rotate(angle-Math.PI*0.3); ctx.translate(-W/2,-H/2);
                    drawImg(imgB, t); ctx.restore(); break;
                }
                case 'blur':
                    drawImg(imgA, 1-t);
                    ctx.filter = `blur(${t*12}px)`; ctx.globalAlpha=t;
                    { const iw=imgB.naturalWidth||imgB.width,ih=imgB.naturalHeight||imgB.height;const iAsp=iw/ih,cAsp=W/H;let dw,dh,dx,dy;if(iAsp>cAsp){dh=H;dw=H*iAsp;}else{dw=W;dh=W/iAsp;}dx=(W-dw)/2;dy=(H-dh)/2;ctx.drawImage(imgB,dx,dy,dw,dh);}
                    ctx.filter='none'; ctx.globalAlpha=1; break;
                case 'flash': {
                    const flashT = t < 0.5 ? t*2 : (1-t)*2;
                    drawImg(imgA, t < 0.5 ? 1 : 0);
                    drawImg(imgB, t >= 0.5 ? 1 : 0);
                    ctx.fillStyle=`rgba(255,255,255,${flashT*0.9})`;ctx.fillRect(0,0,W,H); break;
                }
                case 'glitch': {
                    // Horizontal slice glitch
                    drawImg(imgA, 1-t);
                    if(t > 0.3) {
                        const slices = 8;
                        for(let i=0;i<slices;i++){
                            const sy = (H/slices)*i, sh = H/slices;
                            const offset = (Math.random()-0.5) * W * t * 0.4;
                            const iw=imgB.naturalWidth||imgB.width,ih=imgB.naturalHeight||imgB.height;
                            const iAsp=iw/ih,cAsp=W/H;let dw,dh,dx,dy;
                            if(iAsp>cAsp){dh=H;dw=H*iAsp;}else{dw=W;dh=W/iAsp;}dx=(W-dw)/2;dy=(H-dh)/2;
                            ctx.save();ctx.globalAlpha=t;ctx.beginPath();ctx.rect(0,sy,W,sh);ctx.clip();
                            ctx.drawImage(imgB,dx+offset,dy,dw,dh);ctx.restore();
                        }
                    }
                    break;
                }
                default: drawImg(imgA, 1-t); drawImg(imgB, t);
            }
        }

        // ---- Playback preview ----
        function toggleSlideshowPreview() {
            if (ssClips.length === 0) { showAlert('Add photos!', 'Add at least one photo to the timeline.', 'ðŸ–¼ï¸', [{text:'OK',type:'primary'}]); return; }
            if (ssPlaying) stopSlideshowPreview();
            else startSlideshowPreview();
        }

        function startSlideshowPreview() {
            ssPlaying = true;
            ssActiveClipIdx = 0;
            document.getElementById('ssPlayIcon').className = 'fas fa-stop';
            if (ssSoundAudio) { ssSoundAudio.currentTime=0; ssSoundAudio.play(); }

            const totalDur = ssClips.reduce((s,c)=>s+c.dur,0) + ssTransDur * Math.max(0,ssClips.length-1);
            ssPlayStartTime = performance.now();

            const tick = () => {
                if (!ssPlaying) return;
                const elapsed = (performance.now() - ssPlayStartTime) / 1000; // seconds
                if (elapsed >= totalDur) { stopSlideshowPreview(); return; }

                // Figure out which clip and progress we're in
                let t = elapsed;
                let ci = 0;
                for(let i=0;i<ssClips.length;i++){
                    const clipEnd = ssClips[i].dur;
                    if (t <= clipEnd) { ci=i; break; }
                    t -= clipEnd;
                    // Transition gap
                    if (i < ssClips.length-1) {
                        if (t <= ssTransDur) {
                            // In transition between clip i and i+1
                            const tp = t / ssTransDur;
                            ssActiveClipIdx = i;
                            renderSsPreviewFrame(1, tp);
                            ssPlayRAF = requestAnimationFrame(tick);
                            return;
                        }
                        t -= ssTransDur;
                    }
                }
                ssActiveClipIdx = ci;
                renderSsPreviewFrame(t / ssClips[ci].dur, 0);
                ssPlayRAF = requestAnimationFrame(tick);
            };
            ssPlayRAF = requestAnimationFrame(tick);
        }

        function stopSlideshowPreview() {
            ssPlaying = false;
            if (ssPlayRAF) { cancelAnimationFrame(ssPlayRAF); ssPlayRAF=null; }
            if (ssSoundAudio) ssSoundAudio.pause();
            document.getElementById('ssPlayIcon').className = 'fas fa-play';
            renderSsPreviewFrame(0, 0);
        }

        // ---- Export slideshow to video ----
        async function exportSlideshowVideo() {
            if (ssClips.length < 1) {
                showAlert('Need photos!', 'Add at least 1 photo to export.', 'ðŸ–¼ï¸', [{text:'OK',type:'primary'}]);
                return;
            }
            stopSlideshowPreview();
            ssExportCancelled = false;

            const exportOverlay = document.getElementById('ssExportingOverlay');
            exportOverlay.classList.add('show');

            const setSsProgress = (pct, status) => {
                document.getElementById('ssExpBar').style.width = pct + '%';
                document.getElementById('ssExpPct').textContent = Math.round(pct) + '%';
                document.getElementById('ssExpStatus').textContent = status;
            };

            try {
                const canvas = document.getElementById('ssPreviewCanvas');
                const W = canvas.width, H = canvas.height;
                const FPS = 30;
                const totalDur = ssClips.reduce((s,c)=>s+c.dur,0) + ssTransDur * Math.max(0,ssClips.length-1);
                const totalFrames = Math.ceil(totalDur * FPS);

                setSsProgress(5, 'Setting up audio...');

                // Audio pipeline
                let audioTrack = null;
                let audioCtxSs = null;
                let audioSourceSs = null;
                if (ssSoundBlob) {
                    audioCtxSs = new (window.AudioContext || window.webkitAudioContext)();
                    const ab = await fetch(URL.createObjectURL(ssSoundBlob)).then(r=>r.arrayBuffer()).then(b=>audioCtxSs.decodeAudioData(b));
                    const dest = audioCtxSs.createMediaStreamDestination();
                    const gain = audioCtxSs.createGain(); gain.gain.value = 0.9;
                    gain.connect(dest);
                    audioSourceSs = audioCtxSs.createBufferSource();
                    audioSourceSs.buffer = ab;
                    audioSourceSs.connect(gain);
                    audioTrack = dest.stream.getAudioTracks()[0];
                }

                // Stream from canvas
                const canvasStream = canvas.captureStream(FPS);
                const tracks = [canvasStream.getVideoTracks()[0]];
                if (audioTrack) tracks.push(audioTrack);
                const combined = new MediaStream(tracks);

                const mimeType = ['video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm'].find(m => MediaRecorder.isTypeSupported(m)) || '';
                const recorder = new MediaRecorder(combined, { mimeType, videoBitsPerSecond: 5_000_000 });
                const chunks = [];
                recorder.ondataavailable = e => { if(e.data.size>0) chunks.push(e.data); };

                recorder.onstop = () => {
                    if(audioCtxSs) audioCtxSs.close();
                    exportOverlay.classList.remove('show');
                    if (ssExportCancelled) return;
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    // Show download + use
                    showSsExportDone(blob);
                };

                recorder.start(100);
                if (audioSourceSs) audioSourceSs.start();

                setSsProgress(10, 'Rendering slideshow...');

                // Frame rendering loop
                let frameIdx = 0;
                const renderNextFrame = () => {
                    if (ssExportCancelled) { recorder.stop(); if(audioSourceSs){try{audioSourceSs.stop();}catch(e){}} return; }

                    const elapsed = frameIdx / FPS;
                    let t = elapsed;
                    let ci = 0, clipT = 0, transT = 0;
                    for(let i=0;i<ssClips.length;i++){
                        if (t <= ssClips[i].dur) { ci=i; clipT=t/ssClips[i].dur; break; }
                        t -= ssClips[i].dur;
                        if (i < ssClips.length-1){
                            if (t <= ssTransDur){ ci=i; clipT=1; transT=t/ssTransDur; break; }
                            t -= ssTransDur;
                        }
                        if (i === ssClips.length-1) ci=i;
                    }

                    ssActiveClipIdx = ci;
                    renderSsPreviewFrame(clipT, transT);
                    frameIdx++;

                    const pct = 10 + (frameIdx/totalFrames)*80;
                    if (frameIdx % FPS === 0) setSsProgress(pct, `Frame ${frameIdx}/${totalFrames}`);

                    if (frameIdx < totalFrames) {
                        setTimeout(renderNextFrame, 1000/FPS);
                    } else {
                        setSsProgress(95, 'Finishing up...');
                        setTimeout(() => { recorder.stop(); if(audioSourceSs){try{audioSourceSs.stop();}catch(e){}} }, 400);
                    }
                };
                renderNextFrame();

            } catch(err) {
                console.error('Slideshow export error:', err);
                exportOverlay.classList.remove('show');
                showAlert('Export failed', err.message, 'âŒ', [{text:'OK',type:'primary'}]);
            }
        }

        function showSsExportDone(blob) {
            showAlert('Video Ready! ðŸŽ¬', 'Your slideshow video is ready to save or use in your post.', 'âœ¨', [
                { text: 'ðŸ’¾ Save', type: 'primary' },
                { text: 'ðŸ“Œ Use in Post', type: 'primary' },
                { text: 'Close', type: 'secondary' }
            ]).then(action => {
                if (action === 'ðŸ’¾ Save') {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `slideshow_${Date.now()}.webm`;
                    a.click();
                } else if (action === 'ðŸ“Œ Use in Post') {
                    const file = new File([blob], `slideshow_${Date.now()}.webm`, {type:'video/webm'});
                    currentVideoBlob = blob;
                    const url = URL.createObjectURL(blob);
                    document.getElementById('videoElement').src = url;
                    document.getElementById('videoPlayer').classList.add('active');
                    const dt = new DataTransfer(); dt.items.add(file);
                    document.getElementById('video_file').files = dt.files;
                    closeSlideshowBuilder();
                    updatePreview(); updateShareButtonState();
                }
                createFloatingEmoji('ðŸŽ¬', window.innerWidth/2, 100);
                vibeVibrate(60);
            });
        }

    </script>
</body>
</html>


