<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>kishiface â€” Messages</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
<style>
/* ---------------- BASE ---------------- */
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;background:#FAFAFA;color:#111}
.main-chat-wrapper{display:flex;flex-direction:column;height:100vh;max-width:900px;margin:0 auto;background:white}
.profile-header{height:60px;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid #EFEFEF;background:white;z-index:3}
.profile-header .left{display:flex;align-items:center;gap:12px}
.profile-header img{width:40px;height:40px;border-radius:50%}
.profile-header b{font-size:16px}
.chat-container{flex:1;overflow-y:auto;padding:16px;background:white;-webkit-overflow-scrolling:touch}
.chat-container::-webkit-scrollbar{display:none}

/* ---------------- MESSAGES ---------------- */
.message{max-width:78%;padding:10px 14px;margin-bottom:10px;border-radius:20px;font-size:15px;position:relative;line-height:1.3}
.sent{margin-left:auto;background:linear-gradient(135deg,#0099ff 0%,#a033ff 100%);color:white;border-bottom-right-radius:6px}
.received{margin-right:auto;background:#F2F2F2;color:#111;border-bottom-left-radius:6px}
.time{position:absolute;font-size:10px;bottom:4px;right:8px;opacity:.85}
.received .time{color:#8E8E93}
.message{padding-bottom:22px}

/* ---------------- AUDIO PLAYER ---------------- */
.ig-audio-player{display:flex;align-items:center;gap:8px;width:210px}
.ig-play-btn{border:none;background:#fff;border-radius:50%;width:34px;height:34px;display:flex;align-items:center;justify-content:center;font-size:14px;cursor:pointer;flex-shrink:0}
.sent .ig-play-btn{background:white;color:#0099ff}
.received .ig-play-btn{background:#EFEFEF;color:#111}
.ig-progress{flex:1;height:4px;border-radius:4px;appearance:none;background:rgba(255,255,255,0.25);outline:none}
.received .ig-progress{background:#ddd}
.ig-progress::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;height:10px;width:10px;border-radius:50%;background:#fff}
.ig-ts{font-size:11px;min-width:40px;text-align:right}

/* ---------------- INPUT (kishiface DM V2) ---------------- */
.input-area{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;border-top:1px solid #EFEFEF;background:white;display:flex;align-items:center;gap:10px;z-index:40}
@media(min-width:768px){.input-area{max-width:900px;margin-left:auto;margin-right:auto;border-left:1px solid #DBDBDB;border-right:1px solid #DBDBDB}}
.left-camera{font-size:22px;color:#666;cursor:pointer;flex-shrink:0}

/* Input wrapper mimics kishiface: rounded, with icons inside */
.input-wrapper{flex:1;display:flex;align-items:center;gap:10px;background:#F2F2F2;padding:8px 12px;border-radius:28px;position:relative}
.icon-btn { background:none;border:0;font-size:20px;color:#666;cursor:pointer;flex-shrink:0 }
.input-wrapper input[type="text"]{border:0;background:transparent;outline:none;font-size:15px;flex:1;padding:6px 0}

/* emoji picker absolute inside wrapper area */
.emoji-picker {
    position: absolute;
    bottom: 56px;
    left: 8px;
    width: 320px;
    height: 260px;
    background: #ffffff;
    border: 1px solid #DBDBDB;
    border-radius: 14px;
    padding: 10px;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-gap: 6px;
    overflow-y: auto;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    z-index: 9999;
}

.emoji-picker span {
    font-size: 22px;
    cursor: pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:6px;
    border-radius:8px;
}
.emoji-picker span:hover { background:#f2f2f2; }

/* mic and send buttons to the right */
.controls{display:flex;align-items:center;gap:8px;flex-shrink:0}
#micBtn, #sendBtn{font-size:22px;color:#666;background:none;border:none;cursor:pointer}
#sendBtn{color:#0095F6;display:none}

/* recording indicator class for red pulsing mic */
.recording-indicator{color:#ff3b30;animation:pulse 1s infinite}
@keyframes pulse{0%{opacity:1}50%{opacity:.4}100%{opacity:1}}

/* ---------------- FLOATING RECORD OVERLAY ---------------- */
.record-overlay{
  position:fixed;left:50%;bottom:86px;transform:translateX(-50%);background:rgba(0,0,0,0.85);color:white;padding:10px 14px;border-radius:14px;display:flex;align-items:center;gap:12px;z-index:50;min-width:220px;max-width:90%;
  transition:opacity .18s,transform .18s;
}
.wave-canvas{width:96px;height:36px;display:block;border-radius:6px;background:transparent}
.rec-text{font-size:13px;color:#fff;opacity:.95}
.slide-to-cancel{font-size:13px;color:#f7f7f7;opacity:.9;white-space:nowrap}

/* ---------------- PREVIEW CARD ---------------- */
.preview-area{position:fixed;left:0;right:0;bottom:72px;padding:10px 12px;display:flex;align-items:center;gap:8px;background:transparent;z-index:45;justify-content:center}
.preview-card{background:white;border-radius:14px;padding:8px 10px;display:flex;align-items:center;gap:10px;border:1px solid #EDEDED}
.preview-card audio{display:none}
.preview-buttons{display:flex;gap:8px}
.btn-small{border:none;padding:8px 10px;border-radius:8px;font-weight:600;cursor:pointer}
.btn-send{background:#0095F6;color:white}
.btn-cancel{background:#fff;border:1px solid #E5E5E5;color:#111}

/* small helpers & mobile fixes */
.hint{font-size:12px;color:#8E8E93}
@supports (-webkit-touch-callout:none){
  .chat-container{padding-bottom:170px}
}
</style>
</head>
<body>

<div class="main-chat-wrapper">
  <!-- Header -->
  <div class="profile-header">
    <div class="left">
      <img src="{{ receiver.profile.picture.url }}" alt="">
      <div>
        <b>{% if receiver.profile.full_name %}{{ receiver.profile.full_name }}{% else %}{{ receiver.username }}{% endif %}</b>
        <div style="font-size:12px;color:#8E8E93">Active now</div>
      </div>
    </div>
    <div></div>
  </div>

  <!-- Messages -->
  <div id="messageOutput" class="chat-container">
    {% for label, msgs in grouped_messages.items %}
      <center><b><i>{{ label }}</i></b></center>
      {% for message in msgs %}
        {% if message.sender.username == request.user.username %}
          {% if message.conversation %}
            <div class="sent message">
              {{ message.conversation }}
              <span class="time">{{ message.chat_time }}</span>
            </div>
          {% elif message.file %}
            <div class="sent message">
              <div class="ig-audio-player">
                <button class="ig-play-btn"><i class="fa-solid fa-play"></i></button>
                <input type="range" min="0" max="100" value="0" class="ig-progress">
                <div class="ig-ts">0:00</div>
              </div>
              <audio class="audio-source" src="{{ message.file.url }}"></audio>
              <span class="time">{{ message.chat_time }}</span>
            </div>
          {% endif %}
        {% else %}
          {% if message.conversation %}
            <div class="received message">
              {{ message.conversation }}
              <span class="time">{{ message.chat_time }}</span>
            </div>
          {% elif message.file %}
            <div class="received message">
              <div class="ig-audio-player">
                <button class="ig-play-btn"><i class="fa-solid fa-play"></i></button>
                <input type="range" min="0" max="100" value="0" class="ig-progress">
                <div class="ig-ts">0:00</div>
              </div>
              <audio class="audio-source" src="{{ message.file.url }}"></audio>
              <span class="time">{{ message.chat_time }}</span>
            </div>
          {% endif %}
        {% endif %}
      {% endfor %}
    {% endfor %}
  </div>

  <!-- Input area -->
  <div class="input-area" id="inputArea">

    <div class="input-wrapper">
      <button id="emojiBtn" type="button" class="icon-btn" title="Emoji"><i class="fa-regular fa-face-smile"></i></button>

      <input id="message" type="text" placeholder="Message..." autocomplete="off">

      <label for="image" title="Add photo or video"><i class="fa-regular fa-image icon-btn"></i></label>
      <input id="image" type="file" accept="image/*" hidden>

      <!-- emoji picker container (absolute inside wrapper) -->
      <div id="emojiPicker" class="emoji-picker" style="display:none"></div>
    </div>

    <div class="controls">
      <button id="micBtn" title="Hold to record" aria-label="Hold to record"><i class="fa-solid fa-microphone"></i></button>
      <button id="sendBtn" title="Send"><i class="fa-solid fa-paper-plane"></i></button>
    </div>
  </div>
</div>

<!-- Floating record overlay (shown while holding) -->
<div id="recordOverlay" class="record-overlay" style="display:none;opacity:0;transform:translateX(-50%) translateY(10px)">
  <canvas id="waveCanvas" class="wave-canvas"></canvas>
  <div style="display:flex;flex-direction:column">
    <div class="rec-text" id="recStatus">Recording</div>
    <div style="display:flex;gap:8px;align-items:center">
      <div id="recTimer" style="font-weight:700">0:00</div>
      <div id="slideHint" class="slide-to-cancel">Slide left to cancel</div>
    </div>
  </div>
</div>

<!-- Preview card after recording -->
<div id="previewArea" class="preview-area" style="display:none">
  <div class="preview-card">
    <div style="display:flex;align-items:center;gap:10px">
      <button id="previewPlay" class="ig-play-btn"><i class="fa-solid fa-play"></i></button>
      <div style="min-width:160px">
        <input id="previewProgress" class="ig-progress" type="range" min="0" max="100" value="0">
      </div>
      <div class="ig-ts" id="previewTime">0:00</div>
    </div>
    <div class="preview-buttons" style="margin-left:8px">
      <button id="btnCancelPreview" class="btn-small btn-cancel" title="Delete"><i class="fa-solid fa-trash"></i></button>
      <button id="btnSendPreview" class="btn-small btn-send" title="Send">Send</button>
    </div>
  </div>
</div>

<script>
/* ================= WebSocket integration (keep your route) ================= */
const protocol = window.location.protocol === "https:" ? "wss://" : "ws://";
const socket = new WebSocket(protocol + window.location.host + "/ws/message/");

const receiver = "{{ receiver.username }}";
const sender = "{{ request.user.username }}";

const messageOutput = document.getElementById('messageOutput');
const messageInput = document.getElementById('message');
const imageInput = document.getElementById('image');
const micBtn = document.getElementById('micBtn');
const sendBtn = document.getElementById('sendBtn');

messageOutput.scrollTo({top: messageOutput.scrollHeight, behavior:'smooth'});

/* Initialize audio controls for existing messages */
function initAudioControls(container) {
  const player = container.querySelector('.ig-audio-player');
  if (!player) return;
  const audio = container.querySelector('.audio-source');
  const playBtn = player.querySelector('.ig-play-btn');
  const progress = player.querySelector('.ig-progress');
  const ts = player.querySelector('.ig-ts');

  playBtn.addEventListener('click', () => {
    document.querySelectorAll('.audio-source').forEach(a => { if (a !== audio && !a.paused) a.pause(); });
    if (audio.paused) audio.play(); else audio.pause();
  });
  audio.addEventListener('play', ()=> playBtn.innerHTML = '<i class="fa-solid fa-pause"></i>');
  audio.addEventListener('pause', ()=> playBtn.innerHTML = '<i class="fa-solid fa-play"></i>');
  audio.addEventListener('timeupdate', ()=> {
    if (audio.duration) {
      const p = (audio.currentTime / audio.duration) * 100;
      progress.value = p;
      ts.textContent = formatTime(audio.currentTime);
    }
  });
  audio.addEventListener('loadedmetadata', ()=> { ts.textContent = formatTime(audio.duration); });
  progress.addEventListener('input', ()=> { if (audio.duration) audio.currentTime = (progress.value/100)*audio.duration; });
}
document.querySelectorAll('.message').forEach(initAudioControls);

/* Handle incoming messages */
socket.addEventListener('message', function(e){
  const data = JSON.parse(e.data);
  const div = document.createElement('div');
  div.className = data.sender === sender ? 'sent message' : 'received message';

  if (data.message) {
    div.innerHTML = `${data.message} <span class="time">${data.time}</span>`;
  } else if (data.audio_url) {
    div.innerHTML = `<div class="ig-audio-player">
        <button class="ig-play-btn"><i class="fa-solid fa-play"></i></button>
        <input type="range" min="0" max="100" value="0" class="ig-progress">
        <div class="ig-ts">0:00</div>
      </div>
      <audio class="audio-source" src="${data.audio_url}"></audio>
      <span class="time">${data.time}</span>`;
  } else if (data.image) {
    // optional image support: show image if server sends image URL
    div.innerHTML = `<div class="received message"><img src="${data.image}" style="max-width:200px;border-radius:12px;display:block"/></div>`;
  }
  messageOutput.appendChild(div);
  initAudioControls(div);
  messageOutput.scrollTo({top:messageOutput.scrollHeight, behavior:'smooth'});
});

/* ================= Text send & send/mic toggle ================= */
sendBtn.addEventListener('click', ()=> {
  const text = messageInput.value.trim();
  const file = imageInput.files[0];
  if (!text && !file) return;

  if (file) {
    const reader = new FileReader();
    reader.onload = ()=> {
      socket.send(JSON.stringify({ type:'text', receiver, message:text, image: reader.result }));
      messageInput.value = ''; imageInput.value = ''; toggleSendMic();
    };
    reader.readAsDataURL(file);
  } else {
    socket.send(JSON.stringify({ type:'text', receiver, message:text, image: null }));
    messageInput.value = ''; toggleSendMic();
  }
});

function toggleSendMic(){
  if (messageInput.value.trim().length > 0) {
    sendBtn.style.display = 'inline-block';
    micBtn.style.display = 'none';
  } else {
    sendBtn.style.display = 'none';
    micBtn.style.display = 'inline-block';
  }
}
messageInput.addEventListener('input', toggleSendMic);
messageInput.addEventListener('keypress', e => { if (e.key === 'Enter') sendBtn.click(); });

/* ================= Emoji picker (latest emojis 2024) ================= */
const emojiBtn = document.getElementById("emojiBtn");
const emojiPicker = document.getElementById("emojiPicker");
const inputField = document.getElementById("message");

// Latest emoji subset (Unicode 15.x style â€” comprehensive enough for UI)
const emojiList = [
  "ðŸ˜€","ðŸ˜","ðŸ˜‚","ðŸ¤£","ðŸ˜ƒ","ðŸ˜„","ðŸ˜…","ðŸ˜†","ðŸ˜‰","ðŸ˜Š","ðŸ˜‹","ðŸ˜Ž","ðŸ˜","ðŸ˜˜","ðŸ¥°","ðŸ˜—","ðŸ˜™","ðŸ˜š",
  "ðŸ™‚","ðŸ¤—","ðŸ¤©","ðŸ¤”","ðŸ¤¨","ðŸ˜","ðŸ˜‘","ðŸ˜¶","ðŸ™„","ðŸ˜","ðŸ˜£","ðŸ˜¥","ðŸ˜®","ðŸ¤","ðŸ˜¯","ðŸ˜ª","ðŸ˜«","ðŸ¥±",
  "ðŸ˜´","ðŸ˜Œ","ðŸ˜›","ðŸ˜œ","ðŸ˜","ðŸ¤¤","ðŸ˜’","ðŸ˜“","ðŸ˜”","ðŸ˜•","ðŸ™ƒ","ðŸ« ","ðŸ«¡","ðŸ«£","ðŸ«¥",
  "ðŸ˜²","ðŸ™","ðŸ˜–","ðŸ˜ž","ðŸ˜Ÿ","ðŸ˜¤","ðŸ˜¢","ðŸ˜­","ðŸ˜¦","ðŸ˜§","ðŸ˜¨","ðŸ˜©","ðŸ¤¯","ðŸ˜¬","ðŸ˜°","ðŸ˜±","ðŸ¥µ","ðŸ¥¶",
  "ðŸ˜³","ðŸ¤ª","ðŸ˜µ","ðŸ¤•","ðŸ¤’","ðŸ¤¢","ðŸ¤®","ðŸ¤§","ðŸ¥´","ðŸ˜µâ€ðŸ’«","ðŸ«¨",
  "â¤ï¸","ðŸ©·","ðŸ§¡","ðŸ’›","ðŸ’š","ðŸ’™","ðŸ’œ","ðŸ–¤","ðŸ¤","ðŸ¤Ž","ðŸ’”","â¤ï¸â€ðŸ”¥","â¤ï¸â€ðŸ©¹",
  "ðŸ‘","ðŸ‘Ž","ðŸ‘Š","âœŠ","ðŸ¤›","ðŸ¤œ","ðŸ‘","ðŸ™Œ","ðŸ‘","ðŸ¤²",
  "ðŸ™","âœï¸","ðŸ’…","ðŸ¤³",
  "ðŸ‘‹","ðŸ¤","ðŸ‘Œ","ðŸ¤Œ","ðŸ¤","âœŒï¸","ðŸ¤ž","ðŸ¤Ÿ","ðŸ¤˜","ðŸ¤™","ðŸ‘ˆ","ðŸ‘‰","â˜ï¸","ðŸ‘‡","ðŸ‘†","ðŸ«µ",
  "ðŸ«¶","ðŸ¤²",
  "ðŸ¶","ðŸ±","ðŸ­","ðŸ¹","ðŸ°","ðŸ¦Š","ðŸ»","ðŸ¼","ðŸ¨","ðŸ¯","ðŸ¦","ðŸ®","ðŸ·","ðŸ¸","ðŸµ",
  "ðŸ”¥","âœ¨","ðŸŒŸ","ðŸ’«","ðŸ’¥","ðŸ’¯","âš¡","ðŸ’¢","ðŸ’¤","ðŸŽ‰","ðŸŽŠ",
  "ðŸ•","ðŸ”","ðŸŸ","ðŸŒ­","ðŸ—","ðŸ–","ðŸœ","ðŸ","ðŸ£","ðŸ©","ðŸ§",
  "ðŸš—","ðŸš•","ðŸš™","ðŸšŒ","ðŸšŽ","ðŸŽ","ðŸš“","ðŸš‘","ðŸš’",
  "âš½","ðŸ€","ðŸˆ","ðŸŽ¾","ðŸ¥Š","ðŸ¥‹","ðŸŽ®","ðŸŽ§"
];

function loadEmojis() {
  emojiPicker.innerHTML = "";
  emojiList.forEach(e => {
    const span = document.createElement("span");
    span.textContent = e;
    span.onclick = () => {
      insertAtCursor(inputField, e);
      emojiPicker.style.display = 'none';
      inputField.focus();
      toggleSendMic();
    };
    emojiPicker.appendChild(span);
  });
}
// Insert emoji into input at cursor
function insertAtCursor(field, emoji) {
  const start = field.selectionStart || 0;
  const end = field.selectionEnd || 0;
  const text = field.value;
  field.value = text.substring(0, start) + emoji + text.substring(end);
  const pos = start + emoji.length;
  field.selectionStart = field.selectionEnd = pos;
  field.focus();
}

emojiBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  if (emojiPicker.style.display === 'none' || !emojiPicker.style.display) {
    emojiPicker.style.display = 'grid';
    loadEmojis();
  } else {
    emojiPicker.style.display = 'none';
  }
});

// Close emoji picker when clicking outside
document.addEventListener("click", (e) => {
  if (!emojiPicker.contains(e.target) && e.target !== emojiBtn) {
    emojiPicker.style.display = 'none';
  }
});

/* ================= Recording System (V2 â€“ cross-device hold-to-record) ================= */

/* Elements */
const recordOverlay = document.getElementById('recordOverlay');
const waveCanvas = document.getElementById('waveCanvas');
const recTimer = document.getElementById('recTimer');
const slideHint = document.getElementById('slideHint');

const previewArea = document.getElementById('previewArea');
const previewPlay = document.getElementById('previewPlay');
const previewProgress = document.getElementById('previewProgress');
const previewTime = document.getElementById('previewTime');
const btnCancelPreview = document.getElementById('btnCancelPreview');
const btnSendPreview = document.getElementById('btnSendPreview');

let mediaRecorder = null;
let recordedChunks = [];
let audioBlob = null;
let audioContext = null;
let analyser = null;
let sourceNode = null;
let recordingStart = 0;
let timerInterval = null;
let activePointerId = null;
let isCancelled = false;
let startX = 0;
const CANCEL_THRESHOLD = 80;

/* Wave canvas setup */
const ctx = waveCanvas.getContext('2d');
function resizeCanvas() {
  waveCanvas.width = Math.floor(waveCanvas.clientWidth * devicePixelRatio);
  waveCanvas.height = Math.floor(waveCanvas.clientHeight * devicePixelRatio);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

function drawWave(dataArray, width, height) {
  ctx.clearRect(0,0,width,height);
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(0,0,width,height);

  ctx.lineWidth = 2;
  ctx.strokeStyle = '#ff3b30';
  ctx.beginPath();

  const step = Math.max(1, Math.floor(dataArray.length / width));
  let x = 0;
  for (let i = 0; i < dataArray.length; i += step) {
    const v = dataArray[i] / 128.0;
    const y = (v * height) / 2;
    if (x === 0) ctx.moveTo(x, height/2 + y - height/4);
    else ctx.lineTo(x, height/2 + y - height/4);
    x++;
  }
  ctx.stroke();
}

function startAnalyser(stream) {
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    sourceNode = audioContext.createMediaStreamSource(stream);
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 256;
    sourceNode.connect(analyser);
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const w = waveCanvas.width;
    const h = waveCanvas.height;

    (function render(){
      if (!analyser) return;
      analyser.getByteTimeDomainData(dataArray);
      drawWave(dataArray, w, h);
      requestAnimationFrame(render);
    })();
  } catch(e){ console.warn('analyser failed', e); }
}

function stopAnalyser() {
  try {
    if (analyser) analyser.disconnect();
    if (sourceNode) sourceNode.disconnect();
    if (audioContext) audioContext.close();
  } catch(e){}
  analyser = null; sourceNode = null; audioContext = null;
}

function showOverlay() {
  recordOverlay.style.display = 'flex';
  requestAnimationFrame(()=>{ recordOverlay.style.opacity = 1; recordOverlay.style.transform = 'translateX(-50%) translateY(0)'; });
}
function hideOverlay() {
  recordOverlay.style.opacity = 0;
  recordOverlay.style.transform = 'translateX(-50%) translateY(10px)';
  setTimeout(()=>{ recordOverlay.style.display = 'none'; }, 180);
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
}

function fmtTime(sec) {
  if (!isFinite(sec)) return '0:00';
  sec = Math.floor(sec);
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return `${m}:${s < 10 ? '0'+s : s}`;
}

/* begin recording stream */
async function beginRecording(pointerX) {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    recordedChunks = [];
    isCancelled = false;
    startX = pointerX || 0;

    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = () => {
      stopAnalyser();
      stream.getTracks().forEach(t => t.stop());
      if (isCancelled) {
        recordedChunks = [];
        audioBlob = null;
        hideOverlay();
        micBtn.classList.remove('recording-indicator');
        return;
      }
      audioBlob = new Blob(recordedChunks, { type:'audio/webm' });
      setupPreview(audioBlob);
      hideOverlay();
      micBtn.classList.remove('recording-indicator');
    };

    mediaRecorder.start();
    recordingStart = Date.now();
    micBtn.classList.add('recording-indicator');

    startAnalyser(stream);
    showOverlay();
    slideHint.textContent = 'Slide left to cancel';
    recTimer.textContent = '0:00';
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(()=> {
      const s = Math.floor((Date.now() - recordingStart)/1000);
      recTimer.textContent = fmtTime(s);
    }, 250);
  } catch(err) {
    console.error('getUserMedia err', err);
    alert('Microphone access denied or not supported.');
    micBtn.classList.remove('recording-indicator');
    hideOverlay();
  }
}

/* pointer-based hold-to-record */
micBtn.addEventListener('pointerdown', async (ev) => {
  try {
    ev.preventDefault();
    activePointerId = ev.pointerId;
    micBtn.setPointerCapture(activePointerId);
  } catch(e){}
  await beginRecording(ev.clientX);

  function onMove(e) {
    if (e.pointerId !== activePointerId) return;
    if (startX - e.clientX > CANCEL_THRESHOLD) {
      slideHint.textContent = 'Release to cancel';
      slideHint.style.color = '#ff3b30';
      isCancelled = true;
    } else {
      slideHint.textContent = 'Slide left to cancel';
      slideHint.style.color = '#fff';
      isCancelled = false;
    }
  }

  function onUp(e) {
    if (e.pointerId !== activePointerId) return;
    try { micBtn.releasePointerCapture(activePointerId); } catch(e){}
    if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);
    activePointerId = null;
  }

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
});

/* click fallback quick-record for desktop */
micBtn.addEventListener('click', (ev) => {
  if (mediaRecorder && mediaRecorder.state === 'recording') return;
  (async ()=>{
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      recordedChunks = [];
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = e => { if (e.data && e.data.size>0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        stopAnalyser();
        stream.getTracks().forEach(t => t.stop());
        audioBlob = new Blob(recordedChunks, { type:'audio/webm' });
        setupPreview(audioBlob);
        micBtn.classList.remove('recording-indicator');
      };
      mediaRecorder.start();
      micBtn.classList.add('recording-indicator');
      startAnalyser(stream);
      setTimeout(()=> { if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); }, 2500);
    } catch(e){}
  })();
});

/* preview setup after recording */
let previewAudio = null;
function setupPreview(blob) {
  previewArea.style.display = 'flex';
  const url = URL.createObjectURL(blob);
  if (previewAudio) { previewAudio.pause(); previewAudio = null; }
  previewAudio = new Audio(url);
  previewAudio.preload = 'metadata';
  previewTime.textContent = '0:00';
  previewProgress.value = 0;
  previewPlay.innerHTML = '<i class="fa-solid fa-play"></i>';

  previewAudio.addEventListener('loadedmetadata', ()=> {
    previewTime.textContent = fmtTime(previewAudio.duration);
    previewProgress.value = 0;
  });
  previewAudio.addEventListener('timeupdate', ()=> {
    if (previewAudio.duration) {
      previewProgress.value = (previewAudio.currentTime / previewAudio.duration) * 100;
      previewTime.textContent = fmtTime(previewAudio.currentTime);
    }
  });
  previewPlay.onclick = ()=> {
    if (previewAudio.paused) previewAudio.play(); else previewAudio.pause();
  };
  previewAudio.addEventListener('play', ()=> previewPlay.innerHTML = '<i class="fa-solid fa-pause"></i>');
  previewAudio.addEventListener('pause', ()=> previewPlay.innerHTML = '<i class="fa-solid fa-play"></i>');
  previewProgress.oninput = ()=> { if (previewAudio.duration) previewAudio.currentTime = (previewProgress.value/100) * previewAudio.duration; };

  btnCancelPreview.onclick = ()=> {
    if (previewAudio) { previewAudio.pause(); previewAudio = null; }
    previewArea.style.display = 'none';
    audioBlob = null;
  };

  btnSendPreview.onclick = ()=> {
    if (!blob) return;
    const reader = new FileReader();
    reader.onloadend = ()=> {
      socket.send(JSON.stringify({ type:'audio', receiver, audio: reader.result }));
      previewArea.style.display = 'none';
      if (previewAudio) { previewAudio.pause(); previewAudio = null; }
      audioBlob = null;
      messageOutput.scrollTo({top: messageOutput.scrollHeight, behavior:'smooth'});
    };
    reader.readAsDataURL(blob);
  };
}

/* cleanup on unload */
window.addEventListener('beforeunload', ()=> {
  try {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
    stopAnalyser();
  } catch(e){}
});

/* small util for players */
function formatTime(sec) {
  if (!sec || !isFinite(sec)) return '0:00';
  sec = Math.floor(sec);
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return `${m}:${s < 10 ? '0' + s : s}`;
}
</script>
</body>
</html>
  
